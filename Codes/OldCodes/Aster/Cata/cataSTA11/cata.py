# coding: utf-8
# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

import os
from math import sin, cos, tan, asin, acos, atan2, atan, sinh, cosh, tanh
from math import pi ,exp,log, log10, sqrt

import Accas
from Accas import *
from Accas import _F
import ops

try:
    import aster
    aster_exists = True
except ImportError:
    aster = None
    aster_exists = False

# Le catalogue est constitué par concaténation des fichiers .capy
# de catapy/{entete,commun,commande}.

# Tous les imports globaux devraient être faits ici dans accas.capy.
# Veillez à limiter les imports dans la définition des concepts (co_*.capy)
# au strict nécessaire et les faire sous les méthodes qui en ont
# expressément besoin.

JdC = JDC_CATA(code='ASTER',
               execmodul=None,
#               regles=(AU_MOINS_UN('DEBUT', 'POURSUITE'),
#                       AU_MOINS_UN('FIN'),
#                       A_CLASSER(('DEBUT', 'POURSUITE'), 'FIN'))
               )

# Types géométriques
class no(GEOM):
    """
    Classe servant à définir le nom d'un noeud dans le fichier de commande
    En clair : un chaine de longueur 8.
    """
    pass

class grno(GEOM):
    """
    Classe servant à définir le nom d'un groupe de noeuds dans le fichier de commande
    En clair : un chaine de longueur 24.
    """
    def __convert__(cls,valeur):
        """
        Fonction de verification de la longueur de la chaine
        """
        if isinstance(valeur, (str,unicode)) and len(valeur.strip()) <= 24:
            return valeur.strip()
        raise ValueError(_(u'On attend une chaine de caractères (de longueur <= 24).'))
    __convert__ = classmethod(__convert__)

class ma(GEOM):
    """
    Classe servant à définir le nom d'une maille dans le fichier de commande
    En clair : un chaine de longueur 8.
    """
    pass

class grma(GEOM):
    """
    Classe servant à définir le nom d'un groupe de mailles dans le fichier de commande
    En clair : un chaine de longueur 24.
    """
    def __convert__(cls,valeur):
        """
        Fonction de verification de la longueur de la chaine
        """
        if isinstance(valeur, (str,unicode)) and len(valeur.strip()) <= 24:
            return valeur.strip()
        raise ValueError(_(u'On attend une chaine de caractères (de longueur <= 24).'))
    __convert__ = classmethod(__convert__)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class cabl_precont(ASSD):
    cata_sdj = "SD.sd_cabl_precont.sd_cabl_precont"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class cara_elem(ASSD):
    cata_sdj = "SD.sd_cara_elem.sd_cara_elem"

    def toEPX(self):

        # Raideurs 
        ressorts = {}

        try:
           EPXnoeud = self.sdj.CARRIGXN.get()
           EPXval   = self.sdj.CARRIGXV.get()
           lenEPXval   = len(EPXval)
           lenEPXnoeud = len(EPXnoeud)*6
        except:
           # s'il y a un problème sur la structure de données ==> <F>
           from Utilitai.Utmess import UTMESS
           UTMESS('F','MODELISA9_98')
        # Vérification de la déclaration qui est faite dans 'acearp'
        if ( lenEPXval != lenEPXnoeud ):
           from Utilitai.Utmess import UTMESS
           UTMESS('F','MODELISA9_97')
        # Tout est OK
        i=0
        for no in EPXnoeud :
           ressorts[no] = EPXval[i:i+6]
           i+=6

        # Amortissements
        amorts = {}
        try:
           EPXnoeud = self.sdj.CARAMOXN.get()
           EPXval   = self.sdj.CARAMOXV.get()
           lenEPXval   = len(EPXval)
           lenEPXnoeud = len(EPXnoeud)*6
        except:
           # s'il y a un problème sur la structure de données ==> <F>
           from Utilitai.Utmess import UTMESS
           UTMESS('F','MODELISA9_98')
        # Vérification de la déclaration qui est faite dans 'acearp'
        if ( lenEPXval != lenEPXnoeud ):
           from Utilitai.Utmess import UTMESS
           UTMESS('F','MODELISA9_97')
        # Tout est OK
        i=0
        for no in EPXnoeud :
           amorts[no] = EPXval[i:i+6]
           i+=6

        return ressorts, amorts

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

class cham_gd_sdaster(ASSD):
    cata_sdj = "SD.sd_champ.sd_champ"

class carte_sdaster(cham_gd_sdaster):
    cata_sdj = "SD.sd_champ.sd_carte_class"

class cham_elem(cham_gd_sdaster):
   cata_sdj = "SD.sd_champ.sd_cham_elem_class"

   def EXTR_COMP(self,comp,lgma,topo=0) :
      """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de mailles lgma avec eventuellement l'info de la
        topologie si topo>0. Si lgma est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : numpy.array contenant les valeurs
        Si on a demande la topo  :
          - self.maille  : numero de mailles
          - self.point   : numero du point dans la maille
          - self.sous_point : numero du sous point dans la maille """
      import numpy
      if not self.accessible() :
         raise Accas.AsException("Erreur dans cham_elem.EXTR_COMP en PAR_LOT='OUI'")

      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      nchams=ncham[0:7]+'S'
      ncmp=comp+(8-len(comp))*' '

      aster.prepcompcham(ncham,nchams,ncmp,"EL      ",topo,lgma)

      valeurs=numpy.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))

      if (topo>0) :
         maille=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.M'))
         point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.P'))
         sous_point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.SP'))
      else :
         maille=None
         point=None
         sous_point=None

      aster.prepcompcham("__DETR__",nchams,ncmp,"EL      ",topo,lgma)

      return post_comp_cham_el(valeurs,maille,point,sous_point)

class cham_no_sdaster(cham_gd_sdaster):
   cata_sdj = "SD.sd_champ.sd_cham_no_class"

   def EXTR_COMP(self,comp=' ',lgno=[],topo=0) :
      """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de noeuds lgno avec eventuellement l'info de la
        topologie si topo>0. Si lgno est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : numpy.array contenant les valeurs
        Si on a demande la topo (i.e. self.topo = 1) :
          - self.noeud  : numero de noeud
        Si on demande toutes les composantes (comp = ' ') :
          - self.comp : les composantes associees a chaque grandeur pour chaque noeud
      """
      import numpy
      if not self.accessible() :
         raise Accas.AsException("Erreur dans cham_no.EXTR_COMP en PAR_LOT='OUI'")

      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      nchams=ncham[0:7]+'S'
      ncmp=comp+(8-len(comp))*' '

      aster.prepcompcham(ncham,nchams,ncmp,"NO      ",topo,lgno)

      valeurs=numpy.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))

      if (topo>0) :
         noeud=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.N'))
      else :
         noeud=None

      if comp[:1] == ' ':
         comp=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.C'))
         aster.prepcompcham("__DETR__",nchams,ncmp,"NO      ",topo,lgno)
         return post_comp_cham_no(valeurs,noeud,comp)
      else:
         aster.prepcompcham("__DETR__",nchams,ncmp,"NO      ",topo,lgno)
         return post_comp_cham_no(valeurs,noeud)

   def __add__(self, other):
      from SD.sd_nume_equa import sd_nume_equa
      # on recupere le type
      __nume_ddl=sd_nume_equa(self.sdj.REFE.get()[1])
      __gd=__nume_ddl.REFN.get()[1].strip()
      __type='NOEU_'+__gd
      # on recupere le nom du maillage
      __nomMaillage=self.sdj.REFE.get()[0].strip()
      # on recupere l'objet du maillage
      __maillage=CONTEXT.get_current_step().get_concept(__nomMaillage)
      __CHAM = CREA_CHAMP(OPERATION='ASSE',
                          MAILLAGE=__maillage,
                          TYPE_CHAM=__type,
                          INFO=1,
                          ASSE=(_F(CHAM_GD=self,
                                   TOUT='OUI',
                                   CUMUL='OUI',
                                   COEF_R=1.),
                                _F(CHAM_GD=other,
                                   TOUT='OUI',
                                   CUMUL='OUI',
                                   COEF_R=1.),
                               ))
      return __CHAM

# post-traitement :
class post_comp_cham_no :
    def __init__(self, valeurs, noeud=None, comp=None) :
        self.valeurs = valeurs
        self.noeud = noeud
        self.comp = comp

class post_comp_cham_el :
    def __init__(self, valeurs, maille=None, point=None, sous_point=None) :
        self.valeurs = valeurs
        self.maille = maille
        self.point = point
        self.sous_point = sous_point

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

class cham_mater(ASSD):
    cata_sdj = "SD.sd_cham_mater.sd_cham_mater"

    def get_vale_ref(self, nom_varc):
        """Retourne la valeur de référence de `nom_varc`."""
        from SD.sd_carte import sd_carte
        nom_varc = nom_varc.strip()
        varc = self.sdj.varc
        nom = [sv.strip() for sv in varc.CVRCNOM.get()]
        assert nom_varc in nom, (nom_varc, nom)
        idx = nom.index(nom_varc)
        novarc = [sv for sv in varc.CVRCVARC.get()]
        assert len(novarc) > idx, novarc
        nomch = novarc[idx]
        # accès à la carte
        cartref = sd_carte("%-8s.%-8s.1" % (self.nom, nomch))
        valref = cartref.VALE.get()[0]
        return valref

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_acou(ASSD):
    cata_sdj = "SD.sd_char_acou.sd_char_acou"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_cine_acou(ASSD):
    cata_sdj = "SD.sd_char_cine.sd_char_cine"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_cine_meca(ASSD):
    cata_sdj = "SD.sd_char_cine.sd_char_cine"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_cine_ther(ASSD):
    cata_sdj = "SD.sd_char_cine.sd_char_cine"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_contact(ASSD):
    cata_sdj = "SD.sd_contact.sd_contact"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_meca(ASSD):
    cata_sdj = "SD.sd_char_meca.sd_char_meca"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class char_ther(ASSD):
    cata_sdj = "SD.sd_char_ther.sd_char_ther"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class compor_sdaster(ASSD):
    cata_sdj = "SD.sd_compor.sd_compor"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class corresp_2_mailla(ASSD):
    cata_sdj = "SD.sd_corresp_2_mailla.sd_corresp_2_mailla"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class courbe_sdaster(ASSD):
    cata_sdj = "SD.sd_courbe.sd_courbe"

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

class entier(ASSD):
    cata_sdj = "SD.AsBase"

    def __init__(self, valeur=None, **args):
        ASSD.__init__(self, **args)
        self.valeur = valeur

    def __adapt__(self, validator):
        if validator.name == "list":
            # validateur liste,cardinalité
            return (self, )
        elif validator.name == "type":
            # validateur type
            return validator.adapt(self.valeur or 0)
        else:
            # validateur into et valid
            return self

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class fiss_xfem(ASSD):
    cata_sdj = "SD.sd_xfem.sd_fiss_xfem"

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

# types 'fonction' :
class fonction_class(ASSD):
   cata_sdj = "SD.sd_fonction.sd_fonction_aster"

   def Valeurs(self):
      pass

   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la fonction ;
      le type jeveux (FONCTION, FONCT_C, NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel.
      """
      from Utilitai.Utmess import UTMESS
      if self.accessible():
        TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
        objev = '%-19s.PROL' % self.get_name()
        prol = self.sdj.PROL.get()
        if prol == None:
           UTMESS('F', 'SDVERI_2', valk=[objev])
        dico={
         'INTERPOL'    : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'    : prol[2][0:16].strip(),
         'NOM_RESU'    : prol[3][0:16].strip(),
         'PROL_DROITE' : TypeProl[prol[4][1]],
         'PROL_GAUCHE' : TypeProl[prol[4][0]],
        }
      elif hasattr(self,'etape') and self.etape.nom=='DEFI_FONCTION' :
        dico={
         'INTERPOL'    : self.etape['INTERPOL'],
         'NOM_PARA'    : self.etape['NOM_PARA'],
         'NOM_RESU'    : self.etape['NOM_RESU'],
         'PROL_DROITE' : self.etape['PROL_DROITE'],
         'PROL_GAUCHE' : self.etape['PROL_GAUCHE'],
        }
        if   type(dico['INTERPOL']) == tuple:
                  dico['INTERPOL']=list(dico['INTERPOL'])
        elif type(dico['INTERPOL']) == str:
                  dico['INTERPOL']=[dico['INTERPOL'],]
        if len(dico['INTERPOL'])==1 :
           dico['INTERPOL']=dico['INTERPOL']*2
      else:
         raise Accas.AsException("Erreur dans fonction.Parametres en PAR_LOT='OUI'")
      return dico

   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction"""
      if not self.accessible() :
         raise Accas.AsException("Erreur dans fonction.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
            Lab=[self.Parametres()['NOM_PARA'],self.Parametres()['NOM_RESU']],
            Leg=os.linesep.join(self.sdj.TITR.get()) )
      gr.Trace(FORMAT=FORMAT,**kargs)

class fonction_sdaster(fonction_class):

   def convert(self, arg='real'):
      """
      Retourne un objet de la classe t_fonction
      représentation python de la fonction
      """
      from Cata_Utils.t_fonction import t_fonction, t_fonction_c
      class_fonction = t_fonction
      if arg == 'complex':
         class_fonction = t_fonction_c
      absc, ordo = self.Valeurs()
      return class_fonction(absc, ordo, self.Parametres(), nom=self.nom)

   def Valeurs(self) :
      """
      Retourne deux listes de valeurs : abscisses et ordonnees
      """
      from Utilitai.Utmess import UTMESS
      if self.accessible():
        vale = '%-19s.VALE' % self.get_name()
        lbl = self.sdj.VALE.get()
        if lbl == None:
          UTMESS('F', 'SDVERI_2', valk=[vale])
        lbl = list(lbl)
        dim = len(lbl)/2
        lx = lbl[0:dim]
        ly = lbl[dim:2*dim]
      elif hasattr(self, 'etape') and self.etape.nom == 'DEFI_FONCTION' :
         if self.etape['VALE'] is not None:
            lbl = list(self.etape['VALE'])
            dim = len(lbl)
            lx = [lbl[i] for i in range(0,dim,2)]
            ly = [lbl[i] for i in range(1,dim,2)]
         elif self.etape['VALE_PARA'] is not None:
            lx = self.etape['VALE_PARA'].Valeurs()
            ly = self.etape['VALE_FONC'].Valeurs()
         elif self.etape['ABSCISSE'] is not None:
            lx = self.etape['ABSCISSE']
            ly = self.etape['ORDONNEE']
         else:
            raise Accas.AsException("Erreur (fonction.Valeurs) : ne fonctionne en " \
               "PAR_LOT='OUI' que sur des fonctions produites par DEFI_FONCTION " \
               "dans le fichier de commandes courant.")
      else:
         raise Accas.AsException("Erreur (fonction.Valeurs) : ne fonctionne en " \
               "PAR_LOT='OUI' que sur des fonctions produites par DEFI_FONCTION " \
               "dans le fichier de commandes courant.")
      return [lx, ly]

   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]

   def Ordo(self):
      """Retourne la liste des ordonnées"""
      return self.Valeurs()[1]

   def __call__(self, val, tol=1.e-6):
      """Evaluate a function at 'val'. If provided, 'tol' is a relative
      tolerance to match an abscissa value."""
      # Pour EFICAS : substitution de l'instance de classe
      # parametre par sa valeur
      if isinstance(val, ASSD):
         val=val.valeur
      __ff=self.convert()
      return __ff(val, tol=tol)


class fonction_c(fonction_class):

   def convert(self,arg='real'):
      """
      Retourne un objet de la classe t_fonction ou t_fonction_c,
      représentation python de la fonction complexe
      """
      import numpy
      from Cata_Utils.t_fonction import t_fonction, t_fonction_c
      class_fonction = t_fonction
      if arg == 'complex':
         class_fonction = t_fonction_c
      absc = self.Absc()
      para = self.Parametres()
      if arg == 'real':
         ordo = self.Ordo()
      elif arg == 'imag':
         ordo = self.OrdoImg()
      elif arg == 'modul':
         ordo = numpy.sqrt(numpy.array(self.Ordo())**2 + numpy.array(self.OrdoImg())**2)
      elif arg == 'phase':
         ordo = numpy.arctan2(numpy.array(self.OrdoImg()), numpy.array(self.Ordo())) * 180. / pi
      elif arg == 'complex':
         ordo = map(complex,self.Ordo(),self.OrdoImg())
      else:
         assert False, 'unexpected value for arg: %r' % arg
      return class_fonction(self.Absc(), ordo, self.Parametres(), nom=self.nom)

   def Valeurs(self) :
      """
      Retourne trois listes de valeurs : abscisses, parties reelles et imaginaires.
      """
      from Utilitai.Utmess import UTMESS
      if self.accessible():
         vale = '%-19s.VALE' % self.get_name()
         lbl = self.sdj.VALE.get()
         if lbl == None:
           UTMESS('F', 'SDVERI_2', valk=[vale])
         lbl = list(lbl)
         dim=len(lbl)/3
         lx=lbl[0:dim]
         lr=[]
         li=[]
         for i in range(dim):
            lr.append(lbl[dim+2*i])
            li.append(lbl[dim+2*i+1])
      elif hasattr(self, 'etape') and self.etape.nom == 'DEFI_FONCTION' \
            and self.etape['VALE_C'] is not None:
         lbl=list(self.etape['VALE_C'])
         dim=len(lbl)
         lx=[lbl[i] for i in range(0,dim,3)]
         lr=[lbl[i] for i in range(1,dim,3)]
         li=[lbl[i] for i in range(2,dim,3)]
      else:
         raise Accas.AsException("Erreur (fonction_c.Valeurs) : ne fonctionne en " \
               "PAR_LOT='OUI' que sur des fonctions produites par DEFI_FONCTION " \
               "dans le jdc courant.")
      return [lx, lr, li]

   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]

   def Ordo(self):
      """Retourne la liste des parties réelles des ordonnées"""
      return self.Valeurs()[1]

   def OrdoImg(self):
      """Retourne la liste des parties imaginaires des ordonnées"""
      return self.Valeurs()[2]

   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction complexe"""
      if not self.accessible():
         raise Accas.AsException("Erreur dans fonction_c.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      para = self.Parametres()
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
         Lab=[para['NOM_PARA'], '%s_R' % para['NOM_RESU'], '%s_I' % para['NOM_RESU']],
         Leg=os.linesep.join(self.sdj.TITR.get()) )
      gr.Trace(FORMAT=FORMAT,**kargs)

   def __call__(self, val, tol=1.e-6):
      """Evaluate a function at 'val'. If provided, 'tol' is a relative
      tolerance to match an abscissa value."""
      # Pour EFICAS : substitution de l'instance de classe
      # parametre par sa valeur
      if isinstance(val, ASSD):
         val=val.valeur
      __ff=self.convert(arg='complex')
      return __ff(val, tol=tol)


class nappe_sdaster(fonction_class):

   def convert(self):
      """
      Retourne un objet de la classe t_nappe, représentation python de la nappe
      """
      from Cata_Utils.t_fonction import t_fonction, t_nappe
      para = self.Parametres()
      vale = self.Valeurs()
      l_fonc = []
      i = 0
      for pf in para[1] :
          para_f = {'INTERPOL'    : pf['INTERPOL_FONC'],
                    'PROL_DROITE' : pf['PROL_DROITE_FONC'],
                    'PROL_GAUCHE' : pf['PROL_GAUCHE_FONC'],
                    'NOM_PARA'    : para[0]['NOM_PARA_FONC'],
                    'NOM_RESU'    : para[0]['NOM_RESU'],
                   }
          l_fonc.append(t_fonction(vale[1][i][0],vale[1][i][1],para_f))
          i += 1
      return t_nappe(vale[0], l_fonc, para[0], nom=self.nom)

   def Valeurs(self):
      """
      Retourne la liste des valeurs du parametre,
      et une liste de couples (abscisses,ordonnees) de chaque fonction.
      """
      from Utilitai.Utmess import UTMESS
      if not self.accessible():
         raise Accas.AsException("Erreur dans nappe.Valeurs en PAR_LOT='OUI'")
      nsd = '%-19s' % self.get_name()
      dicv=aster.getcolljev(nsd+'.VALE')
      # les cles de dicv sont 1,...,N (indice du parametre)
      lpar=aster.getvectjev(nsd+'.PARA')
      if lpar == None:
         UTMESS('F', 'SDVERI_2', valk=[nsd+'.PARA'])
      lval=[]
      for k in range(len(dicv)):
         lbl=dicv[k+1]
         dim=len(lbl)/2
         lval.append([lbl[0:dim],lbl[dim:2*dim]])
      return [list(lpar),lval]

   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la nappe,
      le type jeveux (NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel,
      et une liste de dictionnaire des parametres de chaque fonction.
      """
      from Utilitai.Utmess import UTMESS
      if not self.accessible():
         raise Accas.AsException("Erreur dans nappe.Parametres en PAR_LOT='OUI'")
      TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
      objev = '%-19s.PROL' % self.get_name()
      prol=aster.getvectjev(objev)
      if prol == None:
         UTMESS('F', 'SDVERI_2', valk=[objev])
      dico={
         'INTERPOL'      : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'      : prol[2][0:16].strip(),
         'NOM_RESU'      : prol[3][0:16].strip(),
         'PROL_DROITE'   : TypeProl[prol[4][1]],
         'PROL_GAUCHE'   : TypeProl[prol[4][0]],
         'NOM_PARA_FONC' : prol[6][0:4].strip(),
      }
      lparf=[]
      nbf=(len(prol)-7)/2
      for i in range(nbf):
         dicf={
            'INTERPOL_FONC'    : [prol[7+i*2][0:3],prol[7+i*2][4:7]],
            'PROL_DROITE_FONC' : TypeProl[prol[8+i*2][1]],
            'PROL_GAUCHE_FONC' : TypeProl[prol[8+i*2][0]],
         }
         lparf.append(dicf)
      return [dico,lparf]

   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]

   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une nappe"""
      if not self.accessible():
         raise Accas.AsException("Erreur dans nappe.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      gr=Graph()
      lv=self.Valeurs()[1]
      dp=self.Parametres()[0]
      for lx,ly in lv:
         gr.AjoutCourbe(Val=[lx,ly], Lab=[dp['NOM_PARA_FONC'],dp['NOM_RESU']],
            Leg=os.linesep.join(self.sdj.TITR.get()) )
      gr.Trace(FORMAT=FORMAT,**kargs)

   def __call__(self, val1, val2, tol=1.e-6):
      """Evaluate a function at 'val'. If provided, 'tol' is a relative
      tolerance to match an abscissa value."""
      # Pour EFICAS : substitution de l'instance de classe
      # parametre par sa valeur
      if isinstance(val1, ASSD):
         val1=val1.valeur
      if isinstance(val2, ASSD):
         val2=val2.valeur
      __ff=self.convert()
      return __ff(val1, val2, tol=tol)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class fond_fiss(ASSD):
    cata_sdj = "SD.sd_fond_fiss.sd_fond_fiss"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class gfibre_sdaster(ASSD):
    cata_sdj = "SD.sd_gfibre.sd_gfibre"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class interf_dyna_clas(ASSD):
    cata_sdj = "SD.sd_interf_dyna_clas.sd_interf_dyna_clas"

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr


class interspectre(ASSD):
    cata_sdj = "SD.sd_interspectre.sd_interspectre"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class list_inst(ASSD):
    cata_sdj = "SD.sd_list_inst.sd_list_inst"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class listis_sdaster(ASSD):
    cata_sdj = "SD.sd_listis.sd_listis"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class listr8_sdaster(ASSD):
   cata_sdj = "SD.sd_listr8.sd_listr8"

   def Valeurs(self) :
      """
      Retourne la liste des valeurs : [val1, ..., valN]
      """
      if not self.accessible():
         raise Accas.AsException("Erreur dans listr8.Valeurs en PAR_LOT='OUI'")
      from Utilitai.Utmess import UTMESS
      t_vale = self.sdj.VALE.get()
      if t_vale == None:
         UTMESS('F', 'SDVERI_2', valk=[vale])
      return list(t_vale)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def VALE_triang2array(vect_VALE, dim, dtype=None):
    """Conversion (par recopie) de l'objet .VALE decrivant une matrice pleine
    par sa triangulaire sup en numpy.array plein.
    """
    import numpy
    triang_sup = numpy.array(vect_VALE)
    assert dim*(dim+1)/2 == len(triang_sup), \
        'Matrice non pleine : %d*(%d+1)/2 != %d' % (dim, dim, len(triang_sup))

    valeur = numpy.zeros([dim, dim], dtype=dtype)
    for i in range(1, dim+1):
        for j in range(1, i+1):
            k = i*(i-1)/2 + j
            valeur[j-1, i-1]=triang_sup[k-1]
    valeur = valeur + numpy.transpose(valeur)
    for i in range(dim):
        valeur[i, i] = 0.5 * valeur[i, i]
    return valeur

class macr_elem_dyna(ASSD):
    cata_sdj = "SD.sd_macr_elem_dyna.sd_macr_elem_dyna"

    def EXTR_MATR_GENE(self,typmat) :
        """ retourne les valeurs des matrices generalisees reelles
        dans un format numpy
         typmat='MASS_GENE' pour obtenir la matrice de masse generalisee
         typmat='RIGI_GENE' pour obtenir la matrice de raideur generalisee
         typmat='AMOR_GENE' pour obtenir la matrice d'amortissement generalisee
         Attributs retourne
            - self.valeurs : numpy.array contenant les valeurs """
        import numpy
        if not self.accessible():
            raise Accas.AsException("Erreur dans macr_elem_dyna.EXTR_MATR_GENE en PAR_LOT='OUI'")

        if (typmat=='MASS_GENE') :
            macr_elem = self.sdj.MAEL_MASS
        elif (typmat=='RIGI_GENE') :
            macr_elem = self.sdj.MAEL_RAID
        elif (typmat=='AMOR_GENE') :
            macr_elem = self.sdj.MAEL_AMOR
        else:
            raise Accas.AsException("Le type de la matrice est incorrect")

        desc=numpy.array(macr_elem.DESC.get())
        # On teste si le DESC du vecteur existe
        if (desc==None):
            raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster")

        matrice = VALE_triang2array(macr_elem.VALE.get(), desc[1])
        return matrice

    def RECU_MATR_GENE(self,typmat,matrice) :
        """ envoie les valeurs d'un tableau numpy dans des matrices generalisees
        reelles definies dans jeveux
         typmat='MASS_GENE' pour obtenir la matrice de masse generalisee
         typmat='RIGI_GENE' pour obtenir la matrice de raideur generalisee
         typmat='AMOR_GENE' pour obtenir la matrice d'amortissement generalisee
         Attributs ne retourne rien """
        import numpy
        if not self.accessible():
            raise Accas.AsException("Erreur dans macr_elem_dyna.RECU_MATR_GENE en PAR_LOT='OUI'")

        nommacr=self.get_name()
        if (typmat=='MASS_GENE') :
            macr_elem = self.sdj.MAEL_MASS
        elif (typmat=='RIGI_GENE') :
            macr_elem = self.sdj.MAEL_RAID
        elif (typmat=='AMOR_GENE') :
            macr_elem = self.sdj.MAEL_AMOR
        else:
            raise Accas.AsException("Le type de la matrice est incorrect")
        nom_vale = macr_elem.VALE.nomj()
        desc=numpy.array(macr_elem.DESC.get())

        # On teste si le DESC de la matrice jeveux existe
        if (desc==None):
            raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster")
        numpy.asarray(matrice)

        # On teste si la matrice python est de dimension 2
        if (len(numpy.shape(matrice))<>2):
            raise Accas.AsException("La dimension de la matrice est incorrecte")

        # On teste si les tailles de la matrice jeveux et python sont identiques
        if (tuple([desc[1],desc[1]])<>numpy.shape(matrice)) :
            raise Accas.AsException("La dimension de la matrice est incorrecte")
        taille=desc[1]*desc[1]/2.0+desc[1]/2.0
        tmp=numpy.zeros([int(taille)])
        for j in range(desc[1]+1):
            for i in range(j):
                k=j*(j-1)/2+i
                tmp[k]=matrice[j-1,i]
        aster.putvectjev(nom_vale,len(tmp),tuple((
            range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class macr_elem_stat(ASSD):
    cata_sdj = "SD.sd_macr_elem_stat.sd_macr_elem_stat"

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class maillage_sdaster(ASSD):
   cata_sdj = "SD.sd_maillage.sd_maillage"

   def LIST_GROUP_NO(self) :
      """ retourne la liste des groupes de noeuds sous la forme :
        [ (gno1, nb noeuds  gno1), ...] """
      if not self.accessible():
         raise Accas.AsException("Erreur dans maillage.LIST_GROUP_NO en PAR_LOT='OUI'")
      dic_gpno = self.sdj.GROUPENO.get()
      if dic_gpno is None:
          return []
      return [(gpno.strip(),len(dic_gpno[gpno])) for gpno in dic_gpno]

   def LIST_GROUP_MA(self) :
      """ retourne la liste des groupes de mailles sous la forme :
        [ (gma1, nb mailles gma1, dime max des mailles gma1), ...] """
      if not self.accessible():
         raise Accas.AsException("Erreur dans maillage.LIST_GROUP_MA en PAR_LOT='OUI'")
      ltyma = aster.getvectjev("&CATA.TM.NOMTM")
      catama = aster.getcolljev("&CATA.TM.TMDIM")
      dic_gpma = self.sdj.GROUPEMA.get()
      if dic_gpma is None:
          return []
      dimama = [catama[ltyma[ma-1].ljust(24)][0] for ma in self.sdj.TYPMAIL.get()]
      ngpma = []
      for grp in dic_gpma.keys():
         dim = max([dimama[ma-1] for ma in dic_gpma[grp]])
         ngpma.append((grp.strip(), len(dic_gpma[grp]),dim))
      return ngpma

class grille_sdaster(maillage_sdaster):
    cata_sdj = "SD.sd_grille.sd_grille"

class squelette(maillage_sdaster):
    cata_sdj = "SD.sd_squelette.sd_squelette"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class mater_sdaster(ASSD):
   cata_sdj = "SD.sd_mater.sd_mater"

   def RCVALE(self, phenomene, nompar=(), valpar=(), nomres=(), stop=1):
      """Appel à la routine fortran RCVALE pour récupérer les valeurs des
      propriétés du matériau.
      """
      if not self.accessible():
         raise Accas.AsException("Erreur dans mater.RCVALE en PAR_LOT='OUI'")
      from Utilitai.Utmess import UTMESS
      # vérification des arguments
      if not type(nompar) in (list, tuple):
         nompar = [nompar,]
      if not type(valpar) in (list, tuple):
         valpar = [valpar,]
      if not type(nomres) in (list, tuple):
         nomres = [nomres,]
      nompar = tuple(nompar)
      valpar = tuple(valpar)
      nomres = tuple(nomres)
      if len(nompar) != len(valpar):
         vk1=', '.join(nompar)
         vk2=', '.join([repr(v) for v in valpar])
         UTMESS('F','SDVERI_4',valk=[vk1,vk2])
      if len(nomres) < 1:
         UTMESS('F', 'SDVERI_5')
      # appel à l'interface Python/C
      return aster.rcvale(self.nom, phenomene, nompar, valpar, nomres, stop)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

class matr_asse(ASSD):
    cata_sdj = "SD.sd_matr_asse.sd_matr_asse"

    def EXTR_MATR(self) :
        """ retourne les valeurs de la matrice  dans un format numpy
            Attributs retourne
              - self.valeurs : numpy.array contenant les valeurs """
        import numpy
        from SD.sd_stoc_morse import sd_stoc_morse

        if not self.accessible():
            raise Accas.AsException("Erreur dans matr_asse.EXTR_MATR en PAR_LOT='OUI'")

        refa = numpy.array(self.sdj.REFA.get())
        ma=refa[0]
        nu=refa[1]
        smos = sd_stoc_morse(nu[:14]+'.SMOS')

        valm=self.sdj.VALM.get()
        smhc=smos.SMHC.get()
        smdi=smos.SMDI.get()

        sym=len(valm)==1
        dim=len(smdi)
        nnz=smdi[dim-1]

        triang_sup = numpy.array(valm[1])
        if sym:
            triang_inf = triang_sup
        else:
            triang_inf = numpy.array(valm[2])

        if type(valm[1][0]) == type(1.j) :
            dtype=complex
        else :
            dtype=float
        valeur=numpy.zeros([dim, dim], dtype=dtype)

        jcol=1
        for kterm in range(1,nnz+1):
            ilig=smhc[kterm-1]
            if (smdi[jcol-1] < kterm):
                jcol=jcol+1
            valeur[jcol-1,ilig-1]=triang_inf[kterm-1]
            valeur[ilig-1,jcol-1]=triang_sup[kterm-1]

        return valeur

class matr_asse_gd(matr_asse):
    cata_sdj = "SD.sd_matr_asse.sd_matr_asse"

class matr_asse_depl_c(matr_asse_gd):
    pass

class matr_asse_depl_r(matr_asse_gd):
    pass

class matr_asse_pres_c(matr_asse_gd):
    pass

class matr_asse_pres_r(matr_asse_gd):
    pass

class matr_asse_temp_c(matr_asse_gd):
    pass

class matr_asse_temp_r(matr_asse_gd):
    pass

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def VALM_triang2array(dict_VALM, dim, dtype=None):
   """Conversion (par recopie) de l'objet .VALM decrivant une matrice pleine
   par sa triangulaire inf (et parfois triang sup) en numpy.array plein.
   """
   import numpy
   # stockage symetrique ou non (triang inf+sup)
   sym = len(dict_VALM) == 1
   triang_sup = numpy.array(dict_VALM[1])
   assert dim*(dim+1)/2 == len(triang_sup), \
         'Matrice non pleine : %d*(%d+1)/2 != %d' % (dim, dim, len(triang_sup))
   if sym:
      triang_inf = triang_sup
   else:
      triang_inf = numpy.array(dict_VALM[2])
   valeur=numpy.zeros([dim, dim], dtype=dtype)
   for i in range(1, dim+1):
     for j in range(1, i+1):
       k = i*(i-1)/2 + j
       valeur[i-1, j-1]=triang_inf[k-1]
       valeur[j-1, i-1]=triang_sup[k-1]
   return valeur

def VALM_diag2array(dict_VALM, dim, dtype=None):
   """Conversion (par recopie) de l'objet .VALM decrivant une matrice
   diagonale en numpy.array plein.
   """
   import numpy
   diag = numpy.array(dict_VALM[1])
   assert dim == len(diag), 'Dimension incorrecte : %d != %d' % (dim, len(diag))
   valeur=numpy.zeros([dim, dim], dtype=dtype)
   for i in range(dim):
      valeur[i,i] =  diag[i]
   return valeur

class matr_asse_gene(ASSD):
    cata_sdj = "SD.sd_matr_asse_gene.sd_matr_asse_gene"

class matr_asse_gene_r(matr_asse_gene):
  def EXTR_MATR_GENE(self) :
    """ retourne les valeurs de la matrice generalisee reelle
    dans un format numpyal Array
        Attributs retourne
          - self.valeurs : numpy.array contenant les valeurs """
    if not self.accessible():
       raise Accas.AsException("Erreur dans matr_asse_gene.EXTR_MATR_GENE en PAR_LOT='OUI'")
    import numpy

    desc=numpy.array(self.sdj.DESC.get())
    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster")
    # Si le stockage est plein
    if desc[2]==2 :
       valeur = VALM_triang2array(self.sdj.VALM.get(), desc[1])

    # Si le stockage est diagonal
    elif desc[2]==1 :
       valeur = VALM_diag2array(self.sdj.VALM.get(), desc[1])

    # Sinon on arrete tout
    else:
      raise KeyError
    return valeur

  def RECU_MATR_GENE(self,matrice) :
    """ envoie les valeurs d'un tableau numpy dans des matrices
    generalisees reelles definies dans jeveux
        Attributs ne retourne rien """
    import numpy
    if not self.accessible():
       raise Accas.AsException("Erreur dans matr_asse_gene.RECU_MATR_GENE en PAR_LOT='OUI'")

    ncham=self.get_name()
    desc=numpy.array(self.sdj.DESC.get())

    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster")
    numpy.asarray(matrice)

    # On teste si la dimension de la matrice python est 2
    if (len(numpy.shape(matrice))<>2) :
       raise Accas.AsException("La dimension de la matrice est incorrecte ")

    # On teste si les tailles des matrices jeveux et python sont identiques
    if (tuple([desc[1],desc[1]])<>numpy.shape(matrice)) :
       raise Accas.AsException("La taille de la matrice est incorrecte ")

    # Si le stockage est plein
    if desc[2]==2 :
      taille=desc[1]*desc[1]/2.0+desc[1]/2.0
      tmp=numpy.zeros([int(taille)])
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          tmp[k]=matrice[j-1,i]
      aster.putcolljev('%-19s.VALM' % ncham,len(tmp),tuple((\
      range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmp=numpy.zeros(desc[1])
      for j in range(desc[1]):
          tmp[j]=matrice[j,j]
      aster.putcolljev('%-19s.VALM' % ncham,len(tmp),tuple((\
      range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)
    # Sinon on arrete tout
    else:
      raise KeyError
    return

class matr_asse_gene_c(matr_asse_gene):
  def EXTR_MATR_GENE(self) :
    """ retourne les valeurs de la matrice generalisee complexe
    dans un format numpy
        Attributs retourne
          - self.valeurs : numpy.array contenant les valeurs """
    import numpy
    if not self.accessible():
       raise Accas.AsException("Erreur dans matr_asse_gene_c.EXTR_MATR_GENE en PAR_LOT='OUI'")

    desc = numpy.array(self.sdj.DESC.get())
    if desc == None:
       raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster ")
    # Si le stockage est plein
    if desc[2] == 2 :
       valeur = VALM_triang2array(self.sdj.VALM.get(), desc[1], complex)

    # Si le stockage est diagonal
    elif desc[2]==1 :
       valeur = VALM_diag2array(self.sdj.VALM.get(), desc[1], complex)

    # Sinon on arrete tout
    else:
       raise KeyError
    return valeur

  def RECU_MATR_GENE(self,matrice) :
    """ envoie les valeurs d'un tableau numpy dans des matrices
    generalisees reelles definies dans jeveux
        Attributs ne retourne rien """
    import numpy
    if not self.accessible():
       raise Accas.AsException("Erreur dans matr_asse_gene_c.RECU_MATR_GENE en PAR_LOT='OUI'")

    numpy.asarray(matrice)
    ncham=self.get_name()
    desc=numpy.array(self.sdj.DESC.get())

    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou est mal cree par Code Aster")
    numpy.asarray(matrice)

    # On teste si la dimension de la matrice python est 2
    if (len(numpy.shape(matrice))<>2) :
       raise Accas.AsException("La dimension de la matrice est incorrecte ")

    # On teste si la taille de la matrice jeveux et python est identique
    if (tuple([desc[1],desc[1]])<>numpy.shape(matrice)) :
       raise Accas.AsException("La taille de la matrice est incorrecte ")

    # Si le stockage est plein
    if desc[2]==2 :
      taille=desc[1]*desc[1]/2.0+desc[1]/2.0
      tmpr=numpy.zeros([int(taille)])
      tmpc=numpy.zeros([int(taille)])
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          tmpr[k]=matrice[j-1,i].real
          tmpc[k]=matrice[j-1,i].imag
      aster.putvectjev('%-19s.VALM' % ncham, len(tmpr), tuple((\
                       range(1,len(tmpr)+1))),tuple(tmpr),tuple(tmpc),1)
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmpr=numpy.zeros(desc[1])
      tmpc=numpy.zeros(desc[1])
      for j in range(desc[1]):
          tmpr[j]=matrice[j,j].real
          tmpc[j]=matrice[j,j].imag
      aster.putvectjev('%-19s.VALM' % ncham,len(tmpr),tuple((\
                       range(1,len(tmpr)+1))),tuple(tmpr),tuple(tmpc),1)
    # Sinon on arrete tout
    else:
      raise KeyError
    return

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class matr_elem(ASSD):
    cata_sdj = "SD.sd_matr_elem.sd_matr_elem"

class matr_elem_depl_c(matr_elem):
    pass

class matr_elem_depl_r(matr_elem):
    pass

class matr_elem_pres_c(matr_elem):
    pass

class matr_elem_temp_r(matr_elem):
    pass

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class melasflu_sdaster(ASSD):
    cata_sdj = "SD.sd_melasflu.sd_melasflu"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class mode_cycl(ASSD):
    cata_sdj = "SD.sd_mode_cycl.sd_mode_cycl"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class modele_gene(ASSD):
   cata_sdj = "SD.sd_modele_gene.sd_modele_gene"

   def LIST_SOUS_STRUCT(self) :
      """ retourne la liste des sous structures du modele generalise
         la liste des macro-elements sous-jacents"""
      if not self.accessible():
         raise Accas.AsException("Erreur dans modele_gene.LIST_SOUS_STRUCT en PAR_LOT='OUI'")
      nommodgen=self.get_name()
      ncham=nommodgen+(8-len(nommodgen))*' '
      ssno=aster.getvectjev(ncham+(14-len(ncham))*' '+'.MODG.SSNO')
      ssme=aster.getcolljev(ncham+(14-len(ncham))*' '+'.MODG.SSME')
      return [([ssno[ind], ssme[ind+1]]) for ind in range(len(ssno))]

   def LIST_LIAIS_STRUCT(self) :
      """ retourne la liste des liaisons entre sous structures du modele generalise sous la forme :
         [ (ss1, nom_liais1,  ss2 , nom_liais2), ...] """
      if not self.accessible() :
         raise Accas.AsException("Erreur dans modele_gene.LIST_LIAIS_STRUCT en PAR_LOT='OUI'")
      nommodgen=self.get_name()
      ncham=nommodgen+(8-len(nommodgen))*' '
      lidf=aster.getcolljev(ncham+(14-len(ncham))*' '+'.MODG.LIDF')
      return [([(lidf[ind][indb]) for indb in range(4)]) for ind in lidf]

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class modele_sdaster(ASSD):
    cata_sdj = "SD.sd_modele.sd_modele"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class nume_ddl_gene(ASSD):
    cata_sdj = "SD.sd_nume_ddl.sd_nume_ddl"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class nume_ddl_sdaster(ASSD):
    cata_sdj = "SD.sd_nume_ddl.sd_nume_ddl"

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

class reel(ASSD):
    cata_sdj = "SD.AsBase"

    def __init__(self, valeur=None, **args):
        ASSD.__init__(self, **args)
        self.valeur = valeur

    def __call__(self):
        return self.valeur

    def __adapt__(self, validator):
        if validator.name == "list":
            # validateur liste,cardinalité
            return (self, )
        elif validator.name == "type":
            # validateur type
            return validator.adapt(self.valeur or 0.)
        else:
            # validateur into et valid
            return self

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class resultat_sdaster(ASSD):
   cata_sdj = "SD.sd_resultat.sd_resultat"

   def LIST_CHAMPS (self) :
      if not self.accessible():
         raise Accas.AsException("Erreur dans resultat.LIST_CHAMPS en PAR_LOT='OUI'")
      return aster.GetResu(self.get_name(), "CHAMPS")

   def LIST_NOM_CMP (self) :
      if not self.accessible():
         raise Accas.AsException("Erreur dans resultat.LIST_NOM_CMP en PAR_LOT='OUI'")
      return aster.GetResu(self.get_name(), "COMPOSANTES")

   def LIST_VARI_ACCES (self) :
      if not self.accessible():
         raise Accas.AsException("Erreur dans resultat.LIST_VARI_ACCES en PAR_LOT='OUI'")
      return aster.GetResu(self.get_name(), "VARI_ACCES")

   def LIST_PARA (self) :
      if not self.accessible():
         raise Accas.AsException("Erreur dans resultat.LIST_PARA en PAR_LOT='OUI'")
      return aster.GetResu(self.get_name(), "PARAMETRES")

class resultat_jeveux(resultat_sdaster):
   """Classe permettant d'accéder à un resultat jeveux qui n'a pas d'ASSD associée,
   c'est le cas des concepts résultats (table, evol_xxxx) dérivés."""
   def __init__(self, nom_jeveux):
      resultat_sdaster.__init__(self)
      self.set_name(nom_jeveux)

class comb_fourier(resultat_sdaster): pass
class fourier_elas(resultat_sdaster): pass
class fourier_ther(resultat_sdaster): pass
class mult_elas(resultat_sdaster): pass
class theta_geom(resultat_sdaster): pass

# resultat_sdaster/evol_sdaster :
class evol_sdaster(resultat_sdaster): pass
class evol_char(evol_sdaster): pass
class evol_elas(evol_sdaster): pass
class evol_noli(evol_sdaster): pass
class evol_ther(evol_sdaster): pass
class evol_varc(evol_sdaster): pass



# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: hassan.berro at edf.fr

class dyna_gene(ASSD):
    cata_sdj = "SD.sd_dyna_gene.sd_dyna_gene"

class dyna_phys(resultat_sdaster):
    cata_sdj="SD.sd_dyna_phys.sd_dyna_phys"

# Concepts généralisés
class harm_gene  (dyna_gene) : pass
class tran_gene  (dyna_gene) : pass

# Concepts physiques
class acou_harmo (dyna_phys) : pass
class dyna_harmo (dyna_phys) : pass
class dyna_trans (dyna_phys) : pass
class mode_acou  (dyna_phys) : pass
class mode_flamb (dyna_phys) : pass
class mode_meca  (dyna_phys) : pass
class mode_meca_c(mode_meca) : pass

# TODO : convertir mode_gene en format généralisé
class mode_gene  (dyna_phys) : pass
# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class sd_partit(ASSD):
    cata_sdj = "SD.sd_partition.sd_partit"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class spectre_sdaster(ASSD):
    cata_sdj = "SD.sd_spectre.sd_spectre"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class surface_sdaster(ASSD):
    cata_sdj = "SD.sd_surface.sd_surface"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class table_sdaster(ASSD):
    cata_sdj = "SD.sd_table.sd_table"

    def __getitem__(self, key):
        """Retourne la valeur d'une cellule de la table.
        Exemple : TAB['INST', 1] retourne la 1ère valeur de la colonne 'INST'."""
        from Utilitai.Utmess import UTMESS
        if not self.accessible():
            raise Accas.AsException("Erreur dans table.__getitem__ en PAR_LOT='OUI'")
        assert len(key) == 2
        para, numlign = key
        tabnom = self.sdj.TBLP.get()
        try:
            i = tabnom.index('%-24s' % para)
            resu = aster.getvectjev(tabnom[i + 2])
            exist = aster.getvectjev(tabnom[i + 3])
            assert resu is not None
            assert exist is not None
            assert exist[numlign - 1] != 0
            res = resu[numlign - 1]
        except (IndexError, AssertionError):
            # pour __getitem__, il est plus logique de retourner KeyError.
            raise KeyError
        return res

    def TITRE(self):
        """Retourne le titre d'une table Aster
        (Utile pour récupérer le titre et uniquement le titre d'une table dont
        on souhaite manipuler la dérivée).
        """
        if not self.accessible():
            raise Accas.AsException("Erreur dans table.TITRE en PAR_LOT='OUI'")
        #titj = aster.getvectjev('%-19s.TITR' % self.get_name())
        titj = self.sdj.TITR.get()
        if titj != None:
            titr = '\n'.join(titj)
        else:
            titr = ''
        return titr

    def EXTR_TABLE(self, para=None) :
        """Produit un objet Table à partir du contenu d'une table Aster.
        On peut limiter aux paramètres listés dans 'para'.
        """
        def Nonefy(l1,l2) :
            if l2 == 0:
                return None
            else:
                return l1
        if not self.accessible():
            raise Accas.AsException("Erreur dans table.EXTR_TABLE en PAR_LOT='OUI'")
        from Utilitai.Table import Table
        # titre
        titr = self.TITRE()
        # récupération des paramètres
        #v_tblp = aster.getvectjev('%-19s.TBLP' % self.get_name())
        v_tblp = self.sdj.TBLP.get()
        if v_tblp == None:
            # retourne une table vide
            return Table(titr=titr, nom=self.nom)
        tabnom=list(v_tblp)
        nparam=len(tabnom)/4
        lparam=[tabnom[4*i:4*i+4] for i in range(nparam)]
        # restriction aux paramètres demandés
        if para is not None:
            if type(para) not in (list, tuple):
                para = [para, ]
            para = [p.strip() for p in para]
            restr = []
            for ip in lparam:
                if ip[0].strip() in para:
                    restr.append(ip)
            lparam = restr
        dval={}
        # liste des paramètres et des types
        lpar=[]
        ltyp=[]
        for i in lparam :
            value=list(aster.getvectjev(i[2]))
            exist=aster.getvectjev(i[3])
            dval[i[0].strip()] = map(Nonefy, value, exist)
            lpar.append(i[0].strip())
            ltyp.append(i[1].strip())
        n=len(dval[lpar[0]])
        # contenu : liste de dict
        lisdic=[]
        for i in range(n) :
            d={}
            for p in lpar:
               d[p]=dval[p][i]
            lisdic.append(d)
        return Table(lisdic, lpar, ltyp, titr, self.nom)

class table_fonction(table_sdaster):
    """Table contenant en plus une colonne FONCTION et/ou FONCTION_C dont les
    valeurs des cellules sont des noms de fonction_sdaster ou fonction_c."""

class table_jeveux(table_sdaster):
    """Classe permettant d'accéder à une table jeveux qui n'a pas d'ASSD associée,
    c'est le cas des concepts résultats (table, evol_xxxx) dérivés."""
    def __init__(self, nom_jeveux):
        table_sdaster.__init__(self)
        self.set_name(nom_jeveux)

class table_fonction(table_sdaster):
    """Table contenant une colonne FONCTION et/ou FONCTION_C dont les
    valeurs des cellules sont des noms de fonction_sdaster ou
    fonction_c."""
    cata_sdj = "SD.sd_table_fonction.sd_table_fonction"

class table_container(table_sdaster):
    """Table contenant les colonnes NOM_OBJET, TYPE_OBJET et NOM_SD."""
    cata_sdj = "SD.sd_table_container.sd_table_container"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class type_flui_stru(ASSD):
   cata_sdj = "SD.sd_type_flui_stru.sd_type_flui_stru"

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class vect_asse_gene(ASSD):
   cata_sdj = "SD.sd_cham_gene.sd_cham_gene"

   def EXTR_VECT_GENE_R(self) :
      """ retourne les valeurs du vecteur generalisee
      dans un format numpy
         Attributs retourne
            - self.valeurs : numpy.array contenant les valeurs """
      import numpy
      if not self.accessible():
         raise Accas.AsException("Erreur dans vect_asse_gene_r.EXTR_VECT_GENE en PAR_LOT='OUI'")
      #ncham=self.get_name()
      #ncham=ncham+(8-len(ncham))*' '
      #valeur=numpy.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.VALE'))
      valeur = numpy.array(self.sdj.VALE.get())
      return valeur

   def RECU_VECT_GENE_R(self, vecteur) :
      """ envoie les valeurs d'un tableau numpy dans un vecteur generalise
      reel definie dans jeveux
         Attributs ne retourne rien """
      if not self.accessible():
         raise Accas.AsException("Erreur dans vect_asse_gene_r.RECU_VECT_GENE en PAR_LOT='OUI'")
      import numpy
      numpy.asarray(vecteur)
      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      #desc=numpy.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
      desc = numpy.array(self.sdj.DESC.get())
      # On teste si le DESC du vecteur existe
      if (desc==None):
         raise Accas.AsException("L'objet vecteur n'existe pas ou \
         est mal cree par Code Aster")
      # On teste si la taille du vecteur jeveux et python est identique
      if desc[1] != numpy.shape(vecteur)[0] :
         raise Accas.AsException("La taille du vecteur python est incorrecte")
      aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALE',
                       len(vecteur),
                       tuple(range(1, len(vecteur)+1)),
                       tuple(vecteur),
                       tuple(vecteur),
                       1)
      return

   def EXTR_VECT_GENE_C(self) :
      """ retourne les valeurs du vecteur generalisee
      dans un format numpy
         Attributs retourne
            - self.valeurs : numpy.array contenant les valeurs """
      import numpy
      if not self.accessible():
         raise Accas.AsException("Erreur dans vect_asse_gene_c.EXTR_VECT_GENE en PAR_LOT='OUI'")

      #ncham=self.get_name()
      #ncham=ncham+(8-len(ncham))*' '
      #valeur=numpy.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.VALE'), complex)
      valeur=numpy.array(self.sdj.VALE.get(), complex)

      return valeur

   def RECU_VECT_GENE_C(self,vecteur) :
      """ envoie les valeurs d'un tableau numpy dans un vecteur generalise
      complexe definie dans jeveux
         Attributs ne retourne rien """
      if not self.accessible():
         raise Accas.AsException("Erreur dans vect_asse_gene_c.RECU_VECT_GENE en PAR_LOT='OUI'")
      import numpy
      numpy.asarray(vecteur)
      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      desc=numpy.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
      # On teste si le DESC de la matrice existe
      if (desc==None):
         raise Accas.AsException("L'objet vecteur n'existe pas ou \
         est mal cree par Code Aster")
      # On teste si la taille de la matrice jeveux et python est identique
      if desc[1]<>numpy.shape(vecteur)[0] :
         raise Accas.AsException("La taille du vecteur python est incorrecte")
      tmpr=vecteur.real
      tmpc=vecteur.imag
      aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALE',
                       len(tmpr),
                       tuple(range(1, len(tmpr)+1)),
                       tuple(tmpr),
                       tuple(tmpc),
                       1)
      return

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


class vect_elem(ASSD):
   cata_sdj = "SD.sd_vect_elem.sd_vect_elem"

class vect_elem_depl_r(vect_elem):
   pass

class vect_elem_pres_r(vect_elem):
   pass

class vect_elem_pres_c(vect_elem):
   pass

class vect_elem_temp_r(vect_elem):
   pass

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr

def C_AFFICHAGE() : return FACT(statut='f',max=1,
        INFO_RESIDU = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
        INFO_TEMPS  = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),  
        UNITE       = SIMP(statut='f',typ='I',val_min=1),
        PAS         = SIMP(statut='f',typ='I',val_min=1),
       );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
def C_ARCHIVAGE() : return FACT(statut='d',max=1,
    regles         = (EXCLUS('PAS_ARCH','LIST_INST','INST'),),
    LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
    INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
    PAS_ARCH       = SIMP(statut='f',typ='I' ),
    CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),
    CHAM_EXCLU     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix at edf.fr
def C_COMPORTEMENT(COMMAND=None) :  #COMMUN#

    assert COMMAND in ('MACR_ASCOUF_CALC','MACR_ASPIC_CALC','CALC_G','POST_GP','CALC_ESSAI_GEOMECA','CALC_EUROPLEXUS',
                       'CALC_POINT_MAT','SIMU_POINT_MAT', 'DYNA_NON_LINE','STAT_NON_LINE','CALCUL','CALC_FORC_NONL',
                       'CALC_IFS_DNL','CALC_PRECONT','CREA_RESU','LIRE_RESU','MACR_ECREVISSE','TEST_COMPOR',None)

    if COMMAND !='CALC_EUROPLEXUS':
        mcfact = FACT(statut='f',min=1,max='**',

           RELATION  =SIMP( statut='o',typ='TXM',defaut="ELAS",into=C_RELATION(COMMAND)),
           b_monox     = BLOC(condition = "RELATION == 'MONOCRISTAL' ",
                                 fr="SD issue de DEFI_COMPOR",
                   COMPOR =SIMP(statut='o',typ=compor_sdaster,max=1),),
           b_polyx     = BLOC(condition = "RELATION == 'POLYCRISTAL' ",
                                 fr="SD issue de DEFI_COMPOR",
                   COMPOR =SIMP(statut='o',typ=compor_sdaster,max=1),),
           b_zmat      = BLOC(condition = "RELATION == 'ZMAT' ",
                                 fr="Comportement de la bibliotheque Zmat",
                   NB_VARI =SIMP(statut='o',typ='I',max=1),
                   UNITE =SIMP(statut='o',typ='I',max=1),),
           b_umat      = BLOC(condition = "RELATION == 'UMAT' ",
                                 fr="Comportement utilisateur de type UMAT",
                   NB_VARI =SIMP(statut='o',typ='I',max=1,fr="Nombre de variables internes"),
                   LIBRAIRIE = SIMP(statut='o', typ='TXM',validators=LongStr(1,128),
                        fr="Chemin vers la bibliothèque dynamique définissant le comportement UMAT"),
                   NOM_ROUTINE = SIMP(statut='o', typ='TXM',
                        fr="Nom de la routine UMAT dans la bibliothèque"),),
           b_mfront      = BLOC(condition = "RELATION == 'MFRONT' ",
                                 fr="Comportement utilisateur de type MFRONT",
                   NB_VARI =SIMP(statut='o',typ='I',max=1,fr="Nombre de variables internes"),
                   LIBRAIRIE = SIMP(statut='o', typ='TXM',validators=LongStr(1,128),
                        fr="Chemin vers la bibliothèque dynamique définissant le comportement MFRONT"),
                   NOM_ROUTINE = SIMP(statut='o', typ='TXM',
                        fr="Nom de la routine MFRONT dans la bibliothèque"),),

# KITs
           b_kit_ddi = BLOC(condition = "RELATION == 'KIT_DDI' ",
                            fr="relations de couplage fluage-plasticite",
               RELATION_KIT    =SIMP(statut='o',typ='TXM',min=2,max=2,validators=NoRepeat(),
                                 into=(
                                       "VMIS_CINE_LINE",
                                       "VMIS_ISOT_TRAC",
                                       "VMIS_ISOT_LINE",
                                       "VMIS_ISOT_PUIS",
                                       "GLRC_DM",
                                       "GRANGER_FP",
                                       "GRANGER_FP_INDT",
                                       "GRANGER_FP_V",
                                       "BETON_UMLV_FP",
                                       "ROUSS_PR",
                                       "BETON_DOUBLE_DP",
                                       "ENDO_ISOT_BETON",
                                       "MAZARS"
                                       ),),
                   ),
           b_kit_cg= BLOC(condition = "RELATION == 'KIT_CG' ",
                            fr="relations pour elements cables gaines",
               RELATION_KIT    =SIMP(statut='o',typ='TXM',min=2,max=2,validators=NoRepeat(),
                                 into=(
                                       "CABLE_GAINE_FROT",
                                       "VMIS_ISOT_LINE",
                                       "VMIS_ISOT_TRAC",
                                       "VMIS_CINE_LINE",
                                       "PINTO_MENEGOTTO",
                                       "ELAS",
                                       "SANS"
                                       ),),
                   ),

           b_kit_thm = BLOC(condition = "RELATION in ['KIT_HHM','KIT_HH','KIT_H','KIT_HM','KIT_THHM', \
                                                      'KIT_THH','KIT_THM','KIT_THV']",
                            fr="lois de comportements thermo-hydro-mecaniques",
               RELATION_KIT    =SIMP(statut='o',typ='TXM',max=9,validators=NoRepeat(),
                                 into=(
# MECA
                                       "ELAS",
                                       "CJS",
                                       "HUJEUX",
                                       "CAM_CLAY",
                                       "BARCELONE",
                                       "LAIGLE",
                                       "LETK",
                                       "DRUCK_PRAGER",
                                       "DRUCK_PRAG_N_A",
                                       "VISC_DRUC_PRAG",
                                       "ELAS_GONF",
                                       "HOEK_BROWN_EFF",
                                       "HOEK_BROWN_TOT",
                                       "MAZARS",
                                       "ENDO_ISOT_BETON",
                                       "JOINT_BANDIS",
                                       "CZM_LIN_REG",
                                       "CZM_EXP_REG",
# THMC
                                       "GAZ",
                                       "LIQU_SATU",
                                       "LIQU_GAZ_ATM",
                                       "LIQU_VAPE_GAZ",
                                       "LIQU_AD_GAZ_VAPE",
                                       "LIQU_AD_GAZ",
                                       "LIQU_VAPE",
                                       "LIQU_GAZ",
# HYDR
                                       "HYDR_UTIL",
                                       "HYDR_VGM",
                                       "HYDR_VGC",
                                       "HYDR",
                                       "HYDR_ENDO",
                                       ),),
                                       ),
           b_kit_meta = BLOC(condition = "RELATION in ('META_LEMA_ANI','META_P_CL_PT_RE','META_P_CL_PT','META_P_CL_RE','META_P_CL',\
       'META_P_IL_PT_RE','META_P_IL_PT','META_P_IL_RE','META_P_IL','META_P_INL_PT_RE','META_P_INL_PT','META_P_INL_RE','META_P_INL',\
           'META_V_CL_PT_RE','META_V_CL_PT','META_V_CL_RE','META_V_CL','META_V_IL_PT_RE','META_V_IL_PT','META_V_IL_RE','META_V_IL',\
           'META_V_INL_PT_RE','META_V_INL_PT','META_V_INL_RE','META_V_INL')",
                            fr="nombre de phases metallurgiques",
               RELATION_KIT    =SIMP(statut='o',typ='TXM',max=1,validators=NoRepeat(),
                                 into=("ACIER","ZIRC"),),
                                 ),

           DEFORMATION       =SIMP(statut='f',typ='TXM',defaut="PETIT",
                                   into=("PETIT","PETIT_REAC","GROT_GDEP","SIMO_MIEHE","GDEF_HYPO_ELAS","GDEF_LOG")),

           # gestion des contraintes planes par la méthode itérative

              RESI_CPLAN_MAXI    =SIMP(statut='f',typ='R',
                                      fr="Critère d'arret absolu pour assurer la condition de contraintes planes"),

                   b_resi_cplan  =BLOC(condition = " RESI_CPLAN_MAXI == None ",

              RESI_CPLAN_RELA   =SIMP(statut='f',typ='R',defaut= 1.0E-6,
                                      fr="Critère d'arret relatif pour assurer la condition de contraintes planes"),
                                  ),

              ITER_CPLAN_MAXI =SIMP(statut='f',typ='I',defaut= 1,
                                      fr="Nombre d'itérations maxi pour assurer la condition de contraintes planes"),
           #
           RESI_INTE_RELA    =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI    =SIMP(statut='f',typ='I',defaut= 20 ),

           b_redec_local      = BLOC(condition = "DEFORMATION in ('PETIT','PETIT_REAC','GROT_GDEP')",
                                     fr="Nombre de redécoupages internes du pas de temps",
               ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
                                     ),

           ALGO_INTE         =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE", "SECANTE", "DEKKER", "NEWTON_1D","BRENT",
                                                              "NEWTON", "NEWTON_RELI", "NEWTON_PERT", "RUNGE_KUTTA",
                                                              "SPECIFIQUE", "SANS_OBJET")),

           TYPE_MATR_TANG    =SIMP(statut='f',typ='TXM',into=("PERTURBATION","VERIFICATION","TANGENTE_SECANTE")),

           b_perturb         =BLOC(condition = " (TYPE_MATR_TANG != None) and (TYPE_MATR_TANG != 'TANGENTE_SECANTE') ",
                                   fr="Calcul de la matrice tangente par perturbation, valeur de la perturbation",
                VALE_PERT_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-5),
                                  ),

           b_tangsec        = BLOC(condition = " TYPE_MATR_TANG == 'TANGENTE_SECANTE' ",
                                   fr="Modification evolutive de la matrice tangente/secante",
                 SEUIL        =SIMP(statut='f',typ='R',defaut= 3. ),
                 AMPLITUDE    =SIMP(statut='f',typ='R',defaut= 1.5 ),
                 TAUX_RETOUR  =SIMP(statut='f',typ='R',defaut= 0.05 ),
                                  ),

           b_crirupt        = BLOC(condition =
           " RELATION in ('VMIS_ISOT_LINE','VMIS_ISOT_TRAC','VISCOCHAB','VISC_ISOT_LINE','VISC_ISOT_TRAC',)",
                                   fr="Critere de rupture selon une contrainte critique",
                 POST_ITER    =SIMP(statut='f',typ='TXM',into=("CRIT_RUPT",), ),
                                  ),

           PARM_THETA      =SIMP(statut='f',typ='R',val_min=0.,val_max=1., defaut= 1.),
           PARM_ALPHA      =SIMP(statut='f',typ='R',defaut= 1. ),

           b_radi          =BLOC(condition = "TYPE_MATR_TANG == None",
              RESI_RADI_RELA  =SIMP(statut='f',typ='R', ),
                               ),

           regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

         )

    else:
        mcfact = FACT(statut='o',min=1,max='**',  #COMMUN#

           RELATION  = SIMP( statut='o',typ='TXM',defaut="ELAS",into=('ELAS','GLRC_DAMAGE')),
           GROUP_MA  = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
        )


    return mcfact

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
def C_CONVERGENCE() : return FACT(statut='d',
           regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA','RESI_COMP_RELA'),),
           b_refe_rela    =BLOC(condition = "RESI_REFE_RELA != None",
             regles=(AU_MOINS_UN('SIGM_REFE','EPSI_REFE','FLUX_THER_REFE','FORC_REFE',
                                  'FLUX_HYD1_REFE','FLUX_HYD2_REFE','VARI_REFE','DEPL_REFE','LAGR_REFE'),),
             FORC_REFE       =SIMP(statut='f',typ='R',min=2,max=2,
                fr="Force et Moment de référence pour les éléments de structure."),
             SIGM_REFE       =SIMP(statut='f',typ='R'),
             DEPL_REFE       =SIMP(statut='f',typ='R'),
             EPSI_REFE       =SIMP(statut='f',typ='R'),
             FLUX_THER_REFE  =SIMP(statut='f',typ='R'),
             FLUX_HYD1_REFE  =SIMP(statut='f',typ='R'),
             FLUX_HYD2_REFE  =SIMP(statut='f',typ='R'),
             VARI_REFE       =SIMP(statut='f',typ='R'),
             LAGR_REFE       =SIMP(statut='f',typ='R'),
           ),
           RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           RESI_COMP_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
def C_INCREMENT(TYPE_CMD) :   #COMMUN#
#
    assert TYPE_CMD in ('THERMIQUE','MECANIQUE',)
    kwargs = {}
    statut_liste_inst = ' '

# La liste d'instants est facultative en thermique et obligatoire en mecanique

    if TYPE_CMD in ('THERMIQUE'):
      statut_liste_inst = 'f'
    elif TYPE_CMD in ('MECANIQUE'):
      statut_liste_inst = 'o'

    kwargs['LIST_INST']         =SIMP(statut=statut_liste_inst,typ=(listr8_sdaster,list_inst))
    kwargs['NUME_INST_INIT']    =SIMP(statut='f',typ='I')
    kwargs['INST_INIT']         =SIMP(statut='f',typ='R')
    kwargs['NUME_INST_FIN']     =SIMP(statut='f',typ='I')
    kwargs['INST_FIN']          =SIMP(statut='f',typ='R')
    kwargs['PRECISION']         =SIMP(statut='f',typ='R',defaut=1.0E-6 )

    mcfact = FACT(statut=statut_liste_inst,max='**',            
                  regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                            EXCLUS('NUME_INST_FIN','INST_FIN'),),
                  **kwargs)

    return mcfact

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
def C_NEWTON() : return FACT(statut='d',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1,val_min=0),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOLE") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           PAS_MINI_ELAS   =SIMP(statut='f',typ='R',val_min=0.0),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut=0,val_min=0),
           REAC_ITER_ELAS  =SIMP(statut='f',typ='I',defaut=0,val_min=0),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
         );

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: josselin.delmas at edf.fr

class NOM_CHAM_INTO:  #COMMUN#
    """
    """
    def Tous(self):
        """ Tous les champs
        """
        self.all_phenomenes = ('CONTRAINTE', 'DEFORMATION', 'ENERGIE', 'CRITERES',
                               'VARI_INTERNE', 'HYDRAULIQUE', 'THERMIQUE',
                               'ACOUSTIQUE', 'FORCE', 'ERREUR', 'DEPLACEMENT',
                               'METALLURGIE', 'AUTRES')
        d = {}
        d['CONTRAINTE'] = {
            "EFGE_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Efforts généralisés aux points de Gauss"), ),
            "EFGE_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Efforts généralisés aux noeuds par élément"), ),
            "EFGE_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Efforts généralisés aux noeuds"), ),
            "SIEF_ELGA":        ( ("lin",),
                                 _(u"Contraintes et efforts aux points de Gauss"), ),
            "SIEF_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Contraintes et efforts aux noeuds par élément"), ),
            "SIEF_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Contraintes et efforts aux noeuds"), ),
            "SIGM_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Contraintes aux points de Gauss"), ),
            "SIGM_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Contraintes aux noeuds par élément"), ),
            "SIGM_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Contraintes aux noeuds"), ),
            "SIPM_ELNO":        ( ("lin","nonlin"),
                                 _(u"Contraintes aux noeuds par élément pour les éléments de poutre"), ),
            "SIPO_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Contraintes aux noeuds par élément pour les éléments de poutre"), ),
            "SIPO_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Contraintes aux noeuds pour les éléments de poutre"), ),
            "SIRO_ELEM":        ( ("lin", "nonlin",),
                                 _(u"Contraintes de rosette par élément"), ),
        }
        d['DEFORMATION'] = {
            "DEGE_ELGA":        ( ("lin", "nonlin",),          
                                 _(u"Déformations généralisées aux points de Gauss"), ),
            "DEGE_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations généralisées aux noeuds par élément"), ),
            "DEGE_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations généralisées aux noeuds"), ),
            "EPFD_ELGA":        ( ("nonlin",),
                                 _(u"Déformations de fluage de déssication aux points de Gauss"), ),
            "EPFD_ELNO":        ( ("nonlin",),
                                 _(u"Déformations de fluage de déssication aux noeuds par élément"), ),
            "EPFD_NOEU":        ( ("nonlin",),
                                 _(u"Déformations de fluage de déssication aux noeuds"), ),
            "EPFP_ELGA":        ( ("nonlin",),
                                 _(u"Déformations de fluage propre aux points de Gauss"), ),
            "EPFP_ELNO":        ( ("nonlin",),
                                 _(u"Déformations de fluage propre aux noeuds par élément"), ),
            "EPFP_NOEU":        ( ("nonlin",),
                                 _(u"Déformations de fluage propre aux noeuds"), ),
            "EPME_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques en petits déplacements aux points de Gauss"), ),
            "EPME_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques en petits déplacements aux noeuds par élément"), ),
            "EPME_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques en petits déplacements aux noeuds"), ),
            "EPMG_ELGA":        ( ("nonlin",),
                                 _(u"Déformations mécaniques en grands déplacements aux points de Gauss"), ),
            "EPMG_ELNO":        ( ("nonlin",),
                                 _(u"Déformations mécaniques en grands déplacements aux noeuds par élément"), ),
            "EPMG_NOEU":        ( ("nonlin",),
                                 _(u"Déformations mécaniques en grands déplacements aux noeuds"), ),
            "EPSG_ELGA":        ( ("lin","nonlin",),
                                 _(u"Déformations de Green-Lagrange aux points de Gauss"), ),
            "EPSG_ELNO":        ( ("lin","nonlin",),
                                 _(u"Déformations de Green-Lagrange aux noeuds par élément"), ),
            "EPSG_NOEU":        ( ("lin","nonlin",),
                                 _(u"Déformations de Green-Lagrange aux noeuds"), ),
            "EPSI_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Déformations aux points de Gauss"), ),
            "EPSI_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations aux noeuds par élément"), ),
            "EPSI_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations aux noeuds"), ),
            "EPSP_ELGA":        ( ("nonlin",),
                                 _(u"Déformations anélastique aux points de Gauss"), ),
            "EPSP_ELNO":        ( ("nonlin",),
                                 _(u"Déformations anélastique aux noeuds par élément"), ),
            "EPSP_NOEU":        ( ("nonlin",),
                                 _(u"Déformations anélastique aux noeuds"), ),
            "EPVC_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Déformations dues aux variables de commande aux points de Gauss"), ),
            "EPVC_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations dues aux variables de commande aux noeuds par élément"), ),
            "EPVC_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations dues aux variables de commande aux noeuds"), ),
        }
        d['ENERGIE'] = {
            "DISS_ELEM":        ( ("lin", "nonlin",),
                                 _(u"Énergie de dissipation par élément"), ),
            "DISS_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie de dissipation aux points de Gauss"), ),
            "DISS_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie de dissipation aux noeuds par élément"), ),
            "DISS_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie de dissipation aux noeuds"), ),
            "ECIN_ELEM":        ( ("lin",),
                                 _(u"Énergie cinétique par élément"), ),
            "ENEL_ELEM":        ( ("lin", "nonlin",),
                                 _(u"Énergie élastique par élément"), ),
            "ENEL_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie élastique aux points de Gauss"), ),
            "ENEL_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie élastique aux noeuds par élément"), ),
            "ENEL_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Densité d'énergie élastique aux noeuds"), ),
            "EPOT_ELEM":        ( ("lin",),
                                 _(u"Énergie potentielle de déformation élastique par élément"), ),
            "ETOT_ELEM":        ( ("lin", "nonlin",),
                                 _(u"Incrément d'énergie de déformation totale par élément"), ),
            "ETOT_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Incrément de densité d'énergie de déformation totale aux points de Gauss"), ),
            "ETOT_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Incrément de densité d'énergie de déformation totale aux noeuds par élément"), ),
            "ETOT_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Incrément de densité d'énergie de déformation totale aux noeuds"), ),
        }                       
        d['CRITERES'] = {
            "DERA_ELGA":        ( ("nonlin",),
                                 _(u"Indicateur local de décharge et de perte de radialité aux points de Gauss"), ),
            "DERA_ELNO":        ( ("nonlin",),
                                 _(u"Indicateur local de décharge et de perte de radialité aux noeuds par élément"), ),
            "DERA_NOEU":        ( ("nonlin",),
                                 _(u"Indicateur local de décharge et de perte de radialité aux noeuds"), ),
            "ENDO_ELGA":        ( ("nonlin",),
                                 _(u"Dommage de Lemaître-Sermage aux points de Gauss"), ),
            "ENDO_ELNO":        ( ("nonlin",),
                                 _(u"Dommage de Lemaître-Sermage aux noeuds par élément"), ),
            "ENDO_NOEU":        ( ("nonlin",),
                                 _(u"Dommage de Lemaître-Sermage aux noeuds"), ),
            "EPEQ_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Déformations équivalentes aux points de Gauss"), ),
            "EPEQ_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations équivalentes aux noeuds par élément"), ),
            "EPEQ_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations équivalentes aux noeuds"), ),
            "EPMQ_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques équivalentes aux points de Gauss"), ),
            "EPMQ_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques équivalentes aux noeuds par élément"), ),
            "EPMQ_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Déformations mécaniques équivalentes aux noeuds"), ),
            "INDL_ELGA":        ( ("nonlin",),
                                 _(u"Indicateur de localisation aux points de Gauss"), ),
            "PDIL_ELGA":        ( ("nonlin",),
                                 _(u"Module de rigidité de micro-dilatation"), ),
            "SIEQ_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Contraintes équivalentes aux points de Gauss"), ),
            "SIEQ_ELNO":        ( ("lin", "nonlin",),
                                 _(u"Contraintes équivalentes aux noeuds par élément"), ),
            "SIEQ_NOEU":        ( ("lin", "nonlin",),
                                 _(u"Contraintes équivalentes aux noeuds"), ),
        }
        d['VARI_INTERNE'] = {
            "VAEX_ELGA":        ( ("nonlin",),
                                 _(u"Extraction d'une variable interne aux points de Gauss"), ),
            "VAEX_ELNO":        ( ("nonlin",),
                                 _(u"Extraction d'une variable interne aux noeuds pas élément"), ),
            "VAEX_NOEU":        ( ("nonlin",),
                                 _(u"Extraction d'une variable interne aux noeuds"), ),
            "VARC_ELGA":        ( ("lin", "nonlin",),
                                 _(u"Variables de commande aux points de Gauss"), ),
            "VARI_ELNO":        ( ("nonlin",),
                                 _(u"Variables internes aux noeuds pas élément"), ),
            "VARI_NOEU":        ( ("nonlin",),
                                 _(u"Variables internes aux noeuds"), ),
        }
        d['HYDRAULIQUE'] = {
            "FLHN_ELGA":        ( ("nonlin",),
                                 _(u"Flux hydrauliques aux points de Gauss"), ),
        }
        d['THERMIQUE'] = {
            "TEMP_ELGA":        ( (),
                                 _(u"Température aux points de Gauss"), ),
            "FLUX_ELGA":        ( (),
                                 _(u"Flux thermique aux points de Gauss"), ),
            "FLUX_ELNO":        ( (),
                                 _(u"Flux thermique aux noeuds par élément"), ),
            "FLUX_NOEU":        ( (),
                                 _(u"Flux thermique aux noeuds"), ),
            "HYDR_NOEU":        ( (),
                                 _(u"Hydratation aux noeuds"), ),
            "SOUR_ELGA":        ( (),
                                 _(u"Source de chaleur à partir d'un potentiel électrique"), ),
            "ETHE_ELEM":        ( (),
                                 _(u"Énergie dissipée thermiquement"), ),
        }
        d['ACOUSTIQUE'] = {
            "PRAC_ELNO":        ( (),
                                 _(u"Pression acoustique aux noeuds par élément"), ),
            "PRAC_NOEU":        ( (),
                                 _(u"Pression acoustique aux noeuds"), ),
            "PRME_ELNO":        ( (),
                                 _(u"Pression aux noeuds par élément pour les éléments FLUIDE"), ),
            "INTE_ELNO":        ( (),
                                 _(u"Intensité acoustique aux noeuds par élément"), ),
            "INTE_NOEU":        ( (),
                                 _(u"Intensité acoustique aux noeuds"), ),
        }
        d['FORCE'] = {
            "FORC_NODA":        ( (),
                                 _(u"Forces nodales"), ),
            "REAC_NODA":        ( (),
                                 _(u"Réactions nodales"), ),
        }
        d['ERREUR'] = {
            "SIZ1_NOEU":        ( (),
                                 _(u"Contraintes lissées de Zhu-Zienkiewicz version 1 aux noeuds"), ),
            "ERZ1_ELEM":        ( (),
                                 _(u"Indicateur d'erreur de Zhu-Zienkiewicz version 1 par élément"), ),
            "SIZ2_NOEU":        ( (),
                                 _(u"Contraintes lissées de Zhu-Zienkiewicz version 2 aux noeuds"), ),
            "ERZ2_ELEM":        ( (),
                                 _(u"Indicateur d'erreur de Zhu-Zienkiewicz version 2 par élément"), ),
            "ERME_ELEM":        ( (),
                                 _(u"Indicateur d'erreur en résidu en mécanique par élément"), ),
            "ERME_ELNO":        ( (),
                                 _(u"Indicateur d'erreur en résidu en mécanique aux noeuds par élément"), ),
            "ERME_NOEU":        ( (),
                                 _(u"Indicateur d'erreur en résidu en mécanique aux noeuds"), ),
            "QIRE_ELEM":        ( (),
                                 _(u"Indicateur d'erreur en quantités d'intérêt en résidu par élément"), ),
            "QIRE_ELNO":        ( (),
                                 _(u"Indicateur d'erreur en quantités d'intérêt en résidu aux noeuds par élément"), ),
            "QIRE_NOEU":        ( (),
                                 _(u"Indicateur d'erreur en quantités d'intérêt en résidu aux noeuds"), ),
            "QIZ1_ELEM":        ( (),
                                 _(u"Indicateur d'erreur en quantités d'intérêt de Zhu-Zienkiewicz version 1 par élément"), ),
            "QIZ2_ELEM":        ( (),
                                 _(u"Indicateur d'erreur en quantités d'intérêt de Zhu-Zienkiewicz version 2 par élément"), ),
            "SING_ELEM":        ( (),
                                 _(u"Degré de singularité par élément"), ),
            "SING_ELNO":        ( (),
                                 _(u"Degré de singularité aux noeuds par élément"), ),
            "ERTH_ELEM":        ( (),
                                 _(u"Indicateur d'erreur en résidu en thermique par élément"), ),
            "ERTH_ELNO":        ( (),
                                 _(u"Indicateur d'erreur en résidu en thermique aux noeuds par élément"), ),
            "ERTH_NOEU":        ( (),
                                 _(u"Indicateur d'erreur en résidu en thermique aux noeuds"), ),
        }
        d['METALLURGIE'] = {
            "DURT_ELNO":        ( (),
                                 _(u"Dureté aux noeuds par élément"), ),
            "DURT_NOEU":        ( (),
                                 _(u"Dureté aux noeuds"), ),
            "META_ELNO":        ( (),
                                 _(u"Proportion de phases métallurgiques aux noeuds par élément"), ),
            "META_NOEU":        ( (),
                                 _(u"Proportion de phases métallurgiques aux noeuds"), ),
        }
        d['DEPLACEMENT'] = {
            "ACCE":             ( (),
                                 _(u"Accélération aux noeuds"), ),
            "ACCE_ABSOLU":      ( (),
                                 _(u"Accélération absolue aux noeuds"), ),
            "DEPL":             ( (),
                                 _(u"Déplacements aux noeuds"), ),
            "DEPL_ABSOLU":      ( (),
                                 _(u"Déplacements absolus aux noeuds"), ),
            "STRX_ELGA":        ( (),
                                 _(u"Efforts généralisés à partir des déplacements en linéaire aux points de Gauss"), ),
            "TEMP":             ( (),
                                 _(u"Température aux noeuds"), ),
            "VITE":             ( (),
                                 _(u"Vitesse aux noeuds"), ),
            "VALE_CONT":        ( (),
                                 _(u"Statuts de contact"), ),
            "VARI_ELGA":        ( (),
                                 _(u"Variables internes aux points de Gauss"), ),
            "VITE_ABSOLU":      ( (),
                                 _(u"Vitesse absolue aux noeuds"), ),
        }
        d['AUTRES'] = {
            "COMPORTEMENT":     ( (),
                                 _(u"Carte de comportement mécanique"), ),
            "COMPORTHER":       ( (),
                                 _(u"Carte de comportement thermique"), ),
            "DEPL_VIBR":        ( (),
                                 _(u"Déplacement pour mode vibratoire"), ),
            "DIVU":             ( (),
                                 _(u"Déformation volumique en THM"), ),
            "EPSA_ELNO":        ( (),
                                 _(u"Déformations anélastique aux noeuds par élément"), ),
            "EPSA_NOEU":        ( (),
                                 _(u"Déformations anélastique aux noeuds"), ),
            "FERRAILLAGE":      ( ("lin",),
                                 _(u"Densité de ferraillage"), ),
            "FSUR_2D":          ( (),
                                 _(u"Chargement de force surfacique en 2D"), ),
            "FSUR_3D":          ( (),
                                 _(u"Chargement de force surfacique en 3D"), ),
            "FVOL_2D":          ( (),
                                 _(u"Chargement de force volumique en 2D"), ),
            "FVOL_3D":          ( (),
                                 _(u"Chargement de force volumique en 3D"), ),
            "HYDR_ELNO":        ( (),
                                 _(u"Hydratation aux noeuds par élément"), ),
            "IRRA":             ( (),
                                 _(u"Irradition aux noeuds"), ),
            "MODE_FLAMB":       ( (),
                                 _(u"Mode de flambement"), ),
            "MODE_STAB":        ( (),
                                 _(u"Mode de stabilité"), ),
            "NEUT":             ( (),
                                 _(u"Variable de commande 'neutre'"), ),
            "PRES":             ( (),
                                 _(u"Chargement de pression"), ),
            "PTOT":             ( (),
                                 _(u"Pression totale de fluide en THM"), ),
            "SISE_ELNO":        ( (),
                                 _(u"Contraintes aux noeuds par sous-élément"), ),
            "SPMX_ELGA":        ( (),
                                 _(u"Valeurs maximum sur un sous-point"), ),
            "THETA":            ( (),
                                 _(u"Champ theta"), ),
            "VITE_VENT":        ( (),
                                 _(u"Chargement vitesse du vent"), ),
        }
        for typ in ('ELGA', 'ELNO', 'ELEM', 'NOEU', 'CART'):
            for i in range(1, 11):
                d['AUTRES']['UT%02d_%s' % (i, typ)]=( (),
                                 _(u"Champ utilisateur numéro %02d_%s" % (i, typ)), )
        self.d_all = d
        return

    def CheckPhenom(self):
        """ Vérification de la cohérence entre les phenomènes et les clés
        """
        l_keys = list(self.d_all.keys())
        l_phen = list(self.all_phenomenes)
        uniq_keys = set(l_keys)
        uniq_phen = set(l_phen)
        if len(l_keys) != len(uniq_keys) or len(l_phen) != len(uniq_phen) :
            for i in uniq_keys :
                l_keys.remove(i)
            assert len(l_keys) == 0, 'Keys must be unique: %s' % l_keys
            for i in uniq_phen :
                l_phen.remove(i)
            assert len(l_phen) == 0, 'Phenomenon must be unique: %s' % l_phen
        if len(l_keys) > len(l_phen) :
            for i in l_phen :
                l_keys.remove(i)
            assert len(l_keys) == 0, 'Key %s not listed in the list of phenomenons' % l_keys
        if len(l_keys) < len(l_phen) :
            for i in l_keys:
                l_phen.remove(i)
            assert len(l_phen) == 0, 'Phenomenon %s not known as a key' % l_phen


    def CheckField(self):
        """ Vérification des doublons dans les noms des champs
        """
        l_cham = []
        for phen in self.all_phenomenes:
            l_cham.extend(self.d_all[phen].keys())
        uniq = set(l_cham)
        if len(l_cham) != len(uniq):
            for i in uniq:
                l_cham.remove(i)
            assert len(l_cham) == 0, 'Field names must be unique: %s' % l_cham


    def InfoChamps(self, l_nom_cham):
        """ on renvoie juste les informations relatives au(x) champ(s)
        """
        d_cham = {}.fromkeys( l_nom_cham, ( '', '', '' ) )
        for nom_cham in l_nom_cham:
            for phen in self.all_phenomenes:
              for cham in self.d_all[phen].keys():
                  if nom_cham == cham:
                      cate = self.d_all[phen][cham][0]
                      helptxt = self.d_all[phen][cham][1]
                      d_cham[nom_cham] = ( phen, cate, helptxt )
        return d_cham

    def Filtre(self, *l_typ_cham, **kwargs):
        """ Check des doublons
        """
        phenomene   = kwargs.get('phenomene')
        categorie   = kwargs.get('categorie')
        # Construction de la liste des champs en tenant compte des eventuels filtre (phenomene, categorie, l_typ_cham)
        # ------------------------------------------------------------------------------------------------------------
        l_cham = []
        # Filtre par phenomene
        if phenomene is None:
            l_phen = self.all_phenomenes
        else:
            l_phen = [ phenomene ]
        for phen in l_phen:
            # parcours de tous les champs
            for cham in self.d_all[phen].keys():
               isok = True
               # Filtre par categorie
               if categorie is not None:
                 lcat = self.d_all[phen][cham][0]
                 if type(lcat) not in (tuple, list):
                     lcat = [lcat, ]
                 if categorie in lcat:
                     isok = True
                 else:
                     isok = False
               if isok:
                 l_cham.append(cham)
        l_cham.sort()
        # Filtre sur les types de champs
        if len(l_typ_cham) == 0:
            return tuple(l_cham)
        l_ncham = []
        for typ in l_typ_cham :
            for cham in l_cham :
                if typ in cham.split('_'):
                  l_ncham.append(cham)
        return tuple(l_ncham)

    def __init__(self):
        self.Tous()
        # check les doublons (fonctionnalite developpeur permettant de detecter les doublons dans les champs)
        if 1:
            self.CheckPhenom()
            self.CheckField()

    def __call__(self, *l_typ_cham, **kwargs):
        """Cette fonction retourne la liste des "into" possibles pour le mot-clé NOM_CHAM.
        C'est à dire les noms de champs des SD RESULTAT (DATA de la routine RSCRSD).
        l_typ_cham : rien ou un ou plusieurs parmi 'ELGA', 'ELNO', 'NOEU', 'ELEM'.
        kwargs : un dictionnaire de mot-cles, les cles parmis : 
          'phenomene'  : retourne la liste des champs en filtrant par le phenomene (eventuellement mixe avec le suivant)
          'categorie'  : retourne la liste des champs en filtrant par le phenomene (eventuellement mixe avec le precedent)
          'l_nom_cham' : (une liste ou un string) retourne uniqement les informations relatives au champ precise en argument
        """
        l_nom_cham  = kwargs.get('l_nom_cham')
        if type(l_nom_cham) == str:
            l_nom_cham = [ l_nom_cham ]
        if l_nom_cham:
            return self.InfoChamps(l_nom_cham)
        else:
            return self.Filtre(*l_typ_cham, **kwargs)


C_NOM_CHAM_INTO = NOM_CHAM_INTO()

# person_in_charge: xavier.desroches at edf.fr
# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# ce fichier contient la liste des  noms des grandeurs de CODE_ASTER
def C_NOM_GRANDEUR() : return  ( #COMMUN#
"ABSC_R",
"ADRSJEVE",
"ADRSJEVN",
"CAARPO",
"CACABL",
"CACOQU",
"CADISA",
"CADISK",
"CADISM",
"CAFI_R",
"CAGEBA",
"CAGEPO",
"CAGNBA",
"CAGNPO",
"CAMASS",
"CAORIE",
"CAPOUF",
"CARCRI",
"CASECT",
"CHLI_R",
"CODE_I",
"COEH_F",
"COEH_R",
"COMPOR",
"CORR_R",
"CRRU_R",
"DBEL_R",
"DCEL_I",
"DDLI_C",
"DDLI_F",
"DDLI_R",
"DDLM_C",
"DDLM_R",
"DEPL_C",
"DEPL_F",
"DEPL_R",
"DISS_R",
"DOMA_R",
"DURT_R",
"ENDO_R",
"ENER_R",
"EPSI_C",
"EPSI_F",
"EPSI_R",
"ERRE_R",
"FACY_R",
"FELECR",
"FER2_R",
"FISS_R",
"FLAPLA",
"FLUN_F",
"FLUN_R",
"FLUX_F",
"FLUX_R",
"FORC_C",
"FORC_F",
"FORC_R",
"FREQ_R",
"FTHM_F",
"FTHM_R",
"G",
"GEOM_R",
"G_DEPL_R",
"HARMON",
"HYDR_R",
"IMPE_C",
"IMPE_F",
"IMPE_R",
"INDL_R",
"INFC_R",
"INST_R",
"INTE_R",
"INTLOC",
"IRRA_R",
"ITECREL",
"ITEDEC",
"J",
"LISTMA",
"MACOMP",
"MASS_R",
"MATE_F",
"NBSP_I",
"NEUT_F",
"NEUT_I",
"NEUT_K16",
"NEUT_K24",
"NEUT_K8",
"NEUT_R",
"NUMC_I",
"NUMMOD",
"ONDE_F",
"ONDE_R",
"PESA_R",
"PDIL_R",
"PILO_K",
"PILO_R",
"POSI",
"PREC",
"PRES_C",
"PRES_F",
"PRES_R",
"RAYO_F",
"RAYO_R",
"RCCM_K",
"RCCM_R",
"RESCREL",
"RICE_TRA",
"ROTA_R",
"SECTION",
"SIEF_C",
"SIEF_R",
"SIZZ_R",
"SOUR_F",
"SOUR_R",
"SPMX_R",
"STRX_R",
"STAOUDYN",
"TEMP_C",
"TEMP_F",
"TEMP_R",
"THETA",
"VALO_R",
"VANL_R",
"VAR2_R",
"VARI_R",
"VENTCX_F",
"VNOR_C",
"VNOR_F",
"VOISIN",
"WEIBULL",
"XCONTAC",
                                 )

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr

def C_OBSERVATION() : return FACT(statut='f',max=99,
           TITRE           =SIMP(statut='f',typ='TXM',max=1),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
                                   into=("VALE_CONT","FORC_NODA",
                                         "DEPL","VITE","ACCE","TEMP",
                                         "SIEF_ELGA","VARI_ELGA",
                                         "DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU",)),

           EVAL_CHAM       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                   into=("MIN","MAX","MOY","MAXI_ABS","MINI_ABS","VALE",),),

           NOM_CMP         =SIMP(statut='o',typ='TXM',max=20),
           EVAL_CMP        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                   into=("VALE","FORMULE",),),

           b_formule       =BLOC(condition="(EVAL_CMP=='FORMULE')",
                                   FORMULE = SIMP(statut='o',typ=formule,max=1),
                                ),

           b_cham_no       =BLOC(condition="(NOM_CHAM=='DEPL') or \
                                            (NOM_CHAM=='VITE') or \
                                            (NOM_CHAM=='ACCE') or \
                                            (NOM_CHAM=='TEMP') or \
                                            (NOM_CHAM=='FORC_NODA') or \
                                            (NOM_CHAM=='VALE_CONT') or \
                                            (NOM_CHAM=='DEPL_ABSOLU') or \
                                            (NOM_CHAM=='VITE_ABSOLU') or \
                                            (NOM_CHAM=='ACCE_ABSOLU')",
                                 regles   =(UN_PARMI('NOEUD','GROUP_NO','GROUP_MA','MAILLE','TOUT')),
                                 TOUT            =SIMP(statut='d',typ='TXM',into=("OUI",) ),
                                 NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                                 GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                                 MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                                 GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                                ),


           b_cham_elga     =BLOC(condition="(NOM_CHAM=='SIEF_ELGA') or \
                                            (NOM_CHAM=='VARI_ELGA')",
                                 regles          =(UN_PARMI('GROUP_MA','MAILLE','TOUT')),
                                 TOUT            =SIMP(statut='d',typ='TXM',into=("OUI",) ),
                                 MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                 GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
                                 EVAL_ELGA       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                                        into=("MIN","MAX","VALE",),),
                                 b_elga_vale     =BLOC(condition="(EVAL_ELGA=='VALE')",
                                   POINT           =SIMP(statut='o',typ='I'  ,validators=NoRepeat(),max='**'),
                                   SOUS_POINT      =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**'),
                                 ),
                                ),

           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           PAS_OBSE        =SIMP(statut='f',typ='I'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),


       );

# person_in_charge: mathieu.courtois at edf.fr
# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# ce fichier contient la liste des PARA possibles pour les fonctions et les nappes
def C_PARA_FONCTION() : return  ( #COMMUN#
                   "DX","DY","DZ","DRX","DRY","DRZ","TEMP","TSEC",
                   "INST","X","Y","Z","EPSI","META","FREQ","PULS","DSP",
                   "AMOR","ABSC","ABSC_CURV","SIGM","HYDR","SECH","PORO","SAT",
                   "PGAZ","PCAP","PLIQ","PVAP","PAD","VITE","ENDO",
                   "NORM","EPAIS","NEUT1","NEUT2",)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: kyrylo.kazymyrenko at edf.fr
def C_PILOTAGE() : return FACT(statut='f',
           regles=(EXCLUS('NOEUD','GROUP_NO'),PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TYPE    =SIMP(statut='o',typ='TXM',into=("DDL_IMPO","LONG_ARC","PRED_ELAS","DEFORMATION",
                                                    "ANA_LIM","SAUT_IMPO","SAUT_LONG_ARC") ),
           COEF_MULT     =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           EVOL_PARA     =SIMP(statut='f',typ='TXM',defaut="SANS", into=("SANS","CROISSANT","DECROISSANT") ),
           ETA_PILO_MAX  =SIMP(statut='f',typ='R'),
           ETA_PILO_MIN  =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MAX=SIMP(statut='f',typ='R'),
           ETA_PILO_R_MIN=SIMP(statut='f',typ='R'),
           PROJ_BORNES   =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           SELECTION     =SIMP(statut='f',typ='TXM',defaut="NORM_INCR_DEPL",
                               into=("RESIDU","MIXTE","ANGL_INCR_DEPL","NORM_INCR_DEPL")),
           TOUT          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA      =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           FISSURE       =SIMP(statut='f',typ=fiss_xfem ,validators=NoRepeat(),max='**'),
           MAILLE        =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           NOEUD         =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO      =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOM_CMP       =SIMP(statut='f',typ='TXM',max='**'),
           DIRE_PILO     =SIMP(statut='f',typ='TXM',max='**'),
         );

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
def C_RECH_LINEAIRE() : return FACT(statut='f',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="CORDE",into=("CORDE","MIXTE","PILOTAGE") ),
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3,val_max=999),
           RHO_MIN         =SIMP(statut='f',typ='R',defaut=1.0E-2),
           RHO_MAX         =SIMP(statut='f',typ='R',defaut=1.0E+1),
           RHO_EXCL        =SIMP(statut='f',typ='R',defaut=0.9E-2,val_min=0.),
         );

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix@edf.fr
#
def C_RELATION( COMMAND ):

    if COMMAND in ('CALC_G',):
                   return (             "ELAS",            #COMMUN#
                                        "ELAS_VMIS_LINE",
                                        "ELAS_VMIS_TRAC",
                                        "ELAS_VMIS_PUIS",
                                        "ELAS_HYPER",
                                        "VMIS_ISOT_LINE",
                                        "VMIS_ISOT_TRAC",
                                        # relations interdites depuis issue21711, elles
                                        # devront etre introduites dans le F90 si besoin
                                        #"VMIS_CINE_LINE",
                                        #"VMIS_ISOT_PUIS",
                                     )
    elif COMMAND in ('MACR_ASCOUF_CALC','MACR_ASPIC_CALC',):
                   return (             "ELAS",           
                                        "ELAS_VMIS_TRAC",
                                        "VMIS_ISOT_TRAC",
                                     )
    elif COMMAND =='DEFI_COMPOR' :
                   return (             "ELAS",  #uniquement ce qui a du sens (cf doc) et qui fait l'objet d'un test
                                        "BETON_UMLV_FP",
                                        "BETON_DOUBLE_DP",
                                        "CORR_ACIER",
                                        "GRANGER_FP",
                                        "GRANGER_FP_V",
                                        "GRANGER_FP_INDT",
                                        "GRAN_IRRA_LOG",
                                        "MAZARS_GC",
                                        "VISC_IRRA_LOG",
                                        "VMIS_CINE_GC",
                                        "VMIS_CINE_LINE",
                                        "VMIS_ISOT_LINE",
                                        "VMIS_ISOT_TRAC",
                                        "VMIS_ISOT_PUIS",
                                     )
    else :
                   return (             "ELAS",            
                                        "ELAS_VMIS_LINE",
                                        "ELAS_VMIS_TRAC",
                                        "ELAS_VMIS_PUIS",
                                        "ELAS_HYPER",
                                        "ELAS_POUTRE_GR",
                                        "CABLE",
                                        "ARME",
                                        "ASSE_CORN",
                                        "BARCELONE",
                                        "BETON_BURGER_FP",
                                        "BETON_DOUBLE_DP",
                                        "BETON_RAG",
                                        "BETOP_REGLE_PR",
                                        "BETON_UMLV_FP",
                                        "CABLE_GAINE_FROT",
                                        "CAM_CLAY",
                                        "CJS",
                                        "CORR_ACIER",
                                        "CZM_EXP",
                                        "CZM_EXP_REG",
                                        "CZM_FAT_MIX",
                                        "CZM_LIN_REG",
                                        "CZM_OUV_MIX",
                                        "CZM_TAC_MIX",
                                        "CZM_LAB_MIX",
                                        "CZM_TRA_MIX",
                                        "DIS_BILI_ELAS",
                                        "DIS_CHOC",
                                        "DIS_ECRO_CINE",
                                        "DIS_GOUJ2E_ELAS",
                                        "DIS_GOUJ2E_PLAS",
                                        "DIS_GRICRA",
                                        "DIS_VISC",
                                        "DRUCK_PRAGER",
                                        "DRUCK_PRAG_N_A",
                                        "ELAS_GONF",
                                        "ELAS_HYPER",
                                        "ENDO_CARRE",
                                        "ENDO_FISS_EXP",
                                        "ENDO_FRAGILE",
                                        "ENDO_HETEROGENE",
                                        "ENDO_ISOT_BETON",
                                        "ENDO_ORTH_BETON",
                                        "ENDO_SCALAIRE",
                                        "GATT_MONERIE",
                                        "GLRC_DAMAGE",
                                        "GLRC_DM",
                                        "DHRC",
                                        "GRANGER_FP",
                                        "GRANGER_FP_INDT",
                                        "GRANGER_FP_V",
                                        "GRAN_IRRA_LOG",
                                        "GRILLE_CINE_LINE",
                                        "GRILLE_ISOT_LINE",
                                        "GRILLE_PINTO_MEN",
                                        "HAYHURST",
                                        "HOEK_BROWN",
                                        "HOEK_BROWN_EFF",
                                        "HOEK_BROWN_TOT",
                                        "HUJEUX",
                                        "IRRAD3M",
                                        "JOINT_BA",
                                        "JOINT_BANDIS",
                                        "JOINT_MECA_RUPT",
                                        "JOINT_MECA_FROT",
                                        "KIT_CG",
                                        "KIT_DDI",
                                        "KIT_HH",
                                        "KIT_H",
                                        "KIT_HHM",
                                        "KIT_HM",
                                        "KIT_THH",
                                        "KIT_THHM",
                                        "KIT_THM",
                                        "KIT_THV",
                                        "LAIGLE",
                                        "LEMAITRE",
                                        "LEMAITRE_IRRA",
                                        "LEMA_SEUIL",
                                        "LETK",
                                        "LMARC_IRRA",
                                        "MAZARS",
                                        "MAZARS_GC",
                                        "META_LEMA_ANI",
                                        "META_P_CL",
                                        "META_P_CL_PT",
                                        "META_P_CL_PT_RE",
                                        "META_P_CL_RE",
                                        "META_P_IL",
                                        "META_P_IL_PT",
                                        "META_P_IL_PT_RE",
                                        "META_P_IL_RE",
                                        "META_P_INL",
                                        "META_P_INL_PT",
                                        "META_P_INL_PT_RE",
                                        "META_P_INL_RE",
                                        "META_V_CL",
                                        "META_V_CL_PT",
                                        "META_V_CL_PT_RE",
                                        "META_V_CL_RE",
                                        "META_V_IL",
                                        "META_V_IL_PT",
                                        "META_V_IL_PT_RE",
                                        "META_V_IL_RE",
                                        "META_V_INL",
                                        "META_V_INL_PT",
                                        "META_V_INL_PT_RE",
                                        "META_V_INL_RE",
                                        "MOHR_COULOMB",
                                        "MONOCRISTAL",
                                        "MULTIFIBRE",
                                        "NORTON",
                                        "NORTON_HOFF",
                                        "PINTO_MENEGOTTO",
                                        "POLYCRISTAL",
                                        "ROUSSELIER",
                                        "ROUSS_PR",
                                        "ROUSS_VISC",
                                        "RUPT_FRAG",
                                        "SANS",
                                        "VENDOCHAB",
                                        "VISC_ENDO_LEMA",
                                        "VISCOCHAB",
                                        "VISC_CIN1_CHAB",
                                        "VISC_CIN2_CHAB",
                                        "VISC_CIN2_MEMO",
                                        "VISC_CIN2_NRAD",
                                        "VISC_MEMO_NRAD",
                                        "VISC_DRUC_PRAG",
                                        "VISC_IRRA_LOG",
                                        "VISC_ISOT_LINE",
                                        "VISC_ISOT_TRAC",
                                        "VISC_TAHERI",
                                        "VMIS_ASYM_LINE",
                                        "VMIS_CIN1_CHAB",
                                        "VMIS_CIN2_CHAB",
                                        "VMIS_CINE_GC",
                                        "VMIS_CIN2_MEMO",
                                        "VMIS_CIN2_NRAD",
                                        "VMIS_MEMO_NRAD",
                                        "VMIS_CINE_LINE",
                                        "VMIS_ECMI_LINE",
                                        "VMIS_ECMI_TRAC",
                                        "VMIS_ISOT_LINE",
                                        "VMIS_ISOT_PUIS",
                                        "VMIS_ISOT_TRAC",
                                        "VMIS_JOHP_COOK",
                                        "ZMAT",
                                        "UMAT",
                                        "MFRONT",
                                     )

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: olivier.boiteau at edf.fr

def C_SOLVEUR( COMMAND, BASE=None ) :  #COMMUN#

# ----------------------------------------------------------------------------------------------------------------------------------
#
# VERIFICATIONS
#
# ----------------------------------------------------------------------------------------------------------------------------------

   assert COMMAND in ('CALC_ERREUR',
                      'CALC_FORC_AJOU',
                      'CALC_IFS_DNL',
                      'CALC_MATR_AJOU',
                      'CALC_PRECONT',
                      'CREA_ELEM_SSD',
                      'DEFI_BASE_MODALE',
                      'DYNA_LINE_HARM',
                      'DYNA_LINE_TRAN',
                      'DYNA_NON_LINE',
                      'DYNA_TRAN_MODAL',
                      'INFO_MODE',
                      'MACR_ASCOUF_CALC',
                      'MACR_ASPIC_CALC',
                      'MACRO_BASCULE_SCHEMA',
                      'MACRO_MATR_AJOU',
                      'MECA_STATIQUE',
                      'MODE_ITER_SIMULT',
                      'MODE_ITER_INV',
                      'MODE_STATIQUE',
                      'MODE_NON_LINE',
                      'STAT_NON_LINE',
                      'THER_LINEAIRE',
                      'THER_NON_LINE',
                      'THER_NON_LINE_MO',
                      )

   if BASE != None:
      assert COMMAND == 'DYNA_LINE_HARM'
      assert BASE in ('GENE','PHYS')

# ----------------------------------------------------------------------------------------------------------------------------------
#
# CLASSIFICATION EN 3 CATEGORIES :
#  - solveurs directs uniquement
#  - solveurs pour le linéaire
#  - solveurs pour le non-linéaire
#
# GESTION DES EXCEPTIONS
#
# ----------------------------------------------------------------------------------------------------------------------------------

   _type   = None

#  Classification ('SD'/'LIN'/'NL')
   if COMMAND in ('CREA_ELEM_SSD',
                  'DEFI_BASE_MODALE',
                  'DYNA_LINE_HARM',
                  'DYNA_TRAN_MODAL',
                  'INFO_MODE',
                  'MODE_ITER_SIMULT',
                  'MODE_ITER_INV',
                  ):
      _type = 'SD'
   elif COMMAND in ('CALC_ERREUR',
                    'CALC_FORC_AJOU',
                    'CALC_MATR_AJOU',
                    'DYNA_LINE_TRAN',
                    'MACRO_MATR_AJOU',
                    'MECA_STATIQUE',
                    'MODE_STATIQUE',
                    'THER_LINEAIRE',
                    'THER_NON_LINE_MO',
                    ):
      _type = 'LIN'
   elif COMMAND in ('CALC_IFS_DNL',
                    'CALC_PRECONT',
                    'DYNA_NON_LINE',
                    'MACR_ASCOUF_CALC',
                    'MACR_ASPIC_CALC',
                    'MACRO_BASCULE_SCHEMA',
                    'STAT_NON_LINE',
                    'THER_NON_LINE',
                    'MODE_NON_LINE',
                    ):
      _type = 'NL'
   else:
      assert False

# ----------------------------------------------------------------------------------------------------------------------------------

   _dist   = False

#  MATR_DISTRIBUEE ne fonctionnent que dans MECA_STATIQUE et MECA_NON_LINE
   if COMMAND in ('CALC_IFS_DNL',
                  'CALC_PRECONT',
                  'DYNA_NON_LINE',
                  'MACR_ASCOUF_CALC',
                  'MACR_ASPIC_CALC',
                  'MACRO_BASCULE_SCHEMA',
                  'MECA_STATIQUE',
                  'STAT_NON_LINE',
                  ):
      _dist = True

# ----------------------------------------------------------------------------------------------------------------------------------

   _gene   = False
   _ldlt   = False

#  Avec des matrices généralisées, MULT_FRONT n'est pas permis, LDLT est donc par défaut
   if BASE == 'GENE':
      _gene = True
      _ldlt = True

#  LDLT est le solveur par défaut dans DYNA_TRAN_MODAL (systèmes linéaires petits)
   if COMMAND == 'DYNA_TRAN_MODAL':
      _ldlt = True

# ----------------------------------------------------------------------------------------------------------------------------------

   _syme   = False

#  Seuls les opérateurs non-linéaires produisent des matrices non-symétriques
   if _type == 'NL':
      _syme = True
   if COMMAND == 'THER_NON_LINE_MO':
      _syme = True

# ----------------------------------------------------------------------------------------------------------------------------------

   _singu  = True
   _rcmk   = True
   _resol  = True
   _cmodal = False

#  Avec les solveurs modaux STOP_SINGULIER n'existe pas, de plus RCMK n'est pas disponible
   if COMMAND in ('INFO_MODE','MODE_ITER_INV','MODE_ITER_SIMULT'):
      _cmodal= True
      _singu = False
      _rcmk  = False
#     Dans INFO_MODE on ne fait que factoriser
      if COMMAND == 'INFO_MODE':
         _resol = False

# ----------------------------------------------------------------------------------------------------------------------------------

   _singu_non = False

#  Dans DEFI_BASE_MODALE, NON est le défaut de STOP_SINGULIER
   if COMMAND == 'DEFI_BASE_MODALE':
      _singu_non = True

# ----------------------------------------------------------------------------------------------------------------------------------
#
# INITIALISATIONS
#
# ----------------------------------------------------------------------------------------------------------------------------------

#  Mot-clés simples
   _MotCleSimples={}

#  Solveurs
   _BlocMF={}
   _BlocLD={}
   _BlocMU={}
   _BlocGC={}
   _BlocPE={}

#  Préconditionneurs
   _BlocGC_INC={}
   _BlocPE_INC={}
   _BlocXX_SP={}
   _BlocPE_ML={}
   _BlocPE_BOOMER={}
   _BlocXX_Autres={}

# ----------------------------------------------------------------------------------------------------------------------------------
#
# MOT-CLES SIMPLES : METHODE
#                    SYME
#
# ----------------------------------------------------------------------------------------------------------------------------------

#  METHODE
   if (_ldlt):
      _defaut = "LDLT"
   else:
      _defaut = "MULT_FRONT"

   if _type == 'SD':
      _into = ("MULT_FRONT", "LDLT", "MUMPS", )
      if _gene:
         _into = ("LDLT", "MUMPS", )
   else:
      _into = ("MULT_FRONT", "LDLT", "MUMPS", "GCPC", "PETSC", )

   if COMMAND =='MODE_NON_LINE':
      _defaut = "MUMPS"
      _into = ("MUMPS",)

   _MotCleSimples['METHODE'] = SIMP(statut='f', typ='TXM', defaut=_defaut, into=_into, )

# ----------------------------------------------------------------------------------------------------------------------------------

#  SYME
   if _syme:
      _MotCleSimples['SYME'] = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON", ), )

# ----------------------------------------------------------------------------------------------------------------------------------
#
# MULT_FRONT/LDLT/MUMPS (RENUM/NPREC/STOP_SINGULIER)
#
# ----------------------------------------------------------------------------------------------------------------------------------

#  RENUM
   _BlocMF['RENUM'] = SIMP(statut='f', typ='TXM', defaut="METIS", into=("MD", "MDA", "METIS", ), )

   if _rcmk:
      _into = ("RCMK", "SANS", )
      _defaut = "RCMK"
   else:
      _into = ("SANS",)
      _defaut = "SANS"

   _BlocLD['RENUM'] = SIMP(statut='f', typ='TXM', defaut=_defaut, into=_into, )

   _BlocMU['RENUM'] = SIMP(statut='f', typ='TXM', defaut="AUTO", into=("AMD", "AMF", "PORD", "METIS", "QAMD", "SCOTCH", "AUTO", ), )

# ----------------------------------------------------------------------------------------------------------------------------------
#  NPREC
   _BlocMF['NPREC'] = SIMP(statut='f', typ='I', defaut=8, )
   _BlocLD['NPREC'] = SIMP(statut='f', typ='I', defaut=8, )
   _BlocMU['NPREC'] = SIMP(statut='f', typ='I', defaut=8, )

# ----------------------------------------------------------------------------------------------------------------------------------
#  ELIM_LAGR

   if not _cmodal :
      _BlocPE['ELIM_LAGR'     ] = SIMP(statut='f', typ='TXM', defaut="NON" , into=("OUI", "NON"), )
      _BlocMF['ELIM_LAGR'     ] = SIMP(statut='f', typ='TXM', defaut="NON" , into=("OUI", "NON"), )
      _BlocLD['ELIM_LAGR'     ] = SIMP(statut='f', typ='TXM', defaut="NON" , into=("OUI", "NON"), )
      _BlocMU['ELIM_LAGR'     ] = SIMP(statut='f', typ='TXM', defaut="LAGR2" , into=("OUI", "NON", "LAGR2"), )
   else :
      _BlocMU['ELIM_LAGR'     ] = SIMP(statut='f', typ='TXM', defaut="LAGR2" , into=("NON", "LAGR2"), )


# ----------------------------------------------------------------------------------------------------------------------------------
#  STOP_SINGULIER
   _into = ("OUI", "NON", )
   _defaut = "OUI"

   if _singu_non:
      _defaut = "NON"

   if _singu:
      _BlocMF['STOP_SINGULIER'] = SIMP(statut='f', typ='TXM', defaut=_defaut, into=_into, )
      _BlocLD['STOP_SINGULIER'] = SIMP(statut='f', typ='TXM', defaut=_defaut, into=_into, )
      _BlocMU['STOP_SINGULIER'] = SIMP(statut='f', typ='TXM', defaut=_defaut, into=_into, )

# ----------------------------------------------------------------------------------------------------------------------------------
#
# MUMPS (MOT-CLES RESTANT)
#
# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocMU['TYPE_RESOL'     ] = SIMP(statut='f', typ='TXM', defaut="AUTO", into=("NONSYM", "SYMGEN", "SYMDEF", "AUTO", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocMU['PRETRAITEMENTS' ] = SIMP(statut='f', typ='TXM', defaut="AUTO", into=("SANS", "AUTO", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   if _resol:
      _BlocMU['POSTTRAITEMENTS'] = SIMP(statut='f', typ='TXM', defaut="AUTO", into=("SANS", "AUTO", "FORCE", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocMU['PCENT_PIVOT'    ] = SIMP(statut='f', typ='I'  , defaut=20, val_min=1, )

# ----------------------------------------------------------------------------------------------------------------------------------

   if _resol:
      if _type == 'LIN':
         _BlocMU['RESI_RELA'] = SIMP(statut='f', typ='R', defaut=1.0E-6, )
      else:
         _BlocMU['RESI_RELA'] = SIMP(statut='f', typ='R', defaut=-1.0, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocMU['GESTION_MEMOIRE'] = SIMP(statut='f', typ='TXM', defaut="AUTO", into=("IP_CORE", "OUT_OF_CORE", "AUTO", "EVAL"), )

# ----------------------------------------------------------------------------------------------------------------------------------

   if _type == 'NL':
      _BlocMU['FILTRAGE_MATRICE'] = SIMP(statut='f', typ='R'  , defaut=-1.0, )
      _BlocMU['MIXER_PRECISION' ] = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   if _dist:
      _BlocMU['MATR_DISTRIBUEE' ] = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON", ), )
      _BlocPE['MATR_DISTRIBUEE' ] = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON", ), )

# ----------------------------------------------------------------------------------------------------------------------------------
#
# GCPC/PETSC
#
# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocPE['ALGORITHME'] = SIMP(statut='f', typ='TXM', defaut="GMRES", into=("CG", "CR", "GMRES", "GCR", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocGC['PRE_COND'] = SIMP(statut='f', typ='TXM', defaut="LDLT_INC", into=("LDLT_INC", "LDLT_SP", ), )
   _BlocPE['PRE_COND'] = SIMP(statut='f', typ='TXM', defaut="LDLT_SP" ,
                              into=("LDLT_INC", "LDLT_SP", "JACOBI", "SOR", "ML", "BOOMER", "SANS", ), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocGC['RESI_RELA'] = SIMP(statut='f', typ='R', defaut= 1.E-6, )
   _BlocPE['RESI_RELA'] = SIMP(statut='f', typ='R', defaut= 1.E-6, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocGC['NMAX_ITER'] = SIMP(statut='f', typ='I', defaut= 0, )
   _BlocPE['NMAX_ITER'] = SIMP(statut='f', typ='I', defaut= 0, )

# ----------------------------------------------------------------------------------------------------------------------------------
#  Mot-cle cache pour desactiver le critere en norme non preconditionnee dans PETSC

   if _type == 'NL':
      _BlocPE['RESI_RELA_PC'] = SIMP(statut='c', typ='R', defaut= -1.0, )
   else:
      _BlocPE['RESI_RELA_PC'] = SIMP(statut='c', typ='R', defaut=  0.0, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocGC_INC['RENUM'] = SIMP(statut='f', typ='TXM', defaut="RCMK", into=("SANS","RCMK"), )
   _BlocPE_INC['RENUM'] = SIMP(statut='f', typ='TXM', defaut="RCMK", into=("SANS","RCMK"), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocGC_INC['NIVE_REMPLISSAGE'] = SIMP(statut='f', typ='I', defaut= 0, )
   _BlocPE_INC['NIVE_REMPLISSAGE'] = SIMP(statut='f', typ='I', defaut= 0, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocPE_INC['REMPLISSAGE'] = SIMP(statut='f', typ='R', defaut= 1.0, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocXX_SP['RENUM'] = SIMP(statut='f', typ='TXM', defaut="SANS", into=("SANS",), )
   _BlocXX_SP['REAC_PRECOND'] = SIMP(statut='f', typ='I', defaut=30, )
   _BlocXX_SP['PCENT_PIVOT' ] = SIMP(statut='f', typ='I', defaut=20, val_min=1, )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocPE_ML['RENUM'] = SIMP(statut='f', typ='TXM', defaut="SANS", into=("SANS",), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocPE_BOOMER['RENUM'] = SIMP(statut='f', typ='TXM', defaut="SANS", into=("SANS",), )

# ----------------------------------------------------------------------------------------------------------------------------------

   _BlocXX_Autres['RENUM'] = SIMP(statut='f', typ='TXM', defaut="SANS", into=("SANS","RCMK", ), )


# ----------------------------------------------------------------------------------------------------------------------------------
#
# PREPARATION DU MOT-CLE FACTEUR
#
# ----------------------------------------------------------------------------------------------------------------------------------

   mcfact = FACT(statut='d',
                 b_mult_front = BLOC(condition = "METHODE == 'MULT_FRONT' ",
                                     fr="Paramètres de la méthode multi frontale",
                                     **_BlocMF
                                     ),
                 b_ldlt       = BLOC(condition = "METHODE == 'LDLT' ",
                                     fr="Paramètres de la méthode LDLT",
                                     **_BlocLD
                                     ),
                 b_mumps      = BLOC(condition = "METHODE == 'MUMPS' ",
                                     fr="Paramètres de la méthode MUMPS",
                                     **_BlocMU
                                     ),
                 b_gcpc       = BLOC(condition = "METHODE == 'GCPC' ",
                                      fr="Paramètres de la méthode du gradient conjugué",
                                     b_ldltinc    = BLOC(condition = "PRE_COND == 'LDLT_INC' ",
                                                         fr="Paramètres de la factorisation incomplète",
                                                         **_BlocGC_INC
                                                         ),
                                     b_simple     = BLOC(condition = "PRE_COND == 'LDLT_SP' ",
                                                         fr="Paramètres de la factorisation simple précision",
                                                         **_BlocXX_SP
                                                         ),
                                     **_BlocGC
                                     ),
                 b_petsc      = BLOC(condition = "METHODE == 'PETSC' ",
                                     fr="Paramètres de la méthode PETSC",
                                     b_ldltinc    = BLOC(condition = "PRE_COND == 'LDLT_INC' ",
                                                         fr="Paramètres de la factorisation incomplète",
                                                         **_BlocPE_INC
                                                         ),
                                     b_simple     = BLOC(condition = "PRE_COND == 'LDLT_SP' ",
                                                         fr="Paramètres de la factorisation simple précision",
                                                         **_BlocXX_SP
                                                         ),
                                     b_ml         = BLOC(condition = "PRE_COND == 'ML' ",
                                                         fr="Paramètres du multigrille algébrique ML",
                                                         **_BlocPE_ML
                                                         ),
                                     b_boomer        = BLOC(condition = "PRE_COND == 'BOOMER' ",
                                                         fr="Paramètres du multigrille algébrique HYPRE",
                                                         **_BlocPE_BOOMER
                                                         ),
                                     b_autres     = BLOC(condition = "PRE_COND == 'JACOBI' or \
                                                                      PRE_COND == 'SOR'    or \
                                                                      PRE_COND == 'SANS'",
                                                         **_BlocXX_Autres
                                                         ),
                                     **_BlocPE
                                     ),
                 **_MotCleSimples
                 )

   return mcfact

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr

def C_SUIVI_DDL() : return FACT(statut='f',max=4,

           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
                                   into=("DEPL","VITE","ACCE",
                                         "FORC_NODA",
                                         "SIEF_ELGA","VARI_ELGA",)),

           EVAL_CHAM       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                   into=("MIN","MAX","MOY","MAXI_ABS","MINI_ABS","VALE",),),

           NOM_CMP         =SIMP(statut='o',typ='TXM',max=20),
           EVAL_CMP        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                   into=("VALE","FORMULE",),),

           b_formule       =BLOC(condition="(EVAL_CMP=='FORMULE')",
                                   FORMULE = SIMP(statut='o',typ=formule,max=1),
                                ),

           b_cham_no       =BLOC(condition="(NOM_CHAM=='DEPL') or \
                                            (NOM_CHAM=='VITE') or \
                                            (NOM_CHAM=='ACCE') or \
                                            (NOM_CHAM=='FORC_NODA') or \
                                            (NOM_CHAM=='VALE_CONT')",
                                 regles   =(UN_PARMI('NOEUD','GROUP_NO','GROUP_MA','MAILLE','TOUT')),
                                 TOUT            =SIMP(statut='d',typ='TXM',into=("OUI",) ),
                                 NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                                 GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                                 MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                                 GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                                ),

           b_cham_elga     =BLOC(condition="(NOM_CHAM=='SIEF_ELGA') or \
                                            (NOM_CHAM=='VARI_ELGA')",
                                 regles          =(UN_PARMI('GROUP_MA','MAILLE','TOUT')),
                                 TOUT            =SIMP(statut='d',typ='TXM',into=("OUI",) ),
                                 MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                 GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
                                 EVAL_ELGA       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,defaut='VALE',
                                                        into=("MIN","MAX","VALE",),),
                                 b_elga_vale     =BLOC(condition="(EVAL_ELGA=='VALE')",
                                   POINT           =SIMP(statut='o',typ='I'  ,validators=NoRepeat(),max='**'),
                                   SOUS_POINT      =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**'),
                                 ),
                                ),

           TITRE           =  SIMP(statut='f',typ='TXM',max=3),


       );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def C_TEST_REFERENCE(keyword, max=1):       #COMMUN#
    """Mots-clés communs pour TEST_RESU, TEST_TABLE, TEST_FONCTION.
    On retourne un bloc pour ajouter la règle UN_PARMI."""
    assert keyword in ('CHAM_NO', 'CHAM_ELEM', 'CARTE', 'RESU', 'GENE', 'OBJET',
                       'TABLE', 'FONCTION', 'FICHIER')
    with_int     = keyword not in ('FONCTION', 'FICHIER')
    with_complex = keyword not in ('OBJET', 'FICHIER')
    with_string  = keyword in ('FICHIER', 'TABLE')
    vale_abs     = keyword not in ('CARTE', 'FICHIER')
    type_test    = keyword not in ('CARTE', 'GENE', 'OBJET')
    multi_prec   = keyword in ('RESU', 'GENE')
    reference    = keyword not in ('FICHIER', )
    un_parmi     = keyword not in ('FICHIER', )

    opts = {}
    opts_ref = {}
    types = ['',]
    def add_type(typ):
        ttyp = typ == 'K' and 'TXM' or typ
        types.append('_' + typ)
        opts['VALE_CALC_' + typ] = SIMP(statut='f',typ=ttyp,max=max)
        opts_ref['VALE_REFE_' + typ] = SIMP(statut='f',typ=ttyp,max=max)
    if with_int:
        add_type('I')
    if with_complex:
        add_type('C')
    if with_string:
        add_type('K')
    if vale_abs:
        opts['VALE_ABS'] = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"))
    if type_test:
        opts['TYPE_TEST'] = SIMP(statut='f',typ='TXM',into=("SOMM_ABS","SOMM","MAX","MIN"))
    if not multi_prec:
        opts['TOLE_MACHINE'] = SIMP(statut='f',typ='R',defaut=1.e-6)
        opts['CRITERE']      = SIMP(statut='f',typ='TXM',defaut='RELATIF',into=("RELATIF","ABSOLU"))
    else:
        opts['TOLE_MACHINE'] = SIMP(statut='f',typ='R',max=2)
        opts['CRITERE']      = SIMP(statut='f',typ='TXM',max=2,into=("RELATIF","ABSOLU"))
    if un_parmi:
        opts['regles'] = (UN_PARMI(*['VALE_CALC' + t for t in types]))
        opts_ref['regles'] = (UN_PARMI(*['VALE_REFE' + t for t in types]))
    if reference:
        opts['b_reference'] = BLOC(condition = "REFERENCE != None",
            VALE_REFE   = SIMP(statut='f',typ='R',max=max),
            PRECISION   = SIMP(statut='f',typ='R',defaut=1.e-3),
            **opts_ref)
        opts['REFERENCE'] = SIMP(statut='f',typ='TXM',
                                 into=("ANALYTIQUE","SOURCE_EXTERNE","AUTRE_ASTER","NON_DEFINI"))
    kwargs = {
        'b_values' : BLOC(condition = "True",
            VALE_CALC    = SIMP(statut='f',typ='R',max=max),
            LEGENDE      = SIMP(statut='f',typ='TXM'),
            **opts
        )
    }
    return kwargs

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: gerald.nicolas at edf.fr
#
# ce fichier contient la liste des "into" possibles pour le mot cle TYPE_CHAM
def C_TYPE_CHAM_INTO( type_cham=None ) : #COMMUN#
# Si aucun argument n'est passe, on utilise tous les types de champs possibles
  if ( type_cham is None ) :
    l_cham = ["ELEM", "ELNO", "ELGA", "CART", "NOEU"]
# Sinon, on n'utilise que les types passes en argument
  else :
    l_cham = []
    for typ in type_cham :
      l_cham.append(typ)

  l = []
  for gd in C_NOM_GRANDEUR() :
    if gd != "VARI_R" :
       for typ in l_cham :
          l.append(typ+"_"+gd)
    else :
       # il ne peut pas exister NOEU_VARI_R ni CART_VARI_R (il faut utiliser VAR2_R):
       for typ in l_cham :
          if typ not in ("CART", "NOEU") :
             l.append(typ+"_"+gd)

  return tuple(l)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-luc.flejou at edf.fr
AFFE_CARA_ELEM=OPER(nom="AFFE_CARA_ELEM",op=  19,sd_prod=cara_elem,
   fr="Affectation de caracteristiques a des elements de structure",
   reentrant='n',
   UIinfo ={"groupes":("Modélisation",)},
   regles = (AU_MOINS_UN('POUTRE','BARRE','COQUE','CABLE','DISCRET','DISCRET_2D','MASSIF',
                         'GRILLE','MEMBRANE','MULTIFIBRE','RIGI_PARASOL'),
             PRESENT_PRESENT('MULTIFIBRE','GEOM_FIBRE'),
             EXCLUS('DISCRET','DISCRET_2D'),),
   MODELE = SIMP(statut='o',typ=modele_sdaster ),
   INFO   = SIMP(statut='f',typ='I', defaut= 1 ,into=(1,2) ),
   VERIF  = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("MAILLE","NOEUD") ),

#  ============================================================================
   POUTRE               = FACT(statut= 'f',max= '**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
      MAILLE               = SIMP(statut= 'f',typ= ma  ,validators= NoRepeat(),max= '**'),
      GROUP_MA             = SIMP(statut= 'f',typ= grma,validators= NoRepeat(),max= '**'),
      SECTION              = SIMP(statut= 'o',typ= 'TXM' ,into= ("GENERALE","RECTANGLE","CERCLE") ),
      b_generale           = BLOC(condition = " SECTION == 'GENERALE'",
         VARI_SECT            = SIMP(statut= 'f',typ= 'TXM',into= ("CONSTANT","HOMOTHETIQUE"),defaut= "CONSTANT"),
         b_constant           = BLOC(condition = "VARI_SECT == 'CONSTANT'",
                                     regles = (PRESENT_ABSENT('TABLE_CARA','CARA'),
                                     PRESENT_PRESENT('TABLE_CARA','NOM_SEC'),PRESENT_PRESENT('CARA','VALE')),
            TABLE_CARA           = SIMP(statut= 'f',typ=table_sdaster),
            NOM_SEC             = SIMP(statut= 'f',typ= 'TXM'),
            CARA                 = SIMP(statut= 'f',typ= 'TXM',validators= NoRepeat(),min= 4 ,max= 15,
                                       fr= "A,IY,IZ,JX sont des paramètres obligatoires",
                                       into= ("A","IY","IZ","AY","AZ","EY","EZ","JX","RY","RZ","RT",
                                             "JG","IYR2","IZR2","AI") ),
            VALE                    = SIMP(statut= 'f',typ= 'R',min= 4 ,max= 15), ),
         b_homothetique       = BLOC(condition = "VARI_SECT == 'HOMOTHETIQUE'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 8 ,max= 30,
                                       fr= "A1,A2,IY1,IY2,IZ1,IZ2,JX1,JX2 sont des paramètres obligatoires",
                                       into= ("A1","IY1","IZ1","AY1","AZ1","EY1","EZ1","JX1","RY1",
                                             "RZ1","RT1","JG1","IYR21","IZR21","AI1",
                                             "A2","IY2","IZ2","AY2","AZ2","EY2","EZ2","JX2","RY2",
                                             "RZ2","RT2","JG2","IYR22","IZR22","AI2") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 8 ,max= 30),),
      ),
      b_rectangle          = BLOC(condition = "SECTION == 'RECTANGLE'",
         VARI_SECT            = SIMP(statut= 'f',typ= 'TXM',into= ("CONSTANT","HOMOTHETIQUE","AFFINE"),defaut= "CONSTANT"),
         b_constant           = BLOC(condition = "VARI_SECT == 'CONSTANT'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 1 ,max= 4,
                                       into= ("H","EP", "HY","HZ","EPY","EPZ") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 1 ,max= 4), ),
         b_homothetique       = BLOC(condition = "VARI_SECT == 'HOMOTHETIQUE'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 2 ,max= 8,
                                       into= ("H1","HZ1","HY1","EP1","EPY1","EPZ1",
                                          "H2","HZ2","HY2","EP2","EPY2","EPZ2") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 2 ,max= 8), ),
         b_affine             = BLOC(condition = "VARI_SECT == 'AFFINE'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 3 ,max= 6,
                                       into= ("HY","EPY", "HZ1","EPZ1","HZ2","EPZ2") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 3 ,max= 6), ),
      ),
      b_cercle             = BLOC(condition = " SECTION == 'CERCLE'",
         VARI_SECT            = SIMP(statut= 'f',typ= 'TXM',into= ("CONSTANT","HOMOTHETIQUE"),defaut= "CONSTANT"),
         b_constant           = BLOC(condition = "VARI_SECT == 'CONSTANT'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 1 ,max= 2,
                                       fr= "R est un paramètre obligatoire",
                                       into= ("R","EP") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 1 ,max= 2), ),
         b_homothetique       = BLOC(condition = "VARI_SECT == 'HOMOTHETIQUE'",
            CARA                 = SIMP(statut= 'o',typ= 'TXM',validators= NoRepeat(),min= 2 ,max= 4,
                                       fr= "R1, R2 sont des paramètres obligatoires",
                                       into= ("R1","R2","EP1","EP2") ),
            VALE                 = SIMP(statut= 'o',typ= 'R',min= 2 ,max= 4), ),
         MODI_METRIQUE     = SIMP(statut= 'f',typ= 'TXM',defaut= "NON",into= ("OUI","NON") ),
         FCX               = SIMP(statut= 'f',typ= (fonction_sdaster,nappe_sdaster,formule) ),
         TUYAU_NSEC        = SIMP(statut= 'f',typ= 'I',val_max= 32,defaut= 16),
         TUYAU_NCOU        = SIMP(statut= 'f',typ= 'I',val_max= 10,defaut= 3),
      ),
   ),

#  ============================================================================
   BARRE                = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      SECTION              = SIMP(statut='o',typ='TXM',into=("GENERALE","RECTANGLE","CERCLE") ),
      b_generale           = BLOC(condition = "SECTION=='GENERALE'",
                                regles = (PRESENT_ABSENT('TABLE_CARA','CARA'),
                                PRESENT_PRESENT('TABLE_CARA','NOM_SEC'),PRESENT_PRESENT('CARA','VALE')),
         TABLE_CARA           = SIMP(statut= 'f',typ=table_sdaster),
         NOM_SEC              = SIMP(statut= 'f',typ= 'TXM'),
         CARA                 = SIMP(statut='f',typ='TXM',into=("A",) ),
         VALE                 = SIMP(statut='f',typ='R',min=1,max=1 ), ),
      b_rectangle          = BLOC(condition = "SECTION=='RECTANGLE'",
         CARA                 = SIMP(statut='o',typ='TXM',
                                    into=("H","EP","HZ","HY","EPY","EPZ"),
                                    validators=NoRepeat(),min=1,max=4 ),
         VALE                 = SIMP(statut='o',typ='R',min=1,max=4 ), ),
      b_cercle             =  BLOC(condition = "SECTION=='CERCLE'",
         CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=2,into=("R","EP") ),
         VALE                 = SIMP(statut='o',typ='R',min=1,max=2 ), ),
      FCX                  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
   ),

#  ============================================================================
   COQUE                = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA' ),
                              EXCLUS('ANGL_REP','VECTEUR'),
                              PRESENT_PRESENT( 'EXCENTREMENT',   'INER_ROTA' ),
                              PRESENT_PRESENT( 'EXCENTREMENT_FO','INER_ROTA' ),
                              UN_PARMI('EPAIS','EPAIS_FO' ),
                              EXCLUS('EXCENTREMENT','EXCENTREMENT_FO'),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      EPAIS                = SIMP(statut='f',typ='R' ),
      EPAIS_FO             = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
      ANGL_REP             = SIMP(statut='f',typ='R',min=2,max=2),
      VECTEUR              = SIMP(statut='f',typ='R',min=3,max=3),
      A_CIS                = SIMP(statut='f',typ='R',defaut= 0.8333333E0),
      COEF_RIGI_DRZ        = SIMP(statut='f',typ='R',defaut= 1.0E-5 ),
      COQUE_NCOU           = SIMP(statut='f',typ='I',defaut= 1 ),
      EXCENTREMENT         = SIMP(statut='f',typ='R' ),
      EXCENTREMENT_FO      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
      INER_ROTA            = SIMP(statut='f',typ='TXM',into=("OUI",) ),
      MODI_METRIQUE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
   ),

#  ============================================================================
   CABLE                = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      N_INIT               = SIMP(statut='f',typ='R',defaut= 5000. ),
      SECTION              = SIMP(statut='f',typ='R' ),
      FCX                  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
   ),

#  ============================================================================
   DISCRET              = FACT(statut='f',max='**',
      REPERE               = SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
      AMOR_HYST            = SIMP(statut='f',typ='R' ),

      SYME                 = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),),
      b_SYME_OUI           = BLOC(condition="SYME=='OUI'",
         fr="SYMETRIQUE: Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
         CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,defaut="None",
            into=("K_T_D_N", "K_T_D_L", "K_TR_D_N", "K_TR_D_L", "K_T_N", "K_T_L", "K_TR_N", "K_TR_L",
                  "M_T_D_N", "M_T_D_L", "M_TR_D_N", "M_TR_D_L", "M_T_N", "M_T_L", "M_TR_N", "M_TR_L",
                  "A_T_D_N", "A_T_D_L", "A_TR_D_N", "A_TR_D_L", "A_T_N", "A_T_L", "A_TR_N", "A_TR_L",),),
         #  Affection des caractéristiques de RIGIDITE/AMORTISSEMENT/MASSE
         b_AK_T_D_N            = BLOC(condition = "((CARA=='K_T_D_N')or(CARA=='A_T_D_N'))",
            fr="NOEUD: 3 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=3 ,max=3 ),),
         b_AK_T_D_L            = BLOC(condition = "((CARA=='K_T_D_L')or(CARA=='A_T_D_L'))",
            fr="SEGMENT: 3 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=3 ,max=3 ),),
         b_AK_TR_D_N           = BLOC(condition = "((CARA=='K_TR_D_N')or(CARA=='A_TR_D_N'))",
            fr="NOEUD: 6 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=6 ,max=6 ),),
         b_AK_TR_D_L           = BLOC(condition = "((CARA=='K_TR_D_L')or(CARA=='A_TR_D_L'))",
            fr="SEGMENT: 6 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=6 ,max=6 ),),
         b_MAK_T_N              = BLOC(condition = "((CARA=='K_T_N')or(CARA=='A_T_N')or(CARA=='M_T_N'))",
            fr="NOEUD: 6 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=6 ,max=6 ),),
         b_MAK_T_L              = BLOC(condition = "((CARA=='K_T_L')or(CARA=='A_T_L')or(CARA=='M_T_L'))",
            fr="SEGMENT: 21 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=21,max=21),),
         b_MAK_TR_N             = BLOC(condition = "((CARA=='K_TR_N')or(CARA=='A_TR_N')or(CARA=='M_TR_N'))",
            fr="NOEUD: 21 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=21,max=21),),
         b_MAK_TR_L             = BLOC(condition = "((CARA=='K_TR_L')or(CARA=='A_TR_L')or(CARA=='M_TR_L'))",
            fr="SEGMENT: 78 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=78,max=78),),
         #  Affection des caractéristiques de MASSE
         b_M_T_D_N           = BLOC(condition = "(CARA=='M_T_D_N')",
            fr="NOEUD: 1 valeur de masse",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=1 ,max=1 ),),
         b_M_T_D_L           = BLOC(condition = "(CARA=='M_T_D_L')",
            fr="SEGMENT: 1 valeur de masse",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=1 ,max=1 ),),
         b_M_TR_D_N           = BLOC(condition = "(CARA=='M_TR_D_N')",
            fr="NOEUD: 1 valeur de masse, 6 valeurs du tenseur d'inertie, 3 composantes du vecteur d'excentrement",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=10,max=10),),
         b_M_TR_D_L           = BLOC(condition = "(CARA=='M_TR_D_L')",
            fr="SEGMENT: 1 valeur de masse, 3 valeurs du tenseur d'inertie",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=4,max=4),),
      ),
      #     éléments à matrice non-symétrique
      #        b_MAK_T_N_NS       'K_T_N'     'A_T_N'    'M_T_N'
      #        b_MAK_T_L_NS       'K_T_L'     'A_T_L'    'M_T_L'
      #        b_MAK_TR_N_NS      'K_TR_N'    'A_TR_N'   'M_TR_N'
      #        b_MAK_TR_L_NS      'K_TR_L'    'A_TR_L'   'M_TR_L'
      b_SYME_NON           = BLOC(condition="SYME=='NON'",
         fr="NON-SYMETRIQUE: Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
         CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,defaut="None",
            into=("K_T_N", "K_T_L", "K_TR_N", "K_TR_L",
                  "M_T_N", "M_T_L", "M_TR_N", "M_TR_L",
                  "A_T_N", "A_T_L", "A_TR_N", "A_TR_L",),),
         #  Affection des caractéristiques de RIGIDITE/AMORTISSEMENT/MASSE : NON-SYMETRIQUE
         b_MAK_T_N_NS           = BLOC(condition = "((CARA=='K_T_N')or(CARA=='A_T_N')or(CARA=='M_T_N'))",
            fr="NOEUD: 9 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=9 ,max=9 ),),
         b_MAK_T_L_NS           = BLOC(condition = "((CARA=='K_T_L')or(CARA=='A_T_L')or(CARA=='M_T_L'))",
            fr="SEGMENT: 36 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=36,max=36),),
         b_MAK_TR_N_NS          = BLOC(condition = "((CARA=='K_TR_N')or(CARA=='A_TR_N')or(CARA=='M_TR_N'))",
            fr="NOEUD: 36 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=36,max=36),),
         b_MAK_TR_L_NS          = BLOC(condition = "((CARA=='K_TR_L')or(CARA=='A_TR_L')or(CARA=='M_TR_L'))",
            fr="SEGMENT: 144 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=144,max=144),),
      ),
   ),
#  ============================================================================
   DISCRET_2D           = FACT(statut='f',max='**',
      REPERE               = SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
      AMOR_HYST            = SIMP(statut='f',typ='R' ),
      SYME                 = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),),
      b_SYME_OUI           = BLOC(condition="SYME=='OUI'",
         fr="SYMETRIQUE: Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
         CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,defaut="None",
            into=("K_T_D_N", "K_T_D_L", "K_TR_D_N", "K_TR_D_L", "K_T_N", "K_T_L", "K_TR_N", "K_TR_L",
                  "M_T_D_N", "M_T_D_L", "M_TR_D_N", "M_TR_D_L", "M_T_N", "M_T_L", "M_TR_N", "M_TR_L",
                  "A_T_D_N", "A_T_D_L", "A_TR_D_N", "A_TR_D_L", "A_T_N", "A_T_L", "A_TR_N", "A_TR_L",),),
         #  Affection des caractéristiques de RIGIDITE/AMORTISSEMENT/MASSE
         b_AK_T_D_N            = BLOC(condition = "((CARA=='K_T_D_N')or(CARA=='A_T_D_N'))",
            fr="NOEUD: 2 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=2 ,max=2 ),),
         b_AK_T_D_L            = BLOC(condition = "((CARA=='K_T_D_L')or(CARA=='A_T_D_L'))",
            fr="SEGMENT: 2 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=2 ,max=2 ),),
         b_AK_TR_D_N           = BLOC(condition = "((CARA=='K_TR_D_N')or(CARA=='A_TR_D_N'))",
            fr="NOEUD: 3 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=3 ,max=3 ),),
         b_AK_TR_D_L           = BLOC(condition = "((CARA=='K_TR_D_L')or(CARA=='A_TR_D_L'))",
            fr="SEGMENT: 3 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=3 ,max=3 ),),
         b_MAK_T_N              = BLOC(condition = "((CARA=='K_T_N')or(CARA=='A_T_N')or(CARA=='M_T_N'))",
            fr="NOEUD: 3 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=3 ,max=3 ),),
         b_MAK_T_L              = BLOC(condition = "((CARA=='K_T_L')or(CARA=='A_T_L')or(CARA=='M_T_L'))",
            fr="SEGMENT: 10 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=10,max=10),),
         b_MAK_TR_N             = BLOC(condition = "((CARA=='K_TR_N')or(CARA=='A_TR_N')or(CARA=='M_TR_N'))",
            fr="NOEUD: 6 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
           NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=6 ,max=6),),
         b_MAK_TR_L             = BLOC(condition = "((CARA=='K_TR_L')or(CARA=='A_TR_L')or(CARA=='M_TR_L'))",
            fr="SEGMENT: 21 valeurs (triangulaire supérieure par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=21,max=21),),
         #  Affection des caractéristiques de MASSE
         b_M_T_D_N            = BLOC(condition = "(CARA=='M_T_D_N')",
            fr="NOEUD: 1 valeur de masse",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=1 ,max=1 ),),
         b_M_T_D_L            = BLOC(condition = "(CARA=='M_T_D_L')",
            fr="SEGMENT: 1 valeur de masse",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=1 ,max=1 ),),
         b_M_TR_D_N           = BLOC(condition = "(CARA=='M_TR_D_N')",
            fr="NOEUD: 1 valeur de masse, 1 valeur d'inertie, 2 composantes du vecteur d'excentrement",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=4 ,max=4 ),),
         b_M_TR_D_L           = BLOC(condition = "(CARA=='M_TR_D_L')",
            fr="SEGMENT: 1 valeur de masse, 1 valeur d'inertie",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=2 ,max=2 ),),
      ),
      #     éléments à matrice non-symétrique
      #        b_MAK_T_N_NS       'K_T_N'     'A_T_N'    'M_T_N'
      #        b_MAK_T_L_NS       'K_T_L'     'A_T_L'    'M_T_L'
      #        b_MAK_TR_N_NS      'K_TR_N'    'A_TR_N'   'M_TR_N'
      #        b_MAK_TR_L_NS      'K_TR_L'    'A_TR_L'   'M_TR_L'
      b_SYME_NON           = BLOC(condition="SYME=='NON'",
         fr="NON-SYMETRIQUE: Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
         CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,defaut="None",
            into=("K_T_N", "K_T_L", "K_TR_N", "K_TR_L",
                  "M_T_N", "M_T_L", "M_TR_N", "M_TR_L",
                  "A_T_N", "A_T_L", "A_TR_N", "A_TR_L",),),
         #  Affection des caractéristiques de RIGIDITE/AMORTISSEMENT/MASSE : NON-SYMETRIQUE
         b_MAK_T_N_NS           = BLOC(condition = "((CARA=='K_T_N')or(CARA=='A_T_N')or(CARA=='M_T_N'))",
            fr="NOEUD: 4 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=4 ,max=4 ),),
         b_MAK_T_L_NS           = BLOC(condition = "((CARA=='K_T_L')or(CARA=='A_T_L')or(CARA=='M_T_L'))",
            fr="SEGMENT: 16 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=16,max=16),),
         b_MAK_TR_N_NS          = BLOC(condition = "((CARA=='K_TR_N')or(CARA=='A_TR_N')or(CARA=='M_TR_N'))",
            fr="NOEUD: 9 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),),
            NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=9 ,max=9),),
         b_MAK_TR_L_NS          = BLOC(condition = "((CARA=='K_TR_L')or(CARA=='A_TR_L')or(CARA=='M_TR_L'))",
            fr="SEGMENT: 36 valeurs (matrice pleine par colonne)",
            regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
            MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            VALE                 = SIMP(statut='o',typ='R',min=36,max=36),),
      ),
   ),
#  ============================================================================
   ORIENTATION          = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO' ),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      NOEUD                = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
      GROUP_NO             = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
      CARA                 = SIMP(statut='o',typ='TXM',
                                 into=("VECT_Y","ANGL_VRIL","VECT_X_Y","ANGL_NAUT","GENE_TUYAU") ),
      VALE                 = SIMP(statut='o',typ='R',max='**'),
      PRECISION            = SIMP(statut='f',typ='R',defaut= 1.0E-4 ),
      CRITERE              = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
   ),

# ============================================================================
   DEFI_ARC             = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),
                              UN_PARMI('ORIE_ARC','CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE',
                                       'POIN_TANG','NOEUD_POIN_TANG','GROUP_NO_POIN_TG'),
                              PRESENT_PRESENT('ORIE_ARC','RAYON'),
                              EXCLUS('COEF_FLEX','COEF_FLEX_XY'),
                              EXCLUS('COEF_FLEX','COEF_FLEX_XZ'),
                              EXCLUS('INDI_SIGM','INDI_SIGM_XY'),
                              EXCLUS('INDI_SIGM','INDI_SIGM_XZ'),
                              PRESENT_PRESENT('COEF_FLEX_XY','COEF_FLEX_XZ'),
                              PRESENT_PRESENT('INDI_SIGM_XY','INDI_SIGM_XZ'),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      ORIE_ARC             = SIMP(statut='f',typ='R'),
      CENTRE               = SIMP(statut='f',typ='R',max='**'),
      NOEUD_CENTRE         = SIMP(statut='f',typ=no),
      GROUP_NO_CENTRE      = SIMP(statut='f',typ=grno),
      POIN_TANG            = SIMP(statut='f',typ='R',max='**'),
      NOEUD_POIN_TANG      = SIMP(statut='f',typ=no),
      GROUP_NO_POIN_TG     = SIMP(statut='f',typ=grno),
      RAYON                = SIMP(statut='f',typ='R'),
      COEF_FLEX            = SIMP(statut='f',typ='R'),
      INDI_SIGM            = SIMP(statut='f',typ='R'),
      COEF_FLEX_XY         = SIMP(statut='f',typ='R'),
      INDI_SIGM_XY         = SIMP(statut='f',typ='R'),
      COEF_FLEX_XZ         = SIMP(statut='f',typ='R'),
      INDI_SIGM_XZ         = SIMP(statut='f',typ='R'),
      PRECISION            = SIMP(statut='f',typ='R',defaut= 1.0E-3),
      CRITERE              = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
   ),

#============================================================================
   MASSIF               = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),
                              UN_PARMI('ANGL_REP','ANGL_AXE','ANGL_EULER'),
                              EXCLUS('ANGL_REP','ANGL_EULER'),
                              EXCLUS('ANGL_REP','ANGL_AXE'),
                              EXCLUS('ANGL_REP','ORIG_AXE'),
                              PRESENT_PRESENT('ANGL_AXE','ORIG_AXE'), ),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      ANGL_REP             = SIMP(statut='f',typ='R',max=3),
      ANGL_EULER           = SIMP(statut='f',typ='R',min=3,max=3),
      ANGL_AXE             = SIMP(statut='f',typ='R',max=2),
      ORIG_AXE             = SIMP(statut='f',typ='R',max=3),
   ),

#  ============================================================================
   POUTRE_FLUI          = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      B_T                  = SIMP(statut='o',typ='R'),
      B_N                  = SIMP(statut='o',typ='R'),
      B_TN                 = SIMP(statut='o',typ='R',defaut= 0.E+0 ),
      A_FLUI               = SIMP(statut='o',typ='R'),
      A_CELL               = SIMP(statut='o',typ='R'),
      COEF_ECHELLE         = SIMP(statut='o',typ='R'),
   ),

#  ============================================================================
   GRILLE               = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),
                              EXCLUS('ANGL_REP','AXE'),
                              UN_PARMI('SECTION','SECTION_FO' ),
                              EXCLUS('EXCENTREMENT','EXCENTREMENT_FO'), ),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      SECTION              = SIMP(statut='f',typ='R'),
      SECTION_FO           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
      ANGL_REP             = SIMP(statut='f',typ='R',max=2),
      EXCENTREMENT         = SIMP(statut='f',typ='R'),
      EXCENTREMENT_FO      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
      AXE                  = SIMP(statut='f',typ='R',max='**'),
      COEF_RIGI_DRZ        = SIMP(statut='f',typ='R',defaut= 1.0E-10 ),
   ),

#  ============================================================================
   MEMBRANE             = FACT(statut='f',max='**',
      regles               = (UN_PARMI('MAILLE','GROUP_MA'),
                              EXCLUS('ANGL_REP','AXE'),
                              ),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      ANGL_REP             = SIMP(statut='f',typ='R',max=2),
      AXE                  = SIMP(statut='f',typ='R',max='**'),
   ),

#============================================================================
   RIGI_PARASOL         = FACT(statut='f',max='**',
      regles               = (UN_PARMI('COEF_GROUP','FONC_GROUP'),
                              UN_PARMI('COOR_CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                              EXCLUS('GROUP_MA_POI1','GROUP_MA_SEG2'),),
      GROUP_MA             = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**',
         fr="Surface servant à répartir les caractéristiques des discrets"),
      GROUP_MA_POI1        = SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1,
         fr="Mailles de type point correspondant aux discrets"),
      GROUP_MA_SEG2        = SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1,
         fr="Mailles de type seg2 correspondant aux discrets"),
      FONC_GROUP           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
      COEF_GROUP           = SIMP(statut='f',typ='R',max='**'),
      REPERE               = SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
      CARA                 = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=2,
                                 into=("K_TR_D_N","K_T_D_N","K_TR_D_L","K_T_D_L",
                                       "A_TR_D_N","A_T_D_N","A_TR_D_L","A_T_D_L"),
                                 fr="Choix des types de discrets du tapis de ressorts." ),
      b_cara= BLOC(condition =""" au_moins_un(CARA, ["K_TR_D_N","K_T_D_N","K_TR_D_L","K_T_D_L",
                                            "A_TR_D_N","A_T_D_N","A_TR_D_L","A_T_D_L"]) or \
                                  (len(CARA)==2 and CARA[0][2:]==CARA[1][2:])""",
                   fr="Valeurs pour les discrets du tapis de ressorts.",
         VALE = SIMP(statut='o',typ='R',max='**',
              fr="Valeurs pour les discrets du tapis de ressorts.",),
      ),
      GROUP_NO_CENTRE      = SIMP(statut='f',typ=grno),
      NOEUD_CENTRE         = SIMP(statut='f',typ=no),
      COOR_CENTRE          = SIMP(statut='f',typ='R',min=2,max=3),
      EUROPLEXUS           = SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON"),
      UNITE                = SIMP(statut='f',typ='I',val_min=1),
   ),

#============================================================================
   RIGI_MISS_3D         = FACT(statut='f',max='**',
      GROUP_MA_POI1        = SIMP(statut='o',typ=grma,max=1),
      GROUP_MA_SEG2        = SIMP(statut='f',typ=grma,max=1),
      FREQ_EXTR            = SIMP(statut='o',typ='R',max=1),
      UNITE_RESU_IMPE      = SIMP(statut='f',typ='I',defaut=30),
   ),

#============================================================================
   MASS_AJOU            = FACT(statut='f',max='**',
      GROUP_MA             = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**',
         fr="Surface servant à répartir les caractéristiques des discrets"),
      GROUP_MA_POI1        = SIMP(statut='o',typ=grma,validators=NoRepeat(),max=1,
         fr="Mailles de type point correspondant aux discrets"),
      FONC_GROUP           = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
   ),

#============================================================================
   GEOM_FIBRE           = SIMP(statut='f',max=1,typ=gfibre_sdaster,
      fr="Donner le nom de la SD regroupant tous les groupes de fibres (issue de DEFI_GEOM_FIBRE)"),

   MULTIFIBRE           = FACT(statut='f',max='**',
      regles               = (AU_MOINS_UN('GROUP_MA','MAILLE'),),
      GROUP_MA             = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
      MAILLE               = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
      GROUP_FIBRE          = SIMP(statut='o',typ='TXM',max='**'),
      PREC_AIRE            = SIMP(statut= 'f',typ= 'R',defaut= 0.01),
      PREC_INERTIE         = SIMP(statut= 'f',typ= 'R',defaut= 0.1),
   ),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
#
AFFE_CHAR_ACOU=OPER(nom="AFFE_CHAR_ACOU",op=  68,sd_prod=char_acou,
                    fr="Affectation de charges et conditions aux limites acoustiques constantes",
                    reentrant='n',
            UIinfo={"groupes":("Chargements","Acoustique",)},
         regles=(AU_MOINS_UN('PRES_IMPO','VITE_FACE','IMPE_FACE','LIAISON_UNIF' ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         METHODE         =SIMP(statut='c',typ='TXM',fr="Stratégie de résolution pour les pressions imposées",
                               into=('DUALISATION',),defaut='DUALISATION',),
                               # METHODE='ELIMINATION' est traité dans le fortran mais dangereux actuellement
         PRES_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='o',typ='C' ),
         ),
         VITE_FACE       =FACT(statut='f',max='**',
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           VNOR            =SIMP(statut='o',typ='C' ),
         ),
         IMPE_FACE       =FACT(statut='f',max='**',
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           IMPE            =SIMP(statut='o',typ='C' ),
         ),
         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE' ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def affe_char_cine_prod(MECA_IMPO,THER_IMPO,ACOU_IMPO,EVOL_IMPO,**args):
  if MECA_IMPO != None  : return char_cine_meca
  if THER_IMPO != None  : return char_cine_ther
  if ACOU_IMPO != None  : return char_cine_acou
  if EVOL_IMPO != None  :
      if AsType(EVOL_IMPO) in (evol_elas,evol_noli) :
          return char_cine_meca
      elif AsType(EVOL_IMPO) in (evol_ther,) :
          return char_cine_ther
      else :
          raise AsException("Extension à faire ...")

  raise AsException("type de concept resultat non prevu")


AFFE_CHAR_CINE=OPER(nom="AFFE_CHAR_CINE",op= 101,sd_prod=affe_char_cine_prod
                    ,fr="Affectation de conditions aux limites cinématiques (U=U0) pour un traitement sans dualisation",
                     reentrant='n',
            UIinfo={"groupes":("Chargements","Mécanique",)},
         regles=(UN_PARMI('MECA_IMPO','THER_IMPO','ACOU_IMPO','EVOL_IMPO'),
                 ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),

         MECA_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                               'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                               'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                               'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                               'VO6','WI6','WO6','WO','WI1','WO1','GONF',
                               'H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                               'E3X','E3Y','E3Z','E4X','E4Y','E4Z','V11','V12','V13','V21','V22',
                               'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21',
                               'PRES22','PRES23','PRES31','PRES32','PRES33','LH1','GLIS'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
             UI2             =SIMP(statut='f',typ='R' ),
             UI3             =SIMP(statut='f',typ='R' ),
             UI4             =SIMP(statut='f',typ='R' ),
             UI5             =SIMP(statut='f',typ='R' ),
             UI6             =SIMP(statut='f',typ='R' ),
             UO2             =SIMP(statut='f',typ='R' ),
             UO3             =SIMP(statut='f',typ='R' ),
             UO4             =SIMP(statut='f',typ='R' ),
             UO5             =SIMP(statut='f',typ='R' ),
             UO6             =SIMP(statut='f',typ='R' ),
             VI2             =SIMP(statut='f',typ='R' ),
             VI3             =SIMP(statut='f',typ='R' ),
             VI4             =SIMP(statut='f',typ='R' ),
             VI5             =SIMP(statut='f',typ='R' ),
             VI6             =SIMP(statut='f',typ='R' ),
             VO2             =SIMP(statut='f',typ='R' ),
             VO3             =SIMP(statut='f',typ='R' ),
             VO4             =SIMP(statut='f',typ='R' ),
             VO5             =SIMP(statut='f',typ='R' ),
             VO6             =SIMP(statut='f',typ='R' ),
             WI2             =SIMP(statut='f',typ='R' ),
             WI3             =SIMP(statut='f',typ='R' ),
             WI4             =SIMP(statut='f',typ='R' ),
             WI5             =SIMP(statut='f',typ='R' ),
             WI6             =SIMP(statut='f',typ='R' ),
             WO2             =SIMP(statut='f',typ='R' ),
             WO3             =SIMP(statut='f',typ='R' ),
             WO4             =SIMP(statut='f',typ='R' ),
             WO5             =SIMP(statut='f',typ='R' ),
             WO6             =SIMP(statut='f',typ='R' ),
             WO              =SIMP(statut='f',typ='R' ),
             WI1             =SIMP(statut='f',typ='R' ),
             WO1             =SIMP(statut='f',typ='R' ),
             GONF            =SIMP(statut='f',typ='R' ),
             H1X             =SIMP(statut='f',typ='R' ),
             H1Y             =SIMP(statut='f',typ='R' ),
             H1Z             =SIMP(statut='f',typ='R' ),
             E1X             =SIMP(statut='f',typ='R' ),
             E1Y             =SIMP(statut='f',typ='R' ),
             E1Z             =SIMP(statut='f',typ='R' ),
             E2X             =SIMP(statut='f',typ='R' ),
             E2Y             =SIMP(statut='f',typ='R' ),
             E2Z             =SIMP(statut='f',typ='R' ),
             E3X             =SIMP(statut='f',typ='R' ),
             E3Y             =SIMP(statut='f',typ='R' ),
             E3Z             =SIMP(statut='f',typ='R' ),
             E4X             =SIMP(statut='f',typ='R' ),
             E4Y             =SIMP(statut='f',typ='R' ),
             E4Z             =SIMP(statut='f',typ='R' ),
             V11             =SIMP(statut='f',typ='R' ),
             V12             =SIMP(statut='f',typ='R' ),
             V13             =SIMP(statut='f',typ='R' ),
             V21             =SIMP(statut='f',typ='R' ),
             V22             =SIMP(statut='f',typ='R' ),
             V23             =SIMP(statut='f',typ='R' ),
             V31             =SIMP(statut='f',typ='R' ),
             V32             =SIMP(statut='f',typ='R' ),
             V33             =SIMP(statut='f',typ='R' ),
             PRES11          =SIMP(statut='f',typ='R' ),
             PRES12          =SIMP(statut='f',typ='R' ),
             PRES13          =SIMP(statut='f',typ='R' ),
             PRES21          =SIMP(statut='f',typ='R' ),
             PRES22          =SIMP(statut='f',typ='R' ),
             PRES23          =SIMP(statut='f',typ='R' ),
             PRES31          =SIMP(statut='f',typ='R' ),
             PRES32          =SIMP(statut='f',typ='R' ),
             PRES33          =SIMP(statut='f',typ='R' ),
             LH1             =SIMP(statut='f',typ='R' ),
             GLIS            =SIMP(statut='f',typ='R' ),
         ),

         THER_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_MIL','TEMP_INF','TEMP_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP            =SIMP(statut='f',typ='R' ),
           TEMP_MIL        =SIMP(statut='f',typ='R' ),
           TEMP_SUP        =SIMP(statut='f',typ='R' ),
           TEMP_INF        =SIMP(statut='f',typ='R' ),
         ),

         ACOU_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ='C' ),
         ),

         EVOL_IMPO  =SIMP(statut='f',typ=(evol_noli,evol_elas,evol_ther),fr="Pour imposer les ddls d'un evol_xxx"),
         b_evol_impo = BLOC ( condition = "EVOL_IMPO != None",
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**',), # pour n'imposer que certaines CMPS (par défaut : toutes)
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def affe_char_cine_f_prod(MECA_IMPO,THER_IMPO,**args):
  if MECA_IMPO != None  : return char_cine_meca
  if THER_IMPO != None  : return char_cine_ther
  raise AsException("type de concept resultat non prevu")

AFFE_CHAR_CINE_F=OPER(nom="AFFE_CHAR_CINE_F",op= 101,sd_prod=affe_char_cine_f_prod,
                      fr="Affectation de conditions aux limites cinématiques fonction d'un (ou plusieurs) paramètres"
                        +" pour un traitement sans dualisation",
                     reentrant='n',
            UIinfo={"groupes":("Chargements","Mécanique",)},
         regles=(UN_PARMI('MECA_IMPO','THER_IMPO')),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         MECA_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                               'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                               'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                               'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                               'VO6','WI6','WO6','WO','WI1','WO1','GONF',
                               'H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                               'E3X','E3Y','E3Z','E4X','E4Y','E4Z','V11','V12','V13','V21','V22',
                               'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21',
                               'PRES22','PRES23','PRES31','PRES32','PRES33','LH1','GLIS'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           DX    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE1  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE2  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UI2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UI3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UI4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UI5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UI6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UO2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UO3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UO4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UO5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           UO6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VI2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VI3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VI4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VI5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VI6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VO2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VO3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VO4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VO5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VO6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO3   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO4   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO5   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO6   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WI1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           WO1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GONF  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1X   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Y   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Z   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1X   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Y   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Z   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2X   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Y   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Z   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3X   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Y   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Z   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4X   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Y   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Z   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V11   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V12   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V13   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V21   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V22   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V23   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V31   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V32   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           V33   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES11=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES12=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES13=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES21=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES22=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES23=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES31=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES32=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES33=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           LH1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GLIS  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),

         ),
         THER_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_MIL','TEMP_INF','TEMP_SUP' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_MIL        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
AFFE_CHAR_MECA=OPER(nom="AFFE_CHAR_MECA",op=   7,sd_prod=char_meca,
                    fr="Affectation de charges et conditions aux limites mécaniques constantes",
                     reentrant='n',
            UIinfo={"groupes":("Chargements","Mécanique",)},
         regles=(AU_MOINS_UN('EVOL_CHAR','PESANTEUR','ROTATION','DDL_IMPO','DDL_POUTRE','FACE_IMPO',
                             'CHAMNO_IMPO','ARETE_IMPO',
                             'LIAISON_DDL','LIAISON_OBLIQUE','LIAISON_GROUP','LIAISON_MAIL',
                             'LIAISON_CYCL','LIAISON_SOLIDE','LIAISON_ELEM','LIAISON_UNIF',
                             'LIAISON_CHAMNO','LIAISON_RBE3','LIAISON_INTERF',
                             'VECT_ASSE',
                             'FORCE_NODALE','FORCE_FACE','FORCE_ARETE','FORCE_CONTOUR','FORCE_INTERNE',
                             'PRE_SIGM','PRES_REP','EFFE_FOND','PRE_EPSI','FORCE_POUTRE','FORCE_TUYAU',
                             'FORCE_COQUE','LIAISOP_COQUE','RELA_CINE_BP','FORCE_ELEC','INTE_ELEC',
                             'IMPE_FACE','VITE_FACE','ONDE_FLUI','FLUX_THM_REP','FORCE_SOL',),
                         ),
         VERI_NORM       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         EVOL_CHAR       =SIMP(statut='f',fr="Champ de pression issu d'un autre calcul",
                               typ=evol_char ),

         PESANTEUR       =FACT(statut='f',max=1,fr="Champ de pesanteur",
            GROUP_MA         =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE           =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GRAVITE          =SIMP(statut='o',typ='R',min=1,max=1),
            DIRECTION        =SIMP(statut='o',typ='R',min=3,max=3),),

         METHODE         =SIMP(statut='c',typ='TXM',fr="Stratégie de résolution pour les déplacements imposés",
                               into=('DUALISATION',),defaut='DUALISATION',),
                               # METHODE='ELIMINATION' est traité dans le fortran mais dangereux actuellement

         ROTATION        =FACT(statut='f', max=1, 
             fr="Définition d'un chargement de rotation",
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(), max='**'),
             MAILLE          =SIMP(statut='f',typ=ma, validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             VITESSE         =SIMP(statut='o', typ='R',min=1,max=1),
             AXE             =SIMP(statut='o', typ='R',min=2, max=3),
             CENTRE          =SIMP(statut='f',typ='R',min=2, max=3),
             b_rotation_tout=BLOC(condition="(GROUP_MA == None) and (MAILLE ==None)",
                       TOUT     = SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),),),

         DDL_IMPO        =FACT(statut='f',max='**',
             fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées)",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                 'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                 'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                 'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                 'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON',
                                 'H1X','H1Y','H1Z','H2X','H2Y','H2Z','H3X','H3Y','H3Z','H4X','H4Y','H4Z',
                                 'E1X','E1Y','E1Z','E2X','E2Y','E2Z','E3X','E3Y','E3Z','E4X','E4Y','E4Z',
                                 'LAGS_C','LAGS_F1','LAGS_F2','LAG2_C','LAG2_F1','LAG2_F2','LAG3_C','LAG3_F1',
                                 'V11','V12','V13','V21','V22','V23','V31','V32','V33',
                                 'PRES11','PRES12','PRES13','PRES21','PRES22','PRES23','PRES31','PRES32','PRES33','LH1','GLIS'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
             UI2             =SIMP(statut='f',typ='R' ),
             UI3             =SIMP(statut='f',typ='R' ),
             UI4             =SIMP(statut='f',typ='R' ),
             UI5             =SIMP(statut='f',typ='R' ),
             UI6             =SIMP(statut='f',typ='R' ),
             UO2             =SIMP(statut='f',typ='R' ),
             UO3             =SIMP(statut='f',typ='R' ),
             UO4             =SIMP(statut='f',typ='R' ),
             UO5             =SIMP(statut='f',typ='R' ),
             UO6             =SIMP(statut='f',typ='R' ),
             VI2             =SIMP(statut='f',typ='R' ),
             VI3             =SIMP(statut='f',typ='R' ),
             VI4             =SIMP(statut='f',typ='R' ),
             VI5             =SIMP(statut='f',typ='R' ),
             VI6             =SIMP(statut='f',typ='R' ),
             VO2             =SIMP(statut='f',typ='R' ),
             VO3             =SIMP(statut='f',typ='R' ),
             VO4             =SIMP(statut='f',typ='R' ),
             VO5             =SIMP(statut='f',typ='R' ),
             VO6             =SIMP(statut='f',typ='R' ),
             WI2             =SIMP(statut='f',typ='R' ),
             WI3             =SIMP(statut='f',typ='R' ),
             WI4             =SIMP(statut='f',typ='R' ),
             WI5             =SIMP(statut='f',typ='R' ),
             WI6             =SIMP(statut='f',typ='R' ),
             WO2             =SIMP(statut='f',typ='R' ),
             WO3             =SIMP(statut='f',typ='R' ),
             WO4             =SIMP(statut='f',typ='R' ),
             WO5             =SIMP(statut='f',typ='R' ),
             WO6             =SIMP(statut='f',typ='R' ),
             WO              =SIMP(statut='f',typ='R' ),
             WI1             =SIMP(statut='f',typ='R' ),
             WO1             =SIMP(statut='f',typ='R' ),
             GONF            =SIMP(statut='f',typ='R' ),
             H1X             =SIMP(statut='f',typ='R' ),
             H1Y             =SIMP(statut='f',typ='R' ),
             H1Z             =SIMP(statut='f',typ='R' ),
             H2X             =SIMP(statut='f',typ='R' ),
             H2Y             =SIMP(statut='f',typ='R' ),
             H2Z             =SIMP(statut='f',typ='R' ),
             H3X             =SIMP(statut='f',typ='R' ),
             H3Y             =SIMP(statut='f',typ='R' ),
             H3Z             =SIMP(statut='f',typ='R' ),
             H4X             =SIMP(statut='f',typ='R' ),
             H4Y             =SIMP(statut='f',typ='R' ),
             H4Z             =SIMP(statut='f',typ='R' ),
             E1X             =SIMP(statut='f',typ='R' ),
             E1Y             =SIMP(statut='f',typ='R' ),
             E1Z             =SIMP(statut='f',typ='R' ),
             E2X             =SIMP(statut='f',typ='R' ),
             E2Y             =SIMP(statut='f',typ='R' ),
             E2Z             =SIMP(statut='f',typ='R' ),
             E3X             =SIMP(statut='f',typ='R' ),
             E3Y             =SIMP(statut='f',typ='R' ),
             E3Z             =SIMP(statut='f',typ='R' ),
             E4X             =SIMP(statut='f',typ='R' ),
             E4Y             =SIMP(statut='f',typ='R' ),
             E4Z             =SIMP(statut='f',typ='R' ),
             LAGS_C          =SIMP(statut='f',typ='R' ),
             LAGS_F1         =SIMP(statut='f',typ='R' ),
             LAGS_F2         =SIMP(statut='f',typ='R' ),
             LAG2_C          =SIMP(statut='f',typ='R' ),
             LAG2_F1         =SIMP(statut='f',typ='R' ),
             LAG2_F2         =SIMP(statut='f',typ='R' ),
             LAG3_C          =SIMP(statut='f',typ='R' ),
             LAG3_F1         =SIMP(statut='f',typ='R' ),
             V11             =SIMP(statut='f',typ='R' ),
             V12             =SIMP(statut='f',typ='R' ),
             V13             =SIMP(statut='f',typ='R' ),
             V21             =SIMP(statut='f',typ='R' ),
             V22             =SIMP(statut='f',typ='R' ),
             V23             =SIMP(statut='f',typ='R' ),
             V31             =SIMP(statut='f',typ='R' ),
             V32             =SIMP(statut='f',typ='R' ),
             V33             =SIMP(statut='f',typ='R' ),
             PRES11          =SIMP(statut='f',typ='R' ),
             PRES12          =SIMP(statut='f',typ='R' ),
             PRES13          =SIMP(statut='f',typ='R' ),
             PRES21          =SIMP(statut='f',typ='R' ),
             PRES22          =SIMP(statut='f',typ='R' ),
             PRES23          =SIMP(statut='f',typ='R' ),
             PRES31          =SIMP(statut='f',typ='R' ),
             PRES32          =SIMP(statut='f',typ='R' ),
             PRES33          =SIMP(statut='f',typ='R' ),
             LH1             =SIMP(statut='f',typ='R' ),
             GLIS            =SIMP(statut='f',typ='R' ),
           ),



         DDL_POUTRE    =FACT(statut='f',max='**',
             fr="Bloque des DDLs dans un repère local d'une poutre",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ'),
                     UN_PARMI('VECT_Y','ANGL_VRIL'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),


             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
#  définition du repère local
             VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
             ANGL_VRIL       =SIMP(statut='f',typ='R',),
#  restriction sur les mailles servant à définir le repère local
             GROUP_MA_REPE   =SIMP(statut='f',typ=grma,),
             MAILLE_REPE     =SIMP(statut='f',typ=ma,),
                            ),



           FACE_IMPO       =FACT(statut='f',max='**',
             fr="Impose à tous les noeuds d'une face une ou plusieurs valeurs de déplacement (ou de certaines grandeurs associées)",
             regles=(UN_PARMI('GROUP_MA','MAILLE',),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                 'TEMP','PRE1','PRE2','DNOR','DTAN'),
                     EXCLUS('DNOR','DX'),
                     EXCLUS('DNOR','DY'),
                     EXCLUS('DNOR','DZ'),
                     EXCLUS('DNOR','DRX'),
                     EXCLUS('DNOR','DRY'),
                     EXCLUS('DNOR','DRZ'),
                     EXCLUS('DTAN','DX'),
                     EXCLUS('DTAN','DY'),
                     EXCLUS('DTAN','DZ'),
                     EXCLUS('DTAN','DRX'),
                     EXCLUS('DTAN','DRY'),
                     EXCLUS('DTAN','DRZ'),),
#  rajout d'un mot clé REPERE :/ LOCAL /GLOBAL
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             DNOR            =SIMP(statut='f',typ='R' ),
             DTAN            =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
           ),

         CHAMNO_IMPO  =FACT(statut='f',max='**',
             fr="Impose des DDLs aux valeurs d'un concept cham_no_sdaster",
#  type de cham_no_sdaster CO()
             CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster), #CO()
             COEF_MULT       =SIMP(statut='o',typ='R' ),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         ARETE_IMPO       =FACT(statut='f',max='**',
             fr="Impose à tous les noeuds d'une arete des elements 3D une ou plusieurs valeurs de déplacement",
             regles=(UN_PARMI('GROUP_MA','MAILLE',),
                     AU_MOINS_UN('DX','DY','DZ','DTAN','PRES','PHI','TEMP','PRE1','PRE2'),
                     EXCLUS('DTAN','DX'),
                     EXCLUS('DTAN','DY'),
                     EXCLUS('DTAN','DZ'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DTAN            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
           ),

           LIAISON_DDL     =FACT(statut='f',max='**',
             fr="Définit une relation linéaire entre des DDLs de deux ou plusieurs noeuds",
             regles=(UN_PARMI('GROUP_NO','NOEUD'),),
             GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
             NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
             DDL             =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT       =SIMP(statut='o',typ='R'  ,max='**'),
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
           ),

           LIAISON_OBLIQUE =FACT(statut='f',max='**',
             fr="Applique à des noeuds la meme valeur de déplacement définie composante par composante"
              +" dans un repère oblique quelconque",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             ANGL_NAUT       =SIMP(statut='o',typ='R',max=3),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
           ),

           LIAISON_GROUP   =FACT(statut='f',max='**',
             fr="Définit la meme relation linéaire entre certains DDLs de couples de noeuds",
             regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                     UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                     EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                     EXCLUS('GROUP_MA_1','NOEUD_2'),
                     EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                     EXCLUS('GROUP_NO_1','MAILLE_2'),
                     EXCLUS('MAILLE_1','GROUP_NO_2'),
                     EXCLUS('MAILLE_1','NOEUD_2'),
                     EXCLUS('NOEUD_1','GROUP_MA_2'),
                     EXCLUS('NOEUD_1','MAILLE_2'),
                     EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),

               GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
               GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
               GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
               GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

             SANS_NOEUD      =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
             DDL_1           =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT_1     =SIMP(statut='o',typ='R'  ,max='**'),
             DDL_2           =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT_2     =SIMP(statut='o',typ='R'  ,max='**'),
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
             SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             TRAN            =SIMP(statut='f',typ='R',max=3),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
             CENTRE          =SIMP(statut='f',typ='R',max=3),
           ),

           LIAISON_MAIL    =FACT(statut='f',max='**',
             fr="Définit des relations linéaires permettant de recoller deux bords d'une structure",
             regles=(AU_MOINS_UN('GROUP_MA_MAIT','MAILLE_MAIT'),
                     AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL','NOEUD_ESCL')),
              GROUP_MA_MAIT   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD_ESCL      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

              TYPE_RACCORD    =SIMP(statut='o',typ='TXM',defaut="MASSIF",into=("MASSIF","COQUE","COQUE_MASSIF","MASSIF_COQUE",)),

              b_MASSIF     =BLOC ( condition = "TYPE_RACCORD == 'MASSIF'",
                 regles=( PRESENT_PRESENT('DDL_MAIT','DDL_ESCL'),),
              TRAN            =SIMP(statut='f',typ='R',max=3 ),
              ANGL_NAUT       =SIMP(statut='f',typ='R',max=3 ),
              CENTRE          =SIMP(statut='f',typ='R',max=3 ),
              DDL_MAIT        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              DDL_ESCL        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              ),
              b_COQUE_MASSIF =BLOC ( condition = "TYPE_RACCORD == 'COQUE_MASSIF'",
                 EPAIS           =SIMP(statut='o',typ='R'),
                 CHAM_NORMALE    =SIMP(statut='o',typ=cham_no_sdaster),
              ),
              ELIM_MULT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

           LIAISON_CYCL    =FACT(statut='f',max='**',
             fr="Définit des relations linéaires permettant de recoller les bords de deux parties symétriquement cycliques",
             regles=(AU_MOINS_UN('GROUP_MA_MAIT1','MAILLE_MAIT1'),
                     AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL','NOEUD_ESCL'),
                     PRESENT_PRESENT('DDL_MAIT','DDL_ESCL'),
                     ),
              GROUP_MA_MAIT1   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT1     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_MAIT2   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT2     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD_ESCL     =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TRAN            =SIMP(statut='f',typ='R',max=3 ),
              ANGL_NAUT       =SIMP(statut='f',typ='R',max=3 ),
              CENTRE          =SIMP(statut='f',typ='R',max=3 ),
              COEF_MAIT1            =SIMP(statut='f',typ='R',max=1 ),
              COEF_MAIT2            =SIMP(statut='f',typ='R',max=1 ),
              COEF_ESCL            =SIMP(statut='f',typ='R',max=1 ),
              DDL_MAIT        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              DDL_ESCL        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
         ),


           LIAISON_SOLIDE  =FACT(statut='f',max='**',
             fr="Modélise une partie indéformable d'une structure."
              +" Le mot clé TRAN permettent d'imposer le déplacement de la partie indéformable.",
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),

             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

             TRAN            =SIMP(statut='f',typ='R',max=3 ),
             DIST_MIN        =SIMP(statut='f',typ='R'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         LIAISON_ELEM    =FACT(statut='f',max='**',
            fr="Modélise le raccord : d'une partie massive 3D avec une poutre ou avec un tuyau, d'une coque"
               +" avec une poutre ou avec un tuyau, d'une plaque avec une poutre",
            regles      =(UN_PARMI('GROUP_MA_1','MAILLE_1'), UN_PARMI('GROUP_NO_2','NOEUD_2'),),
            OPTION      =SIMP(statut='o',typ='TXM',into=("3D_TUYAU","3D_POU","2D_POU","COQ_POU","COQ_TUYAU","PLAQ_POUT_ORTH") ),

            GROUP_MA_1  =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE_1    =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            GROUP_NO_2  =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            NOEUD_2     =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

            b_plaq_pout_orth =BLOC( condition = "OPTION == 'PLAQ_POUT_ORTH'",
               VERIF_EXCENT   =SIMP(statut='o',typ='TXM',defaut="OUI",into=("OUI","NON") ),
            ),

            b_cara_pout =BLOC( condition = "OPTION == 'COQ_POU' or OPTION == '3D_TUYAU' or OPTION == 'COQ_TUYAU'",
               CARA_ELEM   =SIMP(statut='o',typ=(cara_elem) ),
               AXE_POUTRE  =SIMP(statut='o',typ='R',max=3),
            ),


            NUME_LAGR   =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
            ANGL_MAX    =SIMP(statut='f',typ='R',defaut= 1. ),

         ),

           LIAISON_UNIF    =FACT(statut='f',max='**',
             fr="Impose une meme valeur (inconnue) à des DDLs d'un ensemble de noeuds",
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),

             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

             DDL             =SIMP(statut='o',typ='TXM',max='**'),
           ),

         LIAISON_CHAMNO  =FACT(statut='f',max='**',
             fr="Définit une relation linéaire entre tous les DDLs présents dans un concept CHAM_NO",
#  type de cham_no_sdaster CO()
             CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster), #CO()
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         LIAISON_RBE3    =FACT(statut='f',max='**',
            fr="""Modélise des relations linéaires de type RBE3 entre
                les degrés de liberté d'un noeud maître et des noeuds esclaves.""",
            regles          =(UN_PARMI('GROUP_NO_MAIT','NOEUD_MAIT'), UN_PARMI('GROUP_NO_ESCL','NOEUD_ESCL'),),
            GROUP_NO_MAIT   =SIMP(statut='f',typ=grno,max=1),
            NOEUD_MAIT      =SIMP(statut='f',typ=no  ,max=1),
            DDL_MAIT        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=6,into=('DX','DY','DZ','DRX','DRY','DRZ')),
            GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            NOEUD_ESCL      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),min=1,max='**'),
            DDL_ESCL        =SIMP(statut='o',typ='TXM',min=1,max='**'),
            COEF_ESCL       =SIMP(statut='f',typ='R',min=1,max='**'),
            NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
         ),

         LIAISON_INTERF  =FACT(statut='f',max='**',
             fr="Définit une relation linéaire entre les DDLs d'interface à partir d'un MACRELEM",
             MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna),
             TYPE_LIAISON    =SIMP(statut='f',typ='TXM',defaut="RIGIDE",into=("RIGIDE","SOUPLE") ),
           ),

#         SIMP(statut='f',typ='TXM',defaut="NON" ),

         VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster ),
#
# FORCES
#
         FORCE_NODALE    =FACT(statut='f',fr="Applique à des noeuds des forces nodales",max='**',
           regles=(AU_MOINS_UN('GROUP_NO','NOEUD'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ' ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ='R' ),
           FY              =SIMP(statut='f',typ='R' ),
           FZ              =SIMP(statut='f',typ='R' ),
           MX              =SIMP(statut='f',typ='R' ),
           MY              =SIMP(statut='f',typ='R' ),
           MZ              =SIMP(statut='f',typ='R' ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
         ),

         FORCE_FACE      =FACT(statut='f',max='**',
             fr="Applique des forces surfaciques sur une face d'élément volumique",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_ARETE     =FACT(statut='f',max='**',
         fr="Applique des forces linéiques à une arete d'élément volumique ou de coque",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ' ),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
             MX              =SIMP(statut='f',typ='R' ),
             MY              =SIMP(statut='f',typ='R' ),
             MZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_CONTOUR   =FACT(statut='f',max='**',
             fr="Applique des forces linéiques au bord d'un domaine 2D ou AXIS ou AXIS_FOURIER",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
             MX              =SIMP(statut='f',typ='R' ),
             MY              =SIMP(statut='f',typ='R' ),
             MZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_INTERNE   =FACT(statut='f',max='**',
             fr="Applique des forces volumiques (2D ou 3D) à un domaine volumique",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ' ),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
           ),

         PRE_SIGM   =FACT(statut='f',max='**',
             fr="Applique des contraintes volumiques (2D ou 3D) à un domaine volumique",
             #INST            =SIMP(statut='f',typ='R' ),
             SIGM            =SIMP(statut='o',typ=(cham_elem,carte_sdaster)),
           ),

         PRES_REP        =FACT(statut='f',max='**',
             fr="Applique une pression à un domaine de milieu continu 2D ou 3D, ou à un domaine de coques et tuyaux",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','FISSURE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE','FISSURE'),
                     AU_MOINS_UN('PRES','CISA_2D' ),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FISSURE         =SIMP(statut='f',typ=fiss_xfem,min=1,max=100,),
             PRES            =SIMP(statut='f',typ='R' ),
             CISA_2D         =SIMP(statut='f',typ='R' ),
           ),

         EFFE_FOND       =FACT(statut='f',max='**',
           fr="Calcul l'effet de fond sur une branche de tuyauterie (modélisation 3D) soumise à une pression",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ='R' ),
         ),

         PRE_EPSI       =FACT(statut='f',max='**',
             fr="Applique un chargement de déformation initiale à un élément 2D, 3D ou de structure",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('EPXX','EPYY','EPZZ','EPXY','EPXZ','EPYZ','EPX',
                                 'KY','KZ','EXX','EYY','EXY','KXX','KYY','KXY'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             EPXX            =SIMP(statut='f',typ='R' ),
             EPYY            =SIMP(statut='f',typ='R' ),
             EPZZ            =SIMP(statut='f',typ='R' ),
             EPXY            =SIMP(statut='f',typ='R' ),
             EPXZ            =SIMP(statut='f',typ='R' ),
             EPYZ            =SIMP(statut='f',typ='R' ),
             EPX             =SIMP(statut='f',typ='R' ),
             KY              =SIMP(statut='f',typ='R' ),
             KZ              =SIMP(statut='f',typ='R' ),
             EXX             =SIMP(statut='f',typ='R' ),
             EYY             =SIMP(statut='f',typ='R' ),
             EXY             =SIMP(statut='f',typ='R' ),
             KXX             =SIMP(statut='f',typ='R' ),
             KYY             =SIMP(statut='f',typ='R' ),
             KXY             =SIMP(statut='f',typ='R' ),
           ),

        FORCE_POUTRE    =FACT(statut='f',max='**',
             fr="Applique des forces linéiques sur des éléments de type poutre",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     ),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE",) ),
#  rajour d'un mot clé REPERE :/ LOCAL /GLOBAL
               b_force = BLOC(condition = "TYPE_CHARGE == 'FORCE'",
                          regles=(
                    AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','N','VY','VZ','MT','MFY','MFZ'),
                   PRESENT_ABSENT('FX','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('FY','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('FZ','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MX','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MY','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MZ','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('N','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('VY','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('VZ','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MT','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MFY','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MFZ','FX','FY','FZ','MX','MY','MZ'),),
                    FX              =SIMP(statut='f',typ='R' ),
                    FY              =SIMP(statut='f',typ='R' ),
                    FZ              =SIMP(statut='f',typ='R' ),
                    MX              =SIMP(statut='f',typ='R' ),
                    MY              =SIMP(statut='f',typ='R' ),
                    MZ              =SIMP(statut='f',typ='R' ),
                    N               =SIMP(statut='f',typ='R' ),
                    VY              =SIMP(statut='f',typ='R' ),
                    VZ              =SIMP(statut='f',typ='R' ),
                    MT              =SIMP(statut='f',typ='R' ),
                    MFY             =SIMP(statut='f',typ='R' ),
                    MFZ             =SIMP(statut='f',typ='R' ),
                                  ),
           b_vent = BLOC(condition = "TYPE_CHARGE == 'VENT'",
                         regles=(
                    AU_MOINS_UN('FX','FY','FZ','N','VY','VZ',),
                   PRESENT_ABSENT('FX','N','VY','VZ',),
                     PRESENT_ABSENT('FY','N','VY','VZ',),
                     PRESENT_ABSENT('FZ','N','VY','VZ',),
                     PRESENT_ABSENT('N','FX','FY','FZ',),
                     PRESENT_ABSENT('VY','FX','FY','FZ',),
                     PRESENT_ABSENT('VZ','FX','FY','FZ',),),
                    FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    N               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                                  ),

           ),

         FORCE_TUYAU     =FACT(statut='f',max='**',
             fr="Applique une pression sur des éléments TUYAU",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='f',typ='R' ),
           ),

         FORCE_COQUE     =FACT(statut='f',max='**',
             fr="Applique des forces surfaciques sur des éléments de types coques",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FX','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FY','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MX','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MY','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('F1','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('F2','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('F3','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('MF1','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('MF2','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('PRES','FX','FY','FZ','MX','MY','MZ','F1','F2','F3','MF1','MF2'),),
#  rajour d'un mot clé REPERE :/ LOCAL /GLOBAL
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

               FX              =SIMP(statut='f',typ='R' ),
               FY              =SIMP(statut='f',typ='R' ),
               FZ              =SIMP(statut='f',typ='R' ),
               MX              =SIMP(statut='f',typ='R' ),
               MY              =SIMP(statut='f',typ='R' ),
               MZ              =SIMP(statut='f',typ='R' ),

               F1              =SIMP(statut='f',typ='R' ),
               F2              =SIMP(statut='f',typ='R' ),
               F3              =SIMP(statut='f',typ='R' ),
               MF1             =SIMP(statut='f',typ='R' ),
               MF2             =SIMP(statut='f',typ='R' ),

             PRES            =SIMP(statut='f',typ='R' ),
             PLAN            =SIMP(statut='f',typ='TXM',defaut="MAIL",into=("SUP","INF","MOY","MAIL",) ),
           ),

           LIAISOP_COQUE   =FACT(statut='f',max='**',
             fr="Permet de représenter le raccord entre des éléments de coques au moyen des relations linéaires",
             regles=(AU_MOINS_UN('GROUP_MA_1','MAILLE_1','GROUP_MA_2','MAILLE_2',
                               'GROUP_NO_1','NOEUD_1','GROUP_NO_2','NOEUD_2',),),
             GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA_1 =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE_1   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO_1 =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD_1    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA_2 =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE_2   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO_2 =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD_2    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         RELA_CINE_BP    =FACT(statut='f',max='**',
           fr="Etablir des relations cinématiques permettant de relier les noeuds cable aux noeuds du béton, et spécifier"
              +" la prise en compte des contraintes initiales dans les cables",
           CABLE_BP        =SIMP(statut='o',typ=cabl_precont ),
           SIGM_BPEL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           RELA_CINE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           DIST_MIN        =SIMP(statut='f',typ='R'),
         ),

         FORCE_ELEC      =FACT(statut='f',max='**',
             fr="Appliquer la force de LAPLACE agissant sur un conducteur principal, due à la présence d'un conducteur"
                 +" secondaire droit",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),

             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

             POSITION        =SIMP(statut='f',typ='TXM',fr="Direction prédéfinie",into=("PARA","INFI","FINI",) ),
             b_fxyz  =BLOC ( condition = "POSITION == None",
                  FX   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                  FY   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                  FZ   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                       ),

             b_para     =BLOC ( condition = "POSITION == 'PARA'",
               regles=(UN_PARMI('TRANS','DIST'),),
               TRANS           =SIMP(statut='f',typ='R',max=3),
               DIST            =SIMP(statut='f',typ='R' ),
               b_point2        =BLOC ( condition = "DIST != None",
                 POINT2           =SIMP(statut='o',typ='R',max=3),
               ),
             ),
             b_fini_infi     =BLOC ( condition = "(POSITION == 'FINI') or (POSITION == 'INFI')",
               POINT1          =SIMP(statut='o',typ='R',max=3),
               POINT2          =SIMP(statut='o',typ='R',max=3),
             ),
           ),




        INTE_ELEC       =FACT(statut='f',max='**',
             fr="Appliquer la force de LAPLACE agissant sur un conducteur principal, due à la présence d'un conducteur"
               +" secondaire non nécessairement droit",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('GROUP_MA_2','MAILLE_2','TRANS','SYME'),
                     EXCLUS('TRANS','SYME'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             TRANS           =SIMP(statut='f',typ='R' ,max='**'),
             SYME            =SIMP(statut='f',typ='R' ,max='**'),
           ),


         IMPE_FACE       =FACT(statut='f',fr="Applique une impédance acoustique à une face",max='**',
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE' ),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             IMPE            =SIMP(statut='o',typ='R' ),
           ),

         VITE_FACE       =FACT(statut='f',fr="Impose des vitesses normales à une face (phénomène ACOUSTIQUE), ",max='**',
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             VNOR            =SIMP(statut='o',typ='R' ),
           ),



         ONDE_FLUI       =FACT(statut='f',max='**',
             fr="Applique une amplitude de pression d'onde incidente sinusoidale arrivant normalement à une face",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='o',typ='R' ),
           ),

         FLUX_THM_REP    =FACT(statut='f',max='**',
             fr="Applique à un domaine de milieu continu 2D ou 3D un flux de chaleur et/ou un apport de masse fluide"
                 +" (flux hydraulique)",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FLUN','FLUN_HYDR1','FLUN_HYDR2'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FLUN            =SIMP(statut='f',typ='R' ),
             FLUN_HYDR1      =SIMP(statut='f',typ='R' ),
             FLUN_HYDR2      =SIMP(statut='f',typ='R' ),
           ),
         FORCE_SOL       =FACT(statut='f',max=1,
             fr="Définition des impédances et forces  de sol temporelles",
           regles=(UN_PARMI('GROUP_NO_INTERF','SUPER_MAILLE'),
                   AU_MOINS_UN('UNITE_RESU_MASS','UNITE_RESU_RIGI','UNITE_RESU_AMOR'),),
           GROUP_NO_INTERF =SIMP(statut='f',typ=grno,),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,),
           UNITE_RESU_MASS =SIMP(statut='f',typ='I', ),
           UNITE_RESU_RIGI =SIMP(statut='f',typ='I', ),
           UNITE_RESU_AMOR =SIMP(statut='f',typ='I', ),
           UNITE_RESU_FORC =SIMP(statut='f',typ='I', ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
AFFE_CHAR_MECA_C=OPER(nom="AFFE_CHAR_MECA_C",op=   7,sd_prod=char_meca,
                     fr="Affectation de charges et conditions aux limites mécaniques complexes",
                     reentrant='n',
            UIinfo={"groupes":("Chargements","Mécanique",)},
         regles=(AU_MOINS_UN('DDL_IMPO','FORCE_POUTRE','LIAISON_DDL', ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         METHODE         =SIMP(statut='c',typ='TXM',fr="Stratégie de résolution pour les déplacements imposés",
                               into=('DUALISATION',),defaut='DUALISATION',),
                               # METHODE='ELIMINATION' est traité dans le fortran mais dangereux actuellement
         DDL_IMPO        =FACT(statut='f',max='**',
           fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées)",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD',),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI','LIAISON','GLIS' ),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)),
           DX              =SIMP(statut='f',typ='C' ),
           DY              =SIMP(statut='f',typ='C' ),
           DZ              =SIMP(statut='f',typ='C' ),
           DRX             =SIMP(statut='f',typ='C' ),
           DRY             =SIMP(statut='f',typ='C' ),
           DRZ             =SIMP(statut='f',typ='C' ),
           GRX             =SIMP(statut='f',typ='C' ),
           PRES            =SIMP(statut='f',typ='C' ),
           PHI             =SIMP(statut='f',typ='C' ),
           GLIS            =SIMP(statut='f',typ='C' ),
         ),
         FORCE_POUTRE    =FACT(statut='f',max='**',
           fr="Applique des forces linéiques sur des éléments de type poutre",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','N','VY','VZ',),
                   PRESENT_ABSENT('FX','N','VY','VZ',),
                   PRESENT_ABSENT('FY','N','VY','VZ',),
                   PRESENT_ABSENT('FZ','N','VY','VZ',),
                   PRESENT_ABSENT('N','FX','FY','FZ',),
                   PRESENT_ABSENT('VY', 'FX','FY','FZ',),
                   PRESENT_ABSENT('VZ','FX','FY','FZ', ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE") ),
           FX              =SIMP(statut='f',typ='C' ),
           FY              =SIMP(statut='f',typ='C' ),
           FZ              =SIMP(statut='f',typ='C' ),
           N               =SIMP(statut='f',typ='C' ),
           VY              =SIMP(statut='f',typ='C' ),
           VZ              =SIMP(statut='f',typ='C' ),
         ),
         LIAISON_DDL     =FACT(statut='f',max='**',
           fr="Définit une relation linéaire entre les DDLs de deux ou plusieurs noeuds",
           regles=(UN_PARMI('GROUP_NO','NOEUD', ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT       =SIMP(statut='o',typ='R'  ,max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='C' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
AFFE_CHAR_MECA_F=OPER(nom="AFFE_CHAR_MECA_F",op=7,sd_prod=char_meca,
                      fr="Affectation de charges et conditions aux limites mécaniques fonction d'un (ou plusieurs) paramètres",
                      reentrant='n',
            UIinfo={"groupes":("Chargements","Mécanique",)},
        regles=(AU_MOINS_UN('DDL_IMPO','FACE_IMPO','LIAISON_DDL','FORCE_NODALE',
                            'FORCE_FACE','FORCE_ARETE','FORCE_CONTOUR','FORCE_INTERNE',
                            'PRES_REP','FORCE_POUTRE','VITE_FACE','IMPE_FACE','ONDE_PLANE',
                            'LIAISON_OBLIQUE','PRE_EPSI','LIAISON_GROUP','LIAISON_UNIF',
                            'LIAISON_SOLIDE','FORCE_COQUE','LIAISOP_COQUE','FORCE_TUYAU',
                            'EFFE_FOND','FLUX_THM_REP',),),
         VERI_NORM       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         METHODE         =SIMP(statut='c',typ='TXM',fr="Stratégie de résolution pour les déplacements imposés",
                               into=('DUALISATION',),defaut='DUALISATION',),
                               # METHODE='ELIMINATION' est traité dans le fortran mais dangereux actuellement

         DDL_IMPO        =FACT(statut='f',max='**',
           fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées) fournies"
               +" par l'intermédiaire d'un concept fonction ",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                               'TEMP','PRE1','PRE2','GONF','LIAISON','H1X',
                               'H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                               'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','GLIS'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)),
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE1            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE2            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GONF            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           LAGS_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GLIS            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FACE_IMPO       =FACT(statut='f',max='**',
           fr="Impose à tous les noeuds d'une face une ou plusieurs valeurs de déplacement (ou de certaines grandeurs associées)"
              +" fournies par l'intérmédiaire d'un concept fonction",
           regles=(UN_PARMI('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI','TEMP','PRE1','PRE2','DNOR','DTAN'),
                   EXCLUS('DNOR','DX'),
                   EXCLUS('DNOR','DY'),
                   EXCLUS('DNOR','DZ'),
                   EXCLUS('DNOR','DRX'),
                   EXCLUS('DNOR','DRY'),
                   EXCLUS('DNOR','DRZ'),
                   EXCLUS('DTAN','DX'),
                   EXCLUS('DTAN','DY'),
                   EXCLUS('DTAN','DZ'),
                   EXCLUS('DTAN','DRX'),
                   EXCLUS('DTAN','DRY'),
                   EXCLUS('DTAN','DRZ'),),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE1            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE2            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DNOR            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DTAN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_DDL     =FACT(statut='f',max='**',
           fr="Définit une relation linéaire entre des DDLs de deux ou plusieurs noeuds, les valeurs sont fournies par"
               +" l'intermediaire d'un concept de type fonction",
           regles=(UN_PARMI('GROUP_NO','NOEUD'),UN_PARMI('COEF_MULT','COEF_MULT_FONC'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT       =SIMP(statut='f',typ='R',max='**'),
           COEF_MULT_FONC  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_OBLIQUE =FACT(statut='f',max='**',
           fr="Applique à des noeuds la meme valeur de déplacement définie composante par composante dans un repère oblique"
              +" quelconque, les valeurs sont fournis par l'intermédiaire d'un concept fonction",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             ANGL_NAUT       =SIMP(statut='o',typ='R',max=3),
             DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_GROUP   =FACT(statut='f',max='**',
           fr="Définit la meme relation linéaire entre certains DDLs de couples de noeuds, les valeurs sont fournies par"
               +" l'intermédiaire de concept fonction",
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                   EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                   EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                   EXCLUS('GROUP_NO_1','MAILLE_2'),
                   EXCLUS('MAILLE_1','GROUP_NO_2'),
                   EXCLUS('MAILLE_1','NOEUD_2'),
                   EXCLUS('NOEUD_1','GROUP_MA_2'),
                   EXCLUS('NOEUD_1','MAILLE_2'),
                   EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           CENTRE          =SIMP(statut='f',typ='R',max=3),
         ),

          LIAISON_UNIF    =FACT(statut='f',max='**',
           fr="Impose une meme valeur (inconnue) à des DDLs d'un ensemble de noeuds",
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DDL             =SIMP(statut='o',typ='TXM',max='**'),
         ),


         LIAISON_SOLIDE  =FACT(statut='f',max='**',
             fr="Modélise une partie indéformable d'une structure."
              +" Le mot clé TRAN permettent d'imposer le déplacement de la partie indéformable.",
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),

             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

             TRAN            =SIMP(statut='f',typ='R',max=3 ),
             DIST_MIN        =SIMP(statut='f',typ='R'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
         ),



         FORCE_NODALE    =FACT(statut='f',max='**',
           fr="Applique à des noeuds des forces nodales dont les valeurs des composantes sont fournies par l'intermédiaire"
               +" d'un concept fonction",
           regles=(UN_PARMI('GROUP_NO','NOEUD'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           ANGL_NAUT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max=3 ),
         ),

         FORCE_FACE      =FACT(statut='f',max='**',
           fr="Applique des forces surfaciques sur une face d'élément volumique dont les valeurs des composantes sont fournies"
               +" par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         FORCE_ARETE     =FACT(statut='f',max='**',
           fr="Applique des forces linéiques à une arete d'élément volumique ou de coque dont les valeurs des composantes sont"
               +" fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         FORCE_CONTOUR   =FACT(statut='f',max='**',
           fr="Applique des forces linéiques au bord d'un domaine 2D ou AXIS ou AXIS_FOURIER, dont les valeurs des composantes"
               +" sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FORCE_INTERNE   =FACT(statut='f',max='**',
           fr="Applique des forces volumiques (2D ou 3D) à un domaine volumique, dont les valeurs des composantes sont fournies"
               +" par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         PRES_REP        =FACT(statut='f',max='**',
           fr="Applique une pression à un domaine de milieu continu 2D ou 3D ou à un domaine de coques et tuyaux, dont les"
               +" valeurs imposées (pression et/ou cisaillement) sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','FISSURE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE','FISSURE'),
                   AU_MOINS_UN('PRES','CISA_2D'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,min=1,max=100,),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           CISA_2D         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         EFFE_FOND       =FACT(statut='f',max='**',
           fr="Calcul l'effet de fond sur une branche de tuyauterie (modélisation 3D) soumise"
               +" à une pression dont la valeur est fournie par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         PRE_EPSI       =FACT(statut='f',max='**',
           fr="Applique un chargement de déformation initiale à un élément 2D, 3D ou de structure dont les composantes"
               +" du tenseur de déformation sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('EPXX','EPYY','EPZZ','EPXY','EPXZ','EPYZ'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           EPXX            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPZZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FORCE_POUTRE    =FACT(statut='f',max='**',
           fr="Applique des forces linéiques sur des éléments de type poutre dont les valeurs sont fournies par"
               +" l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),

                     ),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE") ),
           # moment interdit avec VENT
           b_force = BLOC(condition = "TYPE_CHARGE == 'FORCE'",
                          regles=(
                    AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','N','VY','VZ','MT','MFY','MFZ'),
                   PRESENT_ABSENT('FX','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('FY','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('FZ','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MX','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MY','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('MZ','N','VY','VZ','MT','MFY','MFZ'),
                     PRESENT_ABSENT('N','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('VY','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('VZ','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MT','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MFY','FX','FY','FZ','MX','MY','MZ'),
                     PRESENT_ABSENT('MFZ','FX','FY','FZ','MX','MY','MZ'),),
                    FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    N               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MT              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MFY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    MFZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                                  ),
           b_vent = BLOC(condition = "TYPE_CHARGE == 'VENT'",
                         regles=(
                    AU_MOINS_UN('FX','FY','FZ','N','VY','VZ',),
                   PRESENT_ABSENT('FX','N','VY','VZ',),
                     PRESENT_ABSENT('FY','N','VY','VZ',),
                     PRESENT_ABSENT('FZ','N','VY','VZ',),
                     PRESENT_ABSENT('N','FX','FY','FZ',),
                     PRESENT_ABSENT('VY','FX','FY','FZ',),
                     PRESENT_ABSENT('VZ','FX','FY','FZ',),),
                    FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    N               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                    VZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                                  ),
         ),

         FORCE_TUYAU     =FACT(statut='f',max='**',
           fr="Applique une pression sur des éléments TUYAU, la valeur est fournie par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FORCE_COQUE     =FACT(statut='f',max='**',
           fr="Applique des forces surfaciques sur des éléments de types coques dont les valeurs sont fournies par"
               +" l'intermédiaires d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FX','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FY','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MX','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MY','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('F1','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('F2','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('F3','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('MF1','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('MF2','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('PRES','FX','FY','FZ','MX','MY','MZ','F1','F2','F3','MF1','MF2'),),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F1              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F2              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F3              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MF1             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MF2             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PLAN            =SIMP(statut='f',typ='TXM',defaut="MAIL",
                                 into=("SUP","INF","MOY","MAIL") ),
         ),

         LIAISOP_COQUE   =FACT(statut='f',max='**',
             fr="Permet de représenter le raccord entre des éléments de coques au moyen des relations linéaires",
             regles=(AU_MOINS_UN('GROUP_MA_1','MAILLE_1','GROUP_MA_2','MAILLE_2',
                                 'GROUP_NO_1','NOEUD_1','GROUP_NO_2','NOEUD_2',),),
             GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA_1 =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE_1   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO_1 =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD_1    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA_2 =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE_2   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO_2 =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD_2    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES",) ),
         ),


         VITE_FACE       =FACT(statut='f',max='**',
           fr="Impose des vitesses normales à une face (phénomène ACOUSTIQUE) dont les valeurs sont fournies par"
               +" l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           VNOR            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         IMPE_FACE       =FACT(statut='f',max='**',
           fr="Applique à une face une impédance acoustique dont la valeur est fournie par l'intermédiaire"
               +" d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           IMPE            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         ONDE_PLANE      =FACT(statut='f',max=1,
           fr="Impose un chargement sismique par onde plane dont la valeur est fournie par l'intermédiaire"
               +" d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('GROUP_MA','MAILLE'),),
           DIRECTION       =SIMP(statut='o',typ='R',min=3, max=3),
           TYPE_ONDE       =SIMP(statut='o',typ='TXM', into=("S", "P", "SV", "SH",) ),
           FONC_SIGNAL     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),



         FLUX_THM_REP    =FACT(statut='f',max='**',
           fr="Applique à un domaine continue 2D ou 3D un flux de chaleur et/ou un apport de masse fluide (flux hydraulique)"
               +" dont les valeurs des flux sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUN','FLUN_HYDR1','FLUN_HYDR2'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_HYDR1      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_HYDR2      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
AFFE_CHAR_THER=OPER(nom="AFFE_CHAR_THER",op=34,sd_prod=char_ther
                    ,fr="Affectation de charges et conditions aux limites thermiques constantes",
                    reentrant='n',
            UIinfo={"groupes":("Chargements","Thermique",)},
      regles=(AU_MOINS_UN('TEMP_IMPO','SOURCE','FLUX_REP','ECHANGE',
                          'ECHANGE_PAROI','PRE_GRAD_TEMP','LIAISON_DDL','LIAISON_GROUP',
                          'LIAISON_UNIF','LIAISON_CHAMNO','RAYONNEMENT','LIAISON_MAIL' ),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         METHODE         =SIMP(statut='c',typ='TXM',fr="Stratégie de résolution pour les températures imposées",
                               into=('DUALISATION',),defaut='DUALISATION',),
                               # METHODE='ELIMINATION' est traité dans le fortran mais dangereux actuellement

         TEMP_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_MIL','TEMP_SUP','TEMP_INF'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP            =SIMP(statut='f',typ='R'),
           TEMP_MIL        =SIMP(statut='f',typ='R'),
           TEMP_INF        =SIMP(statut='f',typ='R'),
           TEMP_SUP        =SIMP(statut='f',typ='R'), ),

         FLUX_REP        =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_PRESENT('CARA_TORSION','GROUP_MA'),
                   AU_MOINS_UN('FLUN','FLUN_INF','FLUN_SUP','CARA_TORSION') ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ='R'),
           FLUN_INF        =SIMP(statut='f',typ='R'),
           FLUN_SUP        =SIMP(statut='f',typ='R'),
           CARA_TORSION    =SIMP(statut='f',typ=table_sdaster),
         ),


         RAYONNEMENT     =FACT(statut='f',max='**',
           fr="Attention, exprimer les températures en Celsius si rayonnement",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SIGMA           =SIMP(statut='o',typ='R'),
           EPSILON         =SIMP(statut='o',typ='R'),
           TEMP_EXT        =SIMP(statut='o',typ='R'),
         ),

         ECHANGE         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('COEF_H','COEF_H_INF','COEF_H_SUP'),
                   ENSEMBLE('COEF_H','TEMP_EXT',),
                   ENSEMBLE('COEF_H_INF','TEMP_EXT_INF'),
                             ENSEMBLE('COEF_H_SUP','TEMP_EXT_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='f',typ='R'),
           TEMP_EXT        =SIMP(statut='f',typ='R'),
           COEF_H_INF      =SIMP(statut='f',typ='R'),
           TEMP_EXT_INF    =SIMP(statut='f',typ='R'),
           COEF_H_SUP      =SIMP(statut='f',typ='R'),
           TEMP_EXT_SUP    =SIMP(statut='f',typ='R'),
         ),

         SOURCE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('SOUR','SOUR_CALCULEE',),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('SOUR_CALCULEE','TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SOUR            =SIMP(statut='f',typ='R'),
           SOUR_CALCULEE   =SIMP(statut='f',typ=(cham_elem) ),
         ),

         PRE_GRAD_TEMP  =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUX_X          =SIMP(statut='f',typ='R' ),
           FLUX_Y          =SIMP(statut='f',typ='R' ),
           FLUX_Z          =SIMP(statut='f',typ='R' ),
                         ),

         LIAISON_DDL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD', ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
           COEF_MULT       =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
         ),

         LIAISON_GROUP   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                             EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                             EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                             EXCLUS('GROUP_NO_1','MAILLE_2'),
                             EXCLUS('MAILLE_1','GROUP_NO_2'),
                             EXCLUS('MAILLE_1','NOEUD_2'),
                             EXCLUS('NOEUD_1','GROUP_MA_2'),
                             EXCLUS('NOEUD_1','MAILLE_2'),
                             EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP",) ),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max='**'),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**'),
           CENTRE          =SIMP(statut='f',typ='R',max='**'),
         ),

         LIAISON_MAIL    =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('GROUP_MA_MAIT','MAILLE_MAIT'),
                   AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL',
                               'NOEUD_ESCL'),),
           GROUP_MA_MAIT   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_ESCL      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TRAN            =SIMP(statut='f',typ='R',max='**' ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**' ),
           CENTRE          =SIMP(statut='f',typ='R',max='**' ),
           ELIM_MULT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         ECHANGE_PAROI   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','FISSURE'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','FISSURE'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,validators=NoRepeat(),min=1,max=100,),
#          ----------------------
           b_paroi_maillee =BLOC(
             condition = "FISSURE == None",
             COEF_H        =SIMP(statut='o',typ='R'),
             TRAN          =SIMP(statut='f',typ='R',min=2,max=3),
                                 ),
#          ----------------------
           b_xfem         =BLOC(
             condition = "FISSURE != None",
             regles    =(UN_PARMI('COEF_H','TEMP_CONTINUE'),),
             COEF_H        =SIMP(statut='f',typ='R'),
             TEMP_CONTINUE =SIMP(statut='f',typ='TXM',into=("OUI",)),
                                 ),
         ),

         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
         ),

         LIAISON_CHAMNO  =FACT(statut='f',max='**',
           CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),# CO()# "il faut definir une structure de donnee generique chamno"
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
           NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
         ),

         CONVECTION      =FACT(statut='f',max='**',
           VITESSE         =SIMP(statut='o',typ=(cham_no_sdaster) ),
         ),


         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
AFFE_CHAR_THER_F=OPER(nom="AFFE_CHAR_THER_F",op=34,sd_prod=char_ther,
                     fr="Affectation de charges et conditions aux limites thermiques fonction d'un (ou plusieurs)"
                         +" paramètres (temps, ...)",
                     reentrant='n',
            UIinfo={"groupes":("Chargements","Thermique",)},
      regles=(AU_MOINS_UN('TEMP_IMPO','SOURCE','SOUR_NL','FLUX_REP','FLUX_NL','ECHANGE',
                           'ECHANGE_PAROI','LIAISON_DDL','LIAISON_GROUP','LIAISON_UNIF',
                          'PRE_GRAD_TEMP','RAYONNEMENT'),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),

         TEMP_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_MIL','TEMP_SUP','TEMP_INF'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_MIL        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FLUX_REP        =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUN','FLUN_INF','FLUN_SUP','FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_X          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Y          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Z          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FLUX_NL         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),


         RAYONNEMENT     =FACT(statut='f',max='**',
           fr="Attention, exprimer les températures en Celsius si rayonnement",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SIGMA           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPSILON         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),



         ECHANGE         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('COEF_H','COEF_H_INF','COEF_H_SUP'),
                   ENSEMBLE('COEF_H','TEMP_EXT'),
                   ENSEMBLE('COEF_H_INF','TEMP_EXT_INF'),
                   ENSEMBLE('COEF_H_SUP','TEMP_EXT_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_H_INF      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT_INF    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_H_SUP      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT_SUP    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),


         SOURCE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SOUR            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         SOUR_NL          =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SOUR            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         PRE_GRAD_TEMP  =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUX_X          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Y          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Z          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         ECHANGE_PAROI   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','FISSURE'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','FISSURE'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,validators=NoRepeat(),min=1,max=100,),
#          ----------------------
           b_paroi_maillee =BLOC(
             condition = "FISSURE == None",
             COEF_H        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             TRAN          =SIMP(statut='f',typ='R',min=2,max=3),
                                 ),
#          ----------------------
           b_xfem         =BLOC(
             condition = "FISSURE != None",
             regles    =(UN_PARMI('COEF_H','TEMP_CONTINUE'),),
             COEF_H        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             TEMP_CONTINUE =SIMP(statut='f',typ='TXM',into=("OUI",)),
                                 ),
         ),

        LIAISON_DDL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
           COEF_MULT       =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_GROUP   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                             EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                        EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                        EXCLUS('GROUP_NO_1','MAILLE_2'),
                        EXCLUS('MAILLE_1','GROUP_NO_2'),
                        EXCLUS('MAILLE_1','NOEUD_2'),
                        EXCLUS('NOEUD_1','GROUP_MA_2'),
                        EXCLUS('NOEUD_1','MAILLE_2'),
                        EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max='**'),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**'),
           CENTRE          =SIMP(statut='f',typ='R',max='**'),
         ),

         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='f',typ='TXM',defaut="TEMP",
                                 into=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP") ),
         ),

         CONVECTION      =FACT(statut='f',max='**',
           VITESSE         =SIMP(statut='o',typ=cham_no_sdaster ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
AFFE_MATERIAU=OPER(nom="AFFE_MATERIAU",op=6,sd_prod=cham_mater,
                   fr="Affecter des matériaux à des zones géométriques d'un maillage",
                         reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),

         #  affectation du nom du matériau (par mailles):
         #  ----------------------------------------------
         AFFE            =FACT(statut='o',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           MATER           =SIMP(statut='o',typ=mater_sdaster,max=30),
         ),

         #  affectation de comportement (multifibres pour l'instant):
         #  ----------------------------------------------
         AFFE_COMPOR        =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COMPOR          =SIMP(statut='o',typ=compor_sdaster,max=1),
         ),

         #  affectation des variables de commande :
         #  --------------------------------------------------
         # un mot clé caché qui ne sert qu'à boucler sur les VARC possibles :
         LIST_NOM_VARC =SIMP(statut='c',typ='TXM', defaut=("TEMP","GEOM","CORR","IRRA","HYDR","SECH","EPSA",
                                                           "M_ACIER","M_ZIRC","NEUT1","NEUT2","PTOT","DIVU",)),

         AFFE_VARC    =FACT(statut='f',max='**',
          regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                  PRESENT_ABSENT('GROUP_MA','TOUT'),
                  PRESENT_ABSENT('MAILLE','TOUT'),
                # La règle suivante permet de donner VALE_REF sans donner EVOL ni CHAM_GD
                # Elle est nécessaire pour la THM (voir doc U4.43.03)
                # Mais on ne peut plus l'écrire depuis de VALE_REF est dans un bloc
                # AU_MOINS_UN('EVOL','CHAM_GD','VALE_REF'),
                  EXCLUS('EVOL','CHAM_GD'),
                  ),

          TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ), # [défaut]
          GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
          MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

          NOM_VARC        =SIMP(statut='o',typ='TXM', into=("TEMP","GEOM","CORR","IRRA","HYDR","SECH","EPSA",
                               "M_ACIER","M_ZIRC","NEUT1","NEUT2","PTOT","DIVU",)),
          CHAM_GD        =SIMP(statut='f',typ=cham_gd_sdaster,),
          EVOL            =SIMP(statut='f',typ=evol_sdaster,),

          B_EVOL          =BLOC(condition="EVOL!=None",
              NOM_CHAM      =SIMP(statut='f',typ='TXM',into=("TEMP","CORR","IRRA","NEUT","GEOM",
                                                             "HYDR_ELNO","HYDR_NOEU",
                                                             "META_ELNO","META_NOEU",
                                                             "EPSA_ELNO","EPSA_NOEU","PTOT","DIVU",)),
              PROL_DROITE   =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
              PROL_GAUCHE   =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
              FONC_INST     =SIMP(statut='f',typ=(fonction_sdaster,formule)),
          ),

          # VALE_REF est nécessaire pour certaines VARC :
          B_VALE_REF          =BLOC(condition="NOM_VARC in ('TEMP','SECH')",
               VALE_REF          =SIMP(statut='o',typ='R'),
          ),

         ),

         #  mots clés cachés pour les variables de commande NEUT1/NEUT2 :
         #  --------------------------------------------------------------
         VARC_NEUT1   =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="NEUT1"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="NEUT_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("X1")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("NEUT1")),
         ),
         VARC_NEUT2   =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="NEUT2"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="NEUT_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("X1")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("NEUT2")),
         ),

         #  mots clés cachés pour variable de commande TEMP :
         #  --------------------------------------------------
         VARC_TEMP    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="TEMP"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="TEMP_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=4,min=4,defaut=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=4,min=4,defaut=("TEMP","TEMP_MIL","TEMP_INF","TEMP_SUP",)),
         ),

         #  mots clés cachés pour variable de commande GEOM :
         #  --------------------------------------------------
         VARC_GEOM    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="GEOM"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="GEOM_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=3,min=3,defaut=("X","Y","Z",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=3,min=3,defaut=("X","Y","Z",)),
         ),

         #  mots clés cachés pour variable de commande PTOT :
         #  -------------------------------------------------
         VARC_PTOT    =FACT(statut='d',
           NOM_VARC         =SIMP(statut='c',typ='TXM',defaut="PTOT"),
           GRANDEUR         =SIMP(statut='c',typ='TXM',defaut="DEPL_R"),
           CMP_GD           =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("PTOT",)),
           CMP_VARC         =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("PTOT",)),
         ),

         #  mots clés cachés pour variable de commande SECH :
         #  --------------------------------------------------
         VARC_SECH    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="SECH"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="TEMP_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("TEMP",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("SECH",)),
         ),

         #  mots clés cachés pour variable de commande HYDR :
         #  --------------------------------------------------
         VARC_HYDR    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="HYDR"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="HYDR_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("HYDR",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("HYDR",)),
         ),

         #  mots clés cachés pour variable de commande CORR :
         #  --------------------------------------------------
         VARC_CORR    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="CORR"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="CORR_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("CORR",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("CORR",)),
         ),

         #  mots clés cachés pour variable de commande IRRA :
         #  --------------------------------------------------
         VARC_IRRA    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="IRRA"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="IRRA_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("IRRA",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("IRRA",)),
         ),

         #  mots clés cachés pour variable de commande DIVU :
         #  --------------------------------------------------
         VARC_DIVU    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="DIVU"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="EPSI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("DIVU",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("DIVU",)),
         ),

         #  mots clés cachés pour variable de commande EPSA :
         #  --------------------------------------------------
         VARC_EPSA    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="EPSA"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="EPSI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=6,min=6,defaut=("EPXX","EPYY","EPZZ","EPXY","EPXZ","EPYZ",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=6,min=6,defaut=("EPSAXX","EPSAYY","EPSAZZ","EPSAXY","EPSAXZ","EPSAYZ",)),
         ),
         #  mots clés cachés pour variable de commande metallurgique ACIER :
         #  -----------------------------------------------------------------
         VARC_M_ACIER  =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="M_ACIER"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="VARI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=7,min=7,defaut=("V1","V2","V3","V4","V5","V6","V7")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=7,min=7,defaut=("PFERRITE","PPERLITE","PBAINITE",
                                                                          "PMARTENS","TAUSTE","TRANSF","TACIER",)),
         ),
         #  mots clés cachés pour variable de commande metallurgique ZIRCALOY :
         #  --------------------------------------------------------------------
         VARC_M_ZIRC  =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="M_ZIRC"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="VARI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=4,min=4,defaut=("V1","V2","V3","V4")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=4,min=4,defaut=("ALPHPUR","ALPHBETA","TZIRC","TEMPS")),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
AFFE_MODELE=OPER(nom="AFFE_MODELE",op=18,sd_prod=modele_sdaster,
            UIinfo={"groupes":("Modélisation",)},
                 fr="Définir le phénomène physique modélisé et le type d'éléments finis sur le maillage",reentrant='n',
         regles=(AU_MOINS_UN('AFFE','AFFE_SOUS_STRUC'),UN_PARMI('MAILLAGE','GRILLE')),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         GRILLE          =SIMP(statut='f',typ=grille_sdaster),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         VERIF           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=2,into=("MAILLE","NOEUD") ),
#
#====
# Définition des grandeurs caractéristiques
#====
#
         GRANDEUR_CARA =FACT(statut='f',max=1,
         fr="Grandeurs caractéristiques pour l'adimensionnement des indicateurs d'erreur HM",
         ang="Characteristic data for HM error estimators adimensionalisation",
#
            LONGUEUR      =SIMP(statut='f',typ='R',val_min=0,
                                fr ="Longueur caractéristique",
                                ang="Characteristic length",),
            PRESSION      =SIMP(statut='f',typ='R',val_min=0,
                                fr ="Pression caractéristique",
                                ang="Characteristic pressure",),
            TEMPERATURE   =SIMP(statut='f',typ='R',val_min=0,
                                fr ="Température caractéristique",
                                ang="Characteristic temperature",),),
#
         AFFE_SOUS_STRUC =FACT(statut='f',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           PHENOMENE       =SIMP(statut='f',typ='TXM',defaut="MECANIQUE",into=("MECANIQUE",) ),
         ),
         AFFE            =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           PHENOMENE       =SIMP(statut='o',typ='TXM',
                                 into=("MECANIQUE","THERMIQUE","ACOUSTIQUE") ),
                b_mecanique     =BLOC( condition = "PHENOMENE=='MECANIQUE'",
                                        fr="modélisations mécaniques",
                    MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                  "2D_DIS_T",        # RESP. : FLEJOU J.L.FLEJOU
                                  "2D_DIS_TR",       # RESP. : FLEJOU J.L.FLEJOU
                                  "2D_FLUI_ABSO",    # RESP. : DEVESA G.DEVESA
                                  "2D_FLUI_PESA",    # RESP. : GREFFET N.GREFFET
                                  "2D_FLUI_STRU",    # RESP. : GREFFET N.GREFFET
                                  "2D_FLUIDE",       # RESP. : GREFFET N.GREFFET
                                  "3D",              # RESP. : DESROCHES X.DESROCHES
                                  "3D_ABSO",         # RESP. : DEVESA G.DEVESA
                                  "3D_FAISCEAU",     # RESP. : VOLDOIRE F.VOLDOIRE
                                  "3D_FLUI_ABSO",    # RESP. : DEVESA G.DEVESA
                                  "3D_FLUIDE",       # RESP. : GREFFET N.GREFFET
                                  "3D_INCO",         # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_INCO_UP",      # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_INCO_OSGS",    # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_INCO_GD",      # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_INCO_LOG",     # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_INCO_LUP",     # RESP. : SFAYOLLE S.FAYOLLE
                                  "3D_SI",           # RESP. : DESROCHES X.DESROCHES
                                  "3D_GRAD_EPSI",    # RESP. : MICHEL S.MICHEL
                                  "3D_GRAD_VARI",    # RESP. : MICHEL S.MICHEL
                                  "3D_GVNO",         # RESP. : BEAURAIN J.BEAURAIN
                                  "3D_JOINT",        # RESP. : LAVERNE J.LAVERNE
                                  "3D_JOINT_HYME",   # RESP. : LAVERNE J.LAVERNE
                                  "3D_INTERFACE",    # RESP. : LAVERNE J.LAVERNE
                                  "3D_INTERFACE_S",  # RESP. : LAVERNE J.LAVERNE
                                  "AXIS",            # RESP. : LEFEBVRE J.P.LEFEBVRE
                                  "AXIS_FLUI_STRU",  # RESP. : GREFFET N.GREFFET
                                  "AXIS_FLUIDE",     # RESP. : GREFFET N.GREFFET
                                  "AXIS_FOURIER",    # RESP. : DESROCHES X.DESROCHES
                                  "AXIS_INCO",       # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_INCO_UP",    # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_INCO_OSGS",  # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_INCO_GD",    # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_INCO_LOG",   # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_INCO_LUP",   # RESP. : SFAYOLLE S.FAYOLLE
                                  "AXIS_SI",         # RESP. : DESROCHES X.DESROCHES
                                  "AXIS_GRAD_VARI",  # RESP. : MICHEL S.MICHEL
                                  "AXIS_GVNO",       # RESP. : BEAURAIN J.BEAURAIN
                                  "AXIS_JOINT",      # RESP. : LAVERNE J.LAVERNE
                                  "AXIS_INTERFACE",  # RESP. : LAVERNE J.LAVERNE
                                  "AXIS_INTERFACE_S",# RESP. : LAVERNE J.LAVERNE
                                  "AXIS_ELDI",       # RESP. : LAVERNE J.LAVERNE
                                  "BARRE",           # RESP. : FLEJOU J.L.FLEJOU
                                  "CABLE_GAINE",     # RESP. :
                                  "2D_BARRE",        # RESP. : FLEJOU J.L.FLEJOU
                                  "C_PLAN",          # RESP. : LEFEBVRE J.P.LEFEBVRE
                                  "C_PLAN_SI",       # RESP. : DESROCHES X.DESROCHES
                                  "C_PLAN_GRAD_EPSI",# RESP. : MICHEL S.MICHEL
                                  "CABLE",           # RESP. : FLEJOU J.L.FLEJOU
                                  "CABLE_POULIE",    # RESP. : None
                                  "COQUE_3D",        # RESP. : DESROCHES X.DESROCHES
                                  "COQUE_AXIS",      # RESP. : DESROCHES X.DESROCHES
                                  "COQUE_C_PLAN",    # RESP. : DESROCHES X.DESROCHES
                                  "COQUE_D_PLAN",    # RESP. : DESROCHES X.DESROCHES
                                  "D_PLAN",          # RESP. : LEFEBVRE J.P.LEFEBVRE
                                  "D_PLAN_GRAD_EPSI",# RESP. : MICHEL S.MICHEL
                                  "D_PLAN_GRAD_VARI",# RESP. : MICHEL S.MICHEL
                                  "D_PLAN_GVNO",     # RESP. : BEAURAIN J.BEAURAIN
                                  "D_PLAN_GRAD_SIGM",# RESP. : GRANET S.GRANET
                                  "PLAN_JOINT",      # RESP. : LAVERNE J.LAVERNE
                                  "PLAN_JOINT_HYME", # RESP. : LAVERNE J.LAVERNE
                                  "PLAN_INTERFACE",  # RESP. : LAVERNE J.LAVERNE
                                  "PLAN_INTERFACE_S",# RESP. : LAVERNE J.LAVERNE
                                  "PLAN_ELDI",       # RESP. : LAVERNE J.LAVERNE
                                  "D_PLAN_ABSO",     # RESP. : DEVESA G.DEVESA
                                  "D_PLAN_INCO",     # RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_INCO_UP",  # RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_INCO_OSGS",# RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_INCO_GD",  # RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_INCO_LOG", # RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_INCO_LUP", # RESP. : SFAYOLLE S.FAYOLLE
                                  "D_PLAN_SI",       # RESP. : DESROCHES X.DESROCHES
                                  "DIS_T",           # RESP. : FLEJOU J.L.FLEJOU
                                  "DIS_TR",          # RESP. : FLEJOU J.L.FLEJOU
                                  "DKT",             # RESP. : DESROCHES X.DESROCHES
                                  "DKTG",            # RESP. : MARKOVIC D.MARKOVIC
                                  "DST",             # RESP. : DESROCHES X.DESROCHES
                                  "FLUI_STRU",       # RESP. : GREFFET N.GREFFET
                                  "GRILLE_EXCENTRE", # RESP. : ROSPARS C.ROSPARS
                                  "GRILLE_MEMBRANE", # RESP. : ROSPARS C.ROSPARS
                                  "MEMBRANE",        # RESP. : ROSPARS C.ROSPARS
                                  "POU_C_T",         # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_E",         # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_EM",        # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_T",         # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_T_GD",      # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_TG",        # RESP. : FLEJOU J.L.FLEJOU
                                  "POU_D_TGM",       # RESP. : FLEJOU J.L.FLEJOU
                                  "Q4G",             # RESP. : DESROCHES X.DESROCHES
                                  "Q4GG",            # RESP. : DESROCHES X.DESROCHES
                                  "TUYAU_3M",        # RESP. : PROIX J.M.PROIX
                                  "TUYAU_6M",        # RESP. : PROIX J.M.PROIX
                                  "SHB",             # RESP. : DESROCHES X.DESROCHES
                                  "D_PLAN_HHM",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_HM",       # RESP. : GRANET S.GRANET
                                  "D_PLAN_HM_SI",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_THM",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_HHMD",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2MD",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_HMD",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_THHD",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_THH2D",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_THVD",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_THH2MD",   # RESP. : GRANET S.GRANET
                                  "D_PLAN_THHMD",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_THMD",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HHMS",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2MS",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_HMS",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_THHS",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_THH2S",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_THVS",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_THH2MS",   # RESP. : GRANET S.GRANET
                                  "D_PLAN_THHMS",    # RESP. : GRANET S.GRANET
                                  "D_PLAN_THMS",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HM_P",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HS",       # RESP. : GRANET S.GRANET
                                  "D_PLAN_HHD",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_HHS",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2D",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2S",     # RESP. : GRANET S.GRANET
                                  "D_PLAN_2DG",      # RESP. : GRANET S.GRANET
                                  "D_PLAN_DIL",      # RESP. : GRANET S.GRANET
                                  "3D_DIL",          # RESP. : GRANET S.GRANET
                                  "AXIS_THM",        # RESP. : GRANET S.GRANET
                                  "AXIS_HHM",        # RESP. : GRANET S.GRANET
                                  "AXIS_HM",         # RESP. : GRANET S.GRANET
                                  "AXIS_HH2MD",      # RESP. : GRANET S.GRANET
                                  "AXIS_HHMD",       # RESP. : GRANET S.GRANET
                                  "AXIS_HMD",        # RESP. : GRANET S.GRANET
                                  "AXIS_THHD",       # RESP. : GRANET S.GRANET
                                  "AXIS_THH2D",      # RESP. : GRANET S.GRANET
                                  "AXIS_THVD",       # RESP. : GRANET S.GRANET
                                  "AXIS_THHMD",      # RESP. : GRANET S.GRANET
                                  "AXIS_THH2MD",     # RESP. : GRANET S.GRANET
                                  "AXIS_THMD",       # RESP. : GRANET S.GRANET
                                  "AXIS_HH2MS",      # RESP. : GRANET S.GRANET
                                  "AXIS_HHMS",       # RESP. : GRANET S.GRANET
                                  "AXIS_HMS",        # RESP. : GRANET S.GRANET
                                  "AXIS_THHS",       # RESP. : GRANET S.GRANET
                                  "AXIS_THH2S",      # RESP. : GRANET S.GRANET
                                  "AXIS_THVS",       # RESP. : GRANET S.GRANET
                                  "AXIS_THHMS",      # RESP. : GRANET S.GRANET
                                  "AXIS_THH2MS",     # RESP. : GRANET S.GRANET
                                  "AXIS_THMS",       # RESP. : GRANET S.GRANET
                                  "AXIS_HHD",        # RESP. : GRANET S.GRANET
                                  "AXIS_HHS",        # RESP. : GRANET S.GRANET
                                  "AXIS_HH2D",       # RESP. : GRANET S.GRANET
                                  "AXIS_HH2S",       # RESP. : GRANET S.GRANET
                                  "3D_HHM" ,         # RESP. : GRANET S.GRANET
                                  "3D_HM",           # RESP. : GRANET S.GRANET
                                  "3D_HM_SI",        # RESP. : GRANET S.GRANET
                                  "3D_THHM",         # RESP. : GRANET S.GRANET
                                  "3D_THM",          # RESP. : GRANET S.GRANET
                                  "3D_HHMD",         # RESP. : GRANET S.GRANET
                                  "3D_HMD",          # RESP. : GRANET S.GRANET
                                  "3D_THHD",         # RESP. : GRANET S.GRANET
                                  "3D_THVD",         # RESP. : GRANET S.GRANET
                                  "3D_THHMD",        # RESP. : GRANET S.GRANET
                                  "3D_THMD",         # RESP. : GRANET S.GRANET
                                  "3D_HHMS",         # RESP. : GRANET S.GRANET
                                  "3D_HMS",          # RESP. : GRANET S.GRANET
                                  "3D_THHS",         # RESP. : GRANET S.GRANET
                                  "3D_THVS",         # RESP. : GRANET S.GRANET
                                  "3D_THHMS",        # RESP. : GRANET S.GRANET
                                  "3D_THMS",         # RESP. : GRANET S.GRANET
                                  "3D_THH2MD",       # RESP. : GRANET S.GRANET
                                  "3D_THH2MS",       # RESP. : GRANET S.GRANET
                                  "3D_HH2MD",        # RESP. : GRANET S.GRANET
                                  "3D_HH2MS",        # RESP. : GRANET S.GRANET
                                  "3D_THH2S",        # RESP. : GRANET S.GRANET
                                  "3D_THH2D",        # RESP. : GRANET S.GRANET
                                  "3D_HS",           # RESP. : GRANET S.GRANET
                                  "3D_HHD",          # RESP. : GRANET S.GRANET
                                  "3D_HHS",          # RESP. : GRANET S.GRANET
                                  "3D_HH2D",         # RESP. : GRANET S.GRANET
                                  "3D_HH2S",         # RESP. : GRANET S.GRANET
                                  "VF1",             # RESP. : GRANET S.GRANET
                                  "3D_HH2SUDM",      # RESP. : GRANET S.GRANET
                                  "3D_HH2SUDA",      # RESP. : GRANET S.GRANET
                                  "3D_HH2SUC",       # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2SUDM",  # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2SUC",   # RESP. : GRANET S.GRANET
                                  "D_PLAN_HH2SUDA",  # RESP. : GRANET S.GRANET
                                  "PLAN_JHMS",
                                  "AXIS_JHMS",
                                                                      )  )  ),

                b_thermique     =BLOC( condition = "PHENOMENE=='THERMIQUE'",
                                        fr="modélisations thermiques",
                    MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                  "3D",              # RESP. : DURAND C.DURAND
                                  "3D_DIAG",         # RESP. : DURAND C.DURAND
                                  "AXIS",            # RESP. : DURAND C.DURAND
                                  "AXIS_DIAG",       # RESP. : DURAND C.DURAND
                                  "AXIS_FOURIER",    # RESP. : DESROCHES X.DESROCHES
                                  "COQUE",           # RESP. : DESROCHES X.DESROCHES
                                  "COQUE_AXIS",      # RESP. : DESROCHES X.DESROCHES
                                  "COQUE_PLAN",      # RESP. : DESROCHES X.DESROCHES
                                  "PLAN",            # RESP. : DURAND C.DURAND
                                  "PLAN_DIAG",       # RESP. : DURAND C.DURAND
                                                                      ),),),

                b_acoustique    =BLOC( condition = "PHENOMENE=='ACOUSTIQUE'",
                                        fr="modélisations acoustiques",
                     MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                  "3D",              # RESP. : None
                                  "PLAN"             # RESP. : None
                                                                       ), ),),

         ),

         PARTITION         =FACT(statut='d',
             PARALLELISME    =SIMP(statut='f',typ='TXM',defaut="GROUP_ELEM",
                                   into=("MAIL_CONTIGU","MAIL_DISPERSE","CENTRALISE","GROUP_ELEM")),
             b_dist_maille          =BLOC(condition = "PARALLELISME in ('MAIL_DISPERSE','MAIL_CONTIGU')",
                 CHARGE_PROC0_MA =SIMP(statut='f',typ='I',defaut=100,val_min=0,val_max=100),
             ),
         ),

         VERI_JACOBIEN  =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI',
                              fr ="Vérification de la forme des mailles (jacobiens tous de meme signe).",),
) ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def appl_cine_matr_prod(MATR_ASSE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r : return matr_asse_depl_r
  if AsType(MATR_ASSE) == matr_asse_depl_c : return matr_asse_depl_c
  if AsType(MATR_ASSE) == matr_asse_temp_r : return matr_asse_temp_r
  if AsType(MATR_ASSE) == matr_asse_temp_c : return matr_asse_temp_c
  if AsType(MATR_ASSE) == matr_asse_pres_r : return matr_asse_pres_r
  if AsType(MATR_ASSE) == matr_asse_pres_c : return matr_asse_pres_c
  raise AsException("type de concept resultat non prevu")

APPL_CINE_MATR=OPER(nom="APPL_CINE_MATR",op=158,sd_prod=appl_cine_matr_prod,
               fr="Appliquer les C.L. cinématiques sur la matrice",
               reentrant='f', UIinfo={"groupes":("Résolution",)},
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

APPL_CINE_SCMB=OPER(nom="APPL_CINE_SCMB",op=159,sd_prod=cham_no_sdaster,reentrant='f',
               fr="Application des C.L. cinématiques au second membre",
               UIinfo={"groupes":("Résolution",)},
         CHAM_NO        =SIMP(statut='o',typ=cham_no_sdaster),
         MATR           =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),
         CHAM_CINE       =SIMP(statut='f',typ=cham_no_sdaster),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr


def asse_elem_ssd_prod(self,RESU_ASSE_SSD,**args):
    MTYPES = {
        'MODELE' : modele_gene,
        'NUME_DDL_GENE' : nume_ddl_gene,
        'RIGI_GENE' : matr_asse_gene_r,
        'MASS_GENE' : matr_asse_gene_r,
              }
    for res in RESU_ASSE_SSD:
        for mc, typ in MTYPES.items():
            if res[mc]:
                self.type_sdprod(res[mc], typ)
    return None

ASSE_ELEM_SSD=MACRO(nom="ASSE_ELEM_SSD",
                    op=OPS('Macro.asse_elem_ssd_ops.asse_elem_ssd_ops'),
                    sd_prod=asse_elem_ssd_prod,
                    reentrant='n',
                    fr="Enchainer les commandes DEFI_MODELE_GENE, NUME_DDL_GENE et ASSE_MATR_GENE",
                    UIinfo={"groupes":("Matrices/vecteurs",)},

# pour les concepts de sortie
        RESU_ASSE_SSD = FACT( statut='o', max=1,
                          regles=(PRESENT_PRESENT('RIGI_GENE','NUME_DDL_GENE'),
                                  PRESENT_PRESENT('MASS_GENE','NUME_DDL_GENE'),),
                              MODELE=SIMP(statut='o',typ=CO,defaut=None),
                              NUME_DDL_GENE=SIMP(statut='f',typ=CO,defaut=None),
                              RIGI_GENE=SIMP(statut='f',typ=CO,defaut=None),
                              MASS_GENE=SIMP(statut='f',typ=CO,defaut=None),
                           ),

        INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),

# pour DEFI_MODELE_GENE
        SOUS_STRUC      =FACT(statut='o',max='**',
           NOM             =SIMP(statut='o',typ='TXM' ),
           MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           TRANS           =SIMP(statut='f',typ='R',max=3),
         ),
        LIAISON         =FACT(statut='o',max='**',
           SOUS_STRUC_1    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_1     =SIMP(statut='o',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_2     =SIMP(statut='o',typ='TXM' ),
           regles=(EXCLUS('GROUP_MA_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),
                   EXCLUS('MAILLE_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),),
           GROUP_MA_MAIT_1   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_1     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_MAIT_2   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_2     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           OPTION            =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("REDUIT","CLASSIQUE") ),
         ),
        VERIF           =FACT(statut='d',max=1,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),


# pour NUME_DDL_GENE
        METHODE      =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","ELIMINE") ),
        STOCKAGE     =SIMP(statut='f',typ='TXM',defaut="LIGN_CIEL",into=("LIGN_CIEL","PLEIN") ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
ASSE_MAILLAGE=OPER(nom="ASSE_MAILLAGE",op= 105,sd_prod=maillage_sdaster,
                   fr="Assembler deux maillages pour en former un nouveau",
                   reentrant='n',
                   UIinfo={"groupes":("Maillage",)},
         MAILLAGE_1 =  SIMP(statut='o',typ=maillage_sdaster,),
         MAILLAGE_2 =  SIMP(statut='o',typ=maillage_sdaster,),
         OPERATION  =  SIMP(statut='o',typ='TXM',into=("SOUS_STR","SUPERPOSE","COLLAGE"),),
         b_collage  =  BLOC(condition = "OPERATION == 'COLLAGE'",
           COLLAGE  =  FACT(statut='o',
              GROUP_MA_1     =SIMP(statut='o',typ=grma),
              GROUP_MA_2     =SIMP(statut='o',typ=grma),
                             ),
                           ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
def asse_matr_gene_prod(METHODE,**args):
    if   (METHODE=="INITIAL") : return matr_asse_gene_r
    elif (args['OPTION']=="RIGI_GENE_C") : return matr_asse_gene_c
    else : return matr_asse_gene_r

ASSE_MATR_GENE=OPER(nom="ASSE_MATR_GENE",op= 128,sd_prod=asse_matr_gene_prod,
                    fr="Assemblage des matrices généralisées de macro éléments pour construction de la matrice globale généralisée",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         METHODE          =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","INITIAL") ),
         b_option     =BLOC(condition = "METHODE == 'CLASSIQUE'",
           OPTION          =SIMP(statut='o',typ='TXM',into=("RIGI_GENE","RIGI_GENE_C","MASS_GENE","AMOR_GENE") ),
           ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def asse_matrice_prod(MATR_ELEM,**args):
  if AsType(MATR_ELEM) == matr_elem_depl_r : return matr_asse_depl_r
  if AsType(MATR_ELEM) == matr_elem_depl_c : return matr_asse_depl_c
  if AsType(MATR_ELEM) == matr_elem_temp_r : return matr_asse_temp_r
  if AsType(MATR_ELEM) == matr_elem_pres_c : return matr_asse_pres_c
  raise AsException("type de concept resultat non prevu")

ASSE_MATRICE=OPER(nom="ASSE_MATRICE",op=12,sd_prod=asse_matrice_prod,
                  fr="Construction d'une matrice assemblée",reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         MATR_ELEM       =SIMP(statut='o',
                               typ=(matr_elem_depl_r,matr_elem_depl_c,matr_elem_temp_r,matr_elem_pres_c) ),
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster),
         SYME            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         CHAR_CINE       =SIMP(statut='f',typ=(char_cine_meca,char_cine_ther,char_cine_acou) ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
ASSE_VECT_GENE=OPER(nom="ASSE_VECT_GENE",op= 140,sd_prod=vect_asse_gene,
                    fr="Projection des chargements sur la base modale d'une sous structure",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         METHODE          =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","INITIAL") ),
         b_nume     =BLOC(condition = "METHODE == 'CLASSIQUE'",
             CHAR_SOUS_STRUC =FACT(statut='o',max='**',
             SOUS_STRUC      =SIMP(statut='o',typ='TXM' ),
             VECT_ASSE       =SIMP(statut='o',typ=cham_no_sdaster ),
           ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

ASSE_VECTEUR=OPER(nom="ASSE_VECTEUR",op=13,sd_prod=cham_no_sdaster,
                  fr="Construire un champ aux noeuds par assemblage de vecteurs élémentaires",reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         VECT_ELEM       =SIMP(statut='o',typ=vect_elem,max='**'),
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2,) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: albert.alarcon at edf.fr

def assemblage_prod(self,NUME_DDL,MATR_ASSE,VECT_ASSE,**args):
  if ((not MATR_ASSE) and (not VECT_ASSE)):  raise AsException("Aucun concept a assembler")
  if not NUME_DDL :  raise AsException("Impossible de typer les concepts resultats")
  if NUME_DDL.is_typco():
    self.type_sdprod(NUME_DDL,nume_ddl_sdaster)

  if MATR_ASSE !=None: 
      for m in MATR_ASSE:
        opti=m['OPTION']
        if opti in ( "RIGI_MECA","RIGI_FLUI_STRU",
                     "MASS_MECA" , "MASS_FLUI_STRU" ,"RIGI_GEOM" ,"RIGI_ROTA",
                     "AMOR_MECA","IMPE_MECA","ONDE_FLUI","MASS_MECA_DIAG",
                     "MECA_GYRO","RIGI_GYRO" ) : t=matr_asse_depl_r

        if opti in ( "RIGI_ACOU","MASS_ACOU","AMOR_ACOU",) : t=matr_asse_pres_c

        if opti in ( "RIGI_THER","RIGI_THER_CONV" ,
                     "RIGI_THER_CONV_D",) : t=matr_asse_temp_r

        if opti == "RIGI_MECA_HYST"   : t= matr_asse_depl_c

        self.type_sdprod(m['MATRICE'],t)

  if VECT_ASSE !=None:
      for v in VECT_ASSE:
        self.type_sdprod(v['VECTEUR'],cham_no_sdaster)
    
  return None

ASSEMBLAGE=MACRO(nom="ASSEMBLAGE",
                      op=OPS('Macro.assemblage_ops.assemblage_ops'),
                      UIinfo={"groupes":("Matrices et vecteurs",)},
                      sd_prod=assemblage_prod,
                      regles=(AU_MOINS_UN('MATR_ASSE','VECT_ASSE'),),
                      fr="Calcul des matrices et vecteurs assemblés ",
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         INST            =SIMP(statut='f',typ='R',defaut=0.),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         CHARGE          =SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**'),
         CHAR_CINE       =SIMP(statut='f',typ=(char_cine_meca,char_cine_ther,char_cine_acou) ),
         NUME_DDL        =SIMP(statut='o',typ=(nume_ddl_sdaster,CO)),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS","PETSC") ),
         b_mult_front    =BLOC(condition="METHODE=='MULT_FRONT'",fr="Paramètres associés à la méthode multifrontale",
           RENUM           =SIMP(statut='f',typ='TXM',into=("MD","MDA","METIS"),defaut="METIS" ),
         ),
         b_ldlt          =BLOC(condition="METHODE=='LDLT'",fr="Paramètres associés à la méthode LDLT",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         b_mumps         =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
           RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","SCOTCH","AUTO")),
         ),
         b_gcpc          =BLOC(condition="METHODE=='GCPC'",fr="Paramètres associés à la méthode gradient conjugué",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         b_petsc         =BLOC(condition = "METHODE == 'PETSC'",fr="Paramètres de la méthode PETSC",
           RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
         ),
         ),

         MATR_ASSE       =FACT(statut='f',max='**',
             MATRICE         =SIMP(statut='o',typ=CO),         
             OPTION          =SIMP(statut='o',typ='TXM',
                                   into=("RIGI_MECA","MASS_MECA","MASS_MECA_DIAG",
                                         "AMOR_MECA","RIGI_MECA_HYST","IMPE_MECA",
                                         "ONDE_FLUI","RIGI_FLUI_STRU","MASS_FLUI_STRU",
                                         "RIGI_ROTA","RIGI_GEOM","MECA_GYRO","RIGI_GYRO",
                                         "RIGI_THER","RIGI_ACOU","MASS_ACOU","AMOR_ACOU",)
                                   ),

             b_rigi_meca = BLOC( condition = "OPTION=='RIGI_MECA'",
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),

             b_rigi_geom = BLOC( condition = "OPTION=='RIGI_GEOM'",
               SIEF_ELGA       =SIMP(statut='o',typ=cham_elem),
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),

             b_rigi_ther = BLOC( condition = "OPTION=='RIGI_THER'",
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),
#
         ), # fin MATR_ASSE
#          
         VECT_ASSE       =FACT(statut='f',max='**',
             VECTEUR         =SIMP(statut='o',typ=CO),             
             OPTION          =SIMP(statut='o',typ='TXM',into=("CHAR_MECA","CHAR_ACOU","CHAR_THER") ),
           b_char_meca     =BLOC(condition = "OPTION == 'CHAR_MECA'", fr="chargement mécanique",
              CHARGE       =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
              MODE_FOURIER =SIMP(statut='f',typ='I',defaut= 0 ),
              ),
           
           b_char_ther     =BLOC(condition = "OPTION=='CHAR_THER'", fr="chargement thermique",
              CHARGE           =SIMP(statut='f',typ=char_ther,validators=NoRepeat(),max='**'),
              ),

           b_char_acou     =BLOC(condition = "OPTION=='CHAR_ACOU'", fr="chargement acoustique",
              CHARGE           =SIMP(statut='f',typ=char_acou,validators=NoRepeat(),max='**'),
              ),
#
         ), # fin VECT_ASSE
#
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr
CALC_AMOR_MODAL=OPER(nom="CALC_AMOR_MODAL",op= 172,sd_prod=listr8_sdaster,
                     fr="Création d'une liste d'amortissements modaux calculés selon la règle du RCC-G",
                     reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},
       regles=(EXCLUS('AMOR_RAYLEIGH','ENER_SOL',),
               EXCLUS('AMOR_RAYLEIGH','AMOR_INTERNE',),
               EXCLUS('AMOR_RAYLEIGH','AMOR_SOL',),
               PRESENT_PRESENT('ENER_SOL','AMOR_INTERNE'),
               PRESENT_PRESENT('ENER_SOL','AMOR_SOL'),
               ),
         AMOR_RAYLEIGH   =FACT(statut='f',
           AMOR_ALPHA      =SIMP(statut='o',typ='R'),
           AMOR_BETA       =SIMP(statut='o',typ='R'),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
         ),
         ENER_SOL        =FACT(statut='f',
           regles=(UN_PARMI('GROUP_NO_RADIER','GROUP_MA_RADIER'),
                   PRESENT_ABSENT('COEF_GROUP','FONC_GROUP'),
#  Peut-on remplacer les deux règles suivantes par un ENSEMBLE_('KRX','KRY','KRZ')
                   PRESENT_PRESENT('KRX','KRY'),
                   PRESENT_PRESENT('KRX','KRZ'),
                   PRESENT_ABSENT('COOR_CENTRE','NOEUD_CENTRE'),
                   PRESENT_ABSENT('GROUP_NO_CENTRE','NOEUD_CENTRE'),
                   PRESENT_ABSENT('GROUP_NO_CENTRE','COOR_CENTRE'),),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","RIGI_PARASOL") ),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           GROUP_NO_RADIER =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           GROUP_MA_RADIER =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           FONC_GROUP      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_GROUP      =SIMP(statut='f',typ='R',max='**'),
           KX              =SIMP(statut='o',typ='R' ),
           KY              =SIMP(statut='o',typ='R' ),
           KZ              =SIMP(statut='o',typ='R' ),
           KRX             =SIMP(statut='f',typ='R' ),
           KRY             =SIMP(statut='f',typ='R' ),
           KRZ             =SIMP(statut='f',typ='R' ),
           GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
           NOEUD_CENTRE    =SIMP(statut='f',typ=no),
           COOR_CENTRE     =SIMP(statut='f',typ='R',max=3),
         ),
         AMOR_INTERNE    =FACT(statut='f',
           ENER_POT        =SIMP(statut='o',typ=table_sdaster ),
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           AMOR_REDUIT     =SIMP(statut='o',typ='R',max='**'),
         ),
         AMOR_SOL        =FACT(statut='f',
           AMOR_REDUIT     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FONC_AMOR_GEO   =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
           HOMOGENE        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 0.3 ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: josselin.delmas at edf.fr

CALC_CHAM_ELEM=OPER(nom="CALC_CHAM_ELEM",op=38,sd_prod=cham_elem,
                    fr="Calculer un champ élémentaire en thermique et en accoustique à partir de champs déjà calculés",
                    reentrant='n',
            UIinfo={"groupes":("Résultats et champs","Post-traitements",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),

         regles=(EXCLUS('TOUT','GROUP_MA',),EXCLUS('TOUT','MAILLE',),),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0),
         ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
         MODE_FOURIER    =SIMP(statut='f',typ='I',),

         OPTION          =SIMP(statut='o',typ='TXM',
                               into=("FLUX_ELGA","FLUX_ELNO",
                                                 "PRAC_ELNO",
                                     "COOR_ELGA"), ),

         b_thermique  =BLOC(condition="OPTION in ('FLUX_ELNO','FLUX_ELGA',)",
           TEMP            =SIMP(statut='o',typ=(cham_no_sdaster,)),
           CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         ),

         b_acoustique  =BLOC(condition="OPTION in ('PRAC_ELNO',)",
           PRES            =SIMP(statut='o',typ=(cham_no_sdaster,)),
         ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr
def calc_champ_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu : RESULTAT=%s (type %s)" \
        % (RESULTAT, type(RESULTAT)))

CALC_CHAMP=OPER(nom="CALC_CHAMP",op=52,sd_prod=calc_champ_prod,reentrant='f',
                UIinfo={"groupes":("Post traitements",)},
                fr="Completer ou creer un resultat en calculant des champs par elements ou aux noeuds",
     MODELE           = SIMP(statut='f',typ=modele_sdaster),
     CHAM_MATER       = SIMP(statut='f',typ=cham_mater),
     CARA_ELEM        = SIMP(statut='f',typ=cara_elem),

     RESULTAT         = SIMP(statut='o',typ=resultat_sdaster,position='global',
                             fr="Resultat d'une commande globale"),

     regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                    'NOEUD_CMP','LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS'),
             PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
             ),
     TOUT_ORDRE       = SIMP(statut='f',typ='TXM',into=("OUI",) ),
     NUME_ORDRE       = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NUME_MODE        = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NOEUD_CMP        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
     NOM_CAS          = SIMP(statut='f',typ='TXM' ),
     INST             = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     FREQ             = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     LIST_INST        = SIMP(statut='f',typ=listr8_sdaster),
     LIST_FREQ        = SIMP(statut='f',typ=listr8_sdaster),
     CRITERE          = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
     b_prec_rela = BLOC(condition="(CRITERE=='RELATIF')",
          PRECISION   = SIMP(statut='f',typ='R',defaut= 1.E-6),),
     b_prec_abso = BLOC(condition="(CRITERE=='ABSOLU')",
          PRECISION   = SIMP(statut='o',typ='R'),),
     LIST_ORDRE       = SIMP(statut='f',typ=listis_sdaster),

     TOUT             = SIMP(statut='f',typ='TXM',into=("OUI",),
                             fr="le calcul sera effectue sur toutes les mailles"),
     GROUP_MA         = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                             fr="le calcul ne sera effectue que sur ces groupes de mailles"),
     MAILLE           = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**',
                             fr="le calcul ne sera effectue que sur ces mailles"),

     EXCIT       = FACT(statut='f',max='**',
                        fr="Charges contenant les temperatures, les efforts repartis pour les poutres...",
                        regles=(EXCLUS('FONC_MULT','COEF_MULT',),),
         CHARGE       = SIMP(statut='o',typ=(char_meca,char_cine_meca),),
         FONC_MULT    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),),
         COEF_MULT    = SIMP(statut='f',typ='R'),
         TYPE_CHARGE  = SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),),

     # Bloc lineaire
     b_lineaire  = BLOC(condition = "AsType(RESULTAT) in (evol_elas,dyna_trans,dyna_harmo,mode_meca,\
                                                          comb_fourier,mult_elas,fourier_elas,mode_flamb)",
         CONTRAINTE   = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de contraintes et efforts generalises",
                             into=C_NOM_CHAM_INTO(phenomene='CONTRAINTE',categorie='lin'),),

         DEFORMATION  = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de deformations",
                             into=C_NOM_CHAM_INTO(phenomene='DEFORMATION',categorie='lin'),),

         ENERGIE      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul d'energies",
                             into=C_NOM_CHAM_INTO(phenomene='ENERGIE',categorie='lin'),),

         CRITERES     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de criteres",
                             into=C_NOM_CHAM_INTO(phenomene='CRITERES',categorie='lin'),),

         VARI_INTERNE = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de variables internes",
                             into=C_NOM_CHAM_INTO(phenomene='VARI_INTERNE',categorie='lin'),),
                     ),

     # Bloc non-lineaire
     b_non_lin  = BLOC(condition = "AsType(RESULTAT) in (evol_noli,)",
         CONTRAINTE   = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de contraintes et efforts generalises",
                             into=C_NOM_CHAM_INTO(phenomene='CONTRAINTE',categorie='nonlin'),),

         DEFORMATION  = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de deformations",
                             into=C_NOM_CHAM_INTO(phenomene='DEFORMATION',categorie='nonlin'),),

         ENERGIE      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul d'energies",
                             into=C_NOM_CHAM_INTO(phenomene='ENERGIE',categorie='nonlin'),),

         CRITERES     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de criteres",
                             into=C_NOM_CHAM_INTO(phenomene='CRITERES',categorie='nonlin'),),

         VARI_INTERNE = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de variables internes",
                             into=C_NOM_CHAM_INTO(phenomene='VARI_INTERNE',categorie='nonlin'),),

         b_nom_vari   = BLOC(condition = "au_moins_un(VARI_INTERNE, ('VAEX_ELNO','VAEX_ELGA','VAEX_NOEU'))",
             NOM_VARI = SIMP(statut='o',typ='TXM',min= 1,max='**',
                             fr="nom de la variable a extraire",
                             into=("DPORO","DRHOLQ","DPVP","SATLIQ","EVP","IND_ETA","D","IND_END","TEMP_MAX",
                                   "GAMP","PCR","SEUIL_HYD","IND_HYD","PCOHE","COMP_ROC","SEUIL_ISO","ANG_DEV",
                                   "X11","X22","X33","X12","X13","X23","DIST_DEV","DEV_SUR_CRIT","DIST_ISO",
                                   "NB_ITER","ARRET","NB_REDE","SIGNE","RDEV_1","RDEV_2","RDEV_3","RISO","EPSIVPLA",
                                   "IND_1","IND_2","IND_3","IND_4",
                                   ),
                             ),),

         HYDRAULIQUE  = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour le calcul de flux hydraulique",
                             into=C_NOM_CHAM_INTO(phenomene='HYDRAULIQUE',categorie='nonlin'),),
                      ),

     # Bloc Thermique
     b_ther = BLOC(condition = "AsType(RESULTAT) in (evol_ther,fourier_ther,)" ,
         THERMIQUE    = SIMP(statut='f',typ='TXM',validators=NoRepeat(), max='**',
                             fr="Options pour le calcul de champs en thermique",
                             into=C_NOM_CHAM_INTO(phenomene='THERMIQUE',),),
                  ),

     # Bloc acoustique
     b_acou = BLOC(condition = "AsType(RESULTAT) in (acou_harmo,mode_acou,dyna_harmo)",
         ACOUSTIQUE   = SIMP(statut='f',typ='TXM',validators=NoRepeat(), max='**',
                             fr="Options pour le calcul de champs en acoustique",
                             into=C_NOM_CHAM_INTO(phenomene='ACOUSTIQUE',),),
                  ),

     # Bloc FORC_NODA et REAC_NODA
     FORCE            = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                             fr="Options pour des forces nodales et des reactions nodales",
                             into=C_NOM_CHAM_INTO(phenomene='FORCE',),),

     # Mot-cle facteur CHAMp UTILisateur
     CHAM_UTIL = FACT(statut='f', max='**',
          regles = (UN_PARMI('FORMULE', 'CRITERE', 'NORME'), ),
          NOM_CHAM = SIMP(statut='o', typ='TXM',
                          fr="Nom du champ utilisé en donnée",),
          FORMULE  = SIMP(statut='f', typ=formule, max='**',
                          fr="Formule permet d'obtenir le critère",),
          CRITERE  = SIMP(statut='f', typ='TXM', max=1,
                          into=('TRACE', 'VMIS', 'INVA_2'),
                          fr="Calcul d'un critère pré-défini",),
          NORME    = SIMP(statut='f', typ='TXM', max=1,
                          into=('L2', 'FROBENIUS', ),
                          fr="Calcul d'une norme pré-définie",),
          NUME_CHAM_RESU = SIMP(statut='o', typ='I', val_min=1, val_max=20,
                          fr="Numéro du champ produit. Exemple: 6 produit le champ UT06",),
     ),

     INFO             = SIMP(statut='f',typ='I',defaut= 1,into=(1,2)),

     TITRE            = SIMP(statut='f',typ='TXM',max='**'),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

CALC_CHAR_CINE=OPER(nom="CALC_CHAR_CINE",op= 102,sd_prod=cham_no_sdaster,
                    fr="Calcul des seconds membres associés à des charges cinématiques (conditions aux limites non dualisées)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         CHAR_CINE       =SIMP(statut='o',typ=(char_cine_meca,char_cine_ther,char_cine_acou ),validators=NoRepeat(),max='**' ),
         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr
def calc_char_seisme_prod(MATR_MASS,**args ):
  if AsType(MATR_MASS) == matr_asse_depl_r : return cham_no_sdaster
  raise AsException("type de concept resultat non prevu")

CALC_CHAR_SEISME=OPER(nom="CALC_CHAR_SEISME",op=  92,sd_prod=calc_char_seisme_prod,
                      reentrant='n',fr="Calcul du chargement sismique",
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(UN_PARMI('MONO_APPUI','MODE_STAT' ),),
         MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r,fr="Matrice de masse" ),
         DIRECTION       =SIMP(statut='o',typ='R',max=6,fr="Directions du séisme imposé"),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         MODE_STAT       =SIMP(statut='f',typ=(mode_meca,) ),
         b_mode_stat     =BLOC ( condition = "MODE_STAT != None",
           regles=(UN_PARMI('NOEUD','GROUP_NO' ),),
           NOEUD           =SIMP(statut='f',typ=no,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
CALC_CORR_SSD=OPER(nom="CALC_CORR_SSD",op=  91,sd_prod=table_container,
                    fr="Qualite d'un modele reduit en dynamique",
                    reentrant='n',
            UIinfo={"groupes":("Dynamique",)},
         MODELE_GENE    =SIMP(statut='o',typ=modele_gene),
         RESU_GENE      =SIMP(statut='o',typ=mode_gene ),
         UNITE          =SIMP(statut='f',typ='I',defaut=6,),   
         SHIFT          =SIMP(statut='f',typ='R',defaut= 1. ),
         VERIF          =FACT(statut='f',max='**',
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
         TITRE          =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: marina.bottoni at edf.fr


def calc_ecrevisse_prod(self,CHARGE_MECA,CHARGE_THER1,CHARGE_THER2,TABLE,DEBIT,**args):

  self.type_sdprod(CHARGE_MECA,char_meca)
  self.type_sdprod(CHARGE_THER1,char_ther)
  self.type_sdprod(CHARGE_THER2,char_ther)
  self.type_sdprod(TABLE,table_sdaster)
  self.type_sdprod(DEBIT,table_sdaster)
  return None



CALC_ECREVISSE=MACRO(nom="CALC_ECREVISSE",
                     op=OPS('Macro.calc_ecrevisse_ops.calc_ecrevisse_ops'),
                     sd_prod=calc_ecrevisse_prod,
                     reentrant='n',
                     UIinfo={"groupes":("Outils-métier",)},fr="Procedure de couplage avec Ecrevisse",
                     regles   = (UN_PARMI('LOGICIEL','VERSION'),),

#      CONCEPTS SORTANTS : 2 CHARGEMENTS THERMIQUE + 1 MECANIQUE + 2 TABLES POUR LE POST-TRAITEMENT
#      ********************************************
         CHARGE_MECA        =SIMP(statut='o',typ=CO),
         CHARGE_THER1       =SIMP(statut='o',typ=CO),
         CHARGE_THER2       =SIMP(statut='o',typ=CO),
         TABLE              =SIMP(statut='o',typ=CO),
         DEBIT              =SIMP(statut='o',typ=CO),


#      MODELES MECANIQUES
#      ********************************************
         MODELE_MECA        =SIMP(statut='o',typ=modele_sdaster),
         MODELE_THER        =SIMP(statut='o',typ=modele_sdaster),


#      DONNEES GEOMETRIQUES RELATIVES AUX RESULTATS
#      ********************************************
         RESULTAT           =FACT(statut='o',min=1,max=1,
           MECANIQUE           =SIMP(statut='o',typ=resultat_sdaster),
           THERMIQUE           =SIMP(statut='o',typ=resultat_sdaster),
           regles=(EXCLUS('NUME_ORDRE','INST'),),
           NUME_ORDRE          =SIMP(statut='f',typ='I',validators=NoRepeat(),),
           INST                =SIMP(statut='f',typ='R',validators=NoRepeat(),),
         ),

#      DONNEES GEOMETRIQUES RELATIVES A LA FISSURE
#      *******************************************

         FISSURE            =FACT(statut='o',min=1,max='**',
           PREFIXE_FICHIER     =SIMP(statut='f',typ='TXM',validators=LongStr(1,8),),
           GROUP_MA            =SIMP(statut='o',typ=grma,validators=NoRepeat(),min=2,max=2,
                                     fr="Groupe(s) des noeuds definissant les levres de la fissure"),
           GROUP_NO_ORIG       =SIMP(statut='o',typ=grno,validators=NoRepeat(),min=2,max=2),
           GROUP_NO_EXTR       =SIMP(statut='o',typ=grno,validators=NoRepeat(),min=2,max=2),
           ZETA                =SIMP(statut='o',typ='R',fr="Coefficient de la perte de charge singuliere a l'entree [zeta]" ),
           RUGOSITE            =SIMP(statut='o',typ='R',fr="Rugosite absolu (metres) [eps]" ),
           OUVERT_REMANENTE    =SIMP(statut='o',typ='R',val_min=0.,fr="Ouverture remanente"),
           TORTUOSITE          =SIMP(statut='f',typ='R',defaut=1.0, val_min=0., val_max=1.0,
                                       fr="Coefficient de tortuosite de la fissure" ),
           SECTION             =SIMP(statut='o',typ='TXM',into=("ELLIPSE","RECTANGLE"),fr="Type de section [is]" ),
           b_section_ellipse   =BLOC(condition="SECTION=='ELLIPSE'",fr="Fissure a section elliptique",
             LISTE_COTES_BL      =SIMP(statut='f',typ='R',max='**',
                                       fr="Liste des cotes des points definissant le petit axe de la section",
                                       validators=NoRepeat() ),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant le petit axe de la section", ),
           ),
           b_section_rectangle =BLOC(condition="SECTION=='RECTANGLE'",fr="Fissure a section rectangulaire",
             LISTE_COTES_BL      =SIMP(statut='f',typ='R',max='**',
                                       fr="Liste des cotes des points definissant la largeur de la section",
                                       validators=NoRepeat() ),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant la largeur de la section", ),
           ),
         ),


#      DONNEES RELATIVES A L"ECOULEMENT
#      ********************************

         ECOULEMENT         =FACT(statut='o',min=1,max=1,
           PRES_ENTREE         =SIMP(statut='o',typ='R',fr="Pression de stagnation a l'entree (Pa) [pe]" ),
           PRES_SORTIE         =SIMP(statut='o',typ='R',fr="Pression de stagnation a la sortie (Pa) [ps]" ),
           FLUIDE_ENTREE       =SIMP(statut='o',typ='I',into=(1,2,3,4,5,6),fr="Condition du fluide a l'entree [iflow]" ),
           b_condition_1       =BLOC(condition="FLUIDE_ENTREE==1",fr="Eau sous-refroidie ou saturee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_2       =BLOC(condition="FLUIDE_ENTREE==2",fr="Fluide diphasique",
             TITR_MASS           =SIMP(statut='o',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
           ),
           b_condition_3       =BLOC(condition="FLUIDE_ENTREE==3",fr="Vapeur saturee ou surchauffee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_4       =BLOC(condition="FLUIDE_ENTREE==4",fr="Air + vapeur surchauffee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             PRES_PART           =SIMP(statut='o',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_5       =BLOC(condition="FLUIDE_ENTREE==5",fr="Air + vapeur saturee",
             TITR_MASS           =SIMP(statut='o',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
             PRES_PART           =SIMP(statut='o',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_6       =BLOC(condition="FLUIDE_ENTREE==6",fr="Air seul",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
         ),


#      CHOIX DES MODELES
#      *****************

         MODELE_ECRE        =FACT(statut='o',min=1,max=1,
           IVENAC              =SIMP(statut='f', typ='I', into=(0,1), defaut=0,
                                     fr="Calcul ECREVISSE avec prise en compte de la vena contracta"),
           ECOULEMENT          =SIMP(statut='o',typ='TXM',into=("SATURATION","GELE"),
                                     fr="Type de modele d'ecoulement diphasique [imod]" ),
           b_ecou_gele         =BLOC(condition="ECOULEMENT=='GELE'",fr="Modele d'ecoulement gele",
             PRESS_EBULLITION    =SIMP(statut='o',typ='R',fr="Pression d'ebullition [corrp*psat(t)]" ),
           ),
           FROTTEMENT          =SIMP(statut='o',typ='I',into=(-4,-3,-2,-1,0,1,2,3,4,11,12,13,14),fr="Correlation de frottement [ifrot]" ),
           b_frottement        =BLOC(condition="FROTTEMENT<0",fr="Modele d'ecoulement gele",
             REYNOLDS_LIM        =SIMP(statut='o',typ='R',fr="Coefficient de Reynolds limite [relim]" ),
             FROTTEMENT_LIM      =SIMP(statut='o',typ='R',fr="Coefficient de frottement impose [frtlim]" ),
           ),

           TRANSFERT_CHAL      =SIMP(statut='o',typ='I',into=(-12,-11,-2,-1,0,1,2,11,12),fr="Transfert de chaleur [ichal]" ),
           b_transchal         =BLOC(condition="TRANSFERT_CHAL<0", fr="Cas diphasique",
             XMINCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux min [xminch]"),
             XMAXCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux max [xmaxch]"),
           ),
         ),


#      DONNEES RELATIVES A LA CONVERGENCE NUMERIQUE
#      ********************************************

         CONVERGENCE        =FACT(statut='o',min=1,max=1,
           KGTEST              =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 0.5E+0,
                                     fr="Parametre de l'algorithme iteratif [kgtest]" ),
           ITER_GLOB_MAXI      =SIMP(statut='f',typ='I',defaut= 400,
                                     fr="Nombre maximum d'iterations de la methode de Newton [itnmax]" ),
           CRIT_CONV_DEBI      =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 1.E-5,
                                     fr="Critere de convergence en debit [precdb]" ),
         ),

#      GENERAL
#      *******

         COURBES            =SIMP(statut='f',typ='TXM',into=("INTERACTIF","POSTSCRIPT","AUCUNE"),defaut="AUCUNE",
                                  fr="Generation eventuelle des courbes" ),
         LOGICIEL           =SIMP(statut='f',typ='TXM',validators=LongStr(1,255),),
         VERSION            =SIMP(statut='f',typ='TXM',into = ("3.2.1",) ),
         ENTETE             =SIMP(statut='f',typ='TXM',max='**',defaut="Titre du calcul Ecrevisse" ),
         IMPRESSION         =SIMP(statut='f',typ='TXM',defaut='NON',into=( 'OUI','NON') ),
         INFO               =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: josselin.delmas at edf.fr
def calc_erreur_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu")

CALC_ERREUR=OPER(nom="CALC_ERREUR",op=42,sd_prod=calc_erreur_prod,reentrant='f',
            UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
            fr="Compléter ou créer un résultat en calculant des champs d'erreur",
     MODELE          =SIMP(statut='f',typ=modele_sdaster),
     CHAM_MATER      =SIMP(statut='f',typ=cham_mater),

     RESULTAT        =SIMP(statut='o',typ=resultat_sdaster,
                                      fr="Résultat d'une commande globale"),

     regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                    'NOEUD_CMP','LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS'),
                    ),
     TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
     NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
     NOM_CAS         =SIMP(statut='f',typ='TXM' ),
     INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
     LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
     CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
     b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6),),
     b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
         PRECISION       =SIMP(statut='o',typ='R'),),
     LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
     TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI"),

#-----------------------------------------------------------------------
# pour conserver la compatibilité mais ne sert à rien
#-----------------------------------------------------------------------
     CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
     EXCIT           =FACT(statut='f',max='**',
                           fr="Charges contenant les températures, les efforts répartis pour les poutres...",
                           regles=(EXCLUS('FONC_MULT','COEF_MULT',),),
                    CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca),),
                    FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),),
                    COEF_MULT       =SIMP(statut='f',typ='R'),),
#-----------------------------------------------------------------------

     OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(phenomene='ERREUR',),),

     b_erre_qi =BLOC(condition = "au_moins_un(OPTION, ('QIRE_ELEM','QIZ1_ELEM','QIZ2_ELEM','QIRE_ELNO','QIRE_NOEU'))",
                     RESU_DUAL=SIMP(statut='o',typ=resultat_sdaster,fr="Résultat du problème dual"),),

     b_sing    =BLOC(condition= "au_moins_un(OPTION, 'SING_ELEM')",
                    PREC_ERR=SIMP(statut='o',typ='R',val_min= 0.,
                                  fr="Précision demandée pour calculer la carte de taille des éléments"),
                    TYPE_ESTI=SIMP(statut='f',typ='TXM',into=("ERME_ELEM","ERZ1_ELEM","ERZ2_ELEM",
                                                              "QIRE_ELEM","QIZ1_ELEM","QIZ2_ELEM",),
                                   fr="Choix de l'estimateur d'erreur"),),

#-------------------------------------------------------------------
#    Catalogue commun SOLVEUR (utilisé actuellement pour estimateur d'erreur ZZ1)
     SOLVEUR         =C_SOLVEUR('CALC_ERREUR'),
#-------------------------------------------------------------------

     INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
     TITRE           =SIMP(statut='f',typ='TXM',max='**'),
) ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

# person_in_charge: albert.alarcon at edf.fr


def calc_essai_prod(self,RESU_IDENTIFICATION,
                    RESU_MODIFSTRU,
                    **args):

    if RESU_IDENTIFICATION != None:
        for res in RESU_IDENTIFICATION:
            self.type_sdprod(res['TABLE'],interspectre)

    MTYPES = {
        'MODELE'    : modele_sdaster,
        'MODE_MECA' : mode_meca,
        'NUME_DDL'  : nume_ddl_sdaster,
        'MAILLAGE'  : maillage_sdaster,
        'MASS_MECA' : matr_asse_depl_r,
        'RIGI_MECA' : matr_asse_depl_r,
        'AMOR_MECA' : matr_asse_depl_r,
        'MACR_ELEM' : macr_elem_stat,
        'PROJ_MESU' : mode_gene,
        'BASE_ES'   : mode_meca,
        'BASE_LMME' : mode_meca,
        'MODE_STA'  : mode_meca,
              }
    if RESU_MODIFSTRU != None:
        for res in RESU_MODIFSTRU:
            for mc, typ in MTYPES.items():
                if res[mc]:
                    self.type_sdprod(res[mc], typ)
    return None


CALC_ESSAI = MACRO(nom       = 'CALC_ESSAI',
                   op        = OPS('Macro.calc_essai_ops.calc_essai_ops'),
                   sd_prod   = calc_essai_prod,
                   reentrant = 'n',
                   UIinfo    = {"groupes":("Outils-métier","Dynamique",)},
                   fr        = "Outil de post-traitement interactif pour Meidee ",
                   INTERACTIF  = SIMP( statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI' ),
                   RESU_IDENTIFICATION = FACT( statut='f',max='**',
                                               TABLE = SIMP(statut='f', typ=CO),
                                             ),
                   RESU_MODIFSTRU = FACT( statut='f', max=1,
                                          MODELE=SIMP(statut='f',typ=CO,defaut=None),
                                          MODE_MECA=SIMP(statut='f',typ=CO,defaut=None),
                                          MAILLAGE=SIMP(statut='f',typ=CO,defaut=None),
                                          NUME_DDL=SIMP(statut='f',typ=CO,defaut=None),
                                          MASS_MECA=SIMP(statut='f',typ=CO,defaut=None),
                                          RIGI_MECA=SIMP(statut='f',typ=CO,defaut=None),
                                          AMOR_MECA=SIMP(statut='f',typ=CO,defaut=None),
                                          MACR_ELEM=SIMP(statut='f',typ=CO,defaut=None),
                                          PROJ_MESU=SIMP(statut='f',typ=CO,defaut=None),
                                          BASE_ES=SIMP(statut='f',typ=CO,defaut=None),
                                          BASE_LMME=SIMP(statut='f',typ=CO,defaut=None),
                                          MODE_STA=SIMP(statut='f',typ=CO,defaut=None),
                                         ),

                   b_inter    = BLOC( condition="INTERACTIF=='NON'",

                             EXPANSION        = FACT( statut='f',max='**',
                                                      CALCUL           = SIMP(statut='o',typ=mode_meca),
                                                      NUME_MODE_CALCUL = SIMP(statut='f',typ='I',validators=NoRepeat(),
                                                                              max='**',defaut=0),
                                                      MESURE           = SIMP(statut='o',typ=mode_meca),
                                                      NUME_MODE_MESURE = SIMP(statut='f',typ='I',validators=NoRepeat(),
                                                                              max='**',defaut=0),
                                                      RESOLUTION       = SIMP(statut='f',typ='TXM',defaut='SVD',into=('SVD','LU')),
                                                      b_reso           = BLOC(condition = "RESOLUTION=='SVD'",
                                                                              EPS = SIMP(statut='f',typ='R', defaut = 0.)
                                                                       )
                                                    ),
                             IDENTIFICATION   = FACT( statut='f',max='**',
                                                      ALPHA   = SIMP(statut='f',typ='R', defaut = 0.),
                                                      EPS     = SIMP(statut='f',typ='R', defaut = 0.),
                                                      OBSERVABILITE  = SIMP(statut='o',typ=mode_meca),
                                                      COMMANDABILITE = SIMP(statut='o',typ=mode_meca),
                                                      INTE_SPEC      = SIMP(statut='o',typ=interspectre),
                                                      RESU_EXPANSION = SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON')),
                                                      BASE           = SIMP(statut='o',typ=mode_meca),
                                                     ),
                             MODIFSTRUCT = FACT( statut='f', max=1,
                                                 MESURE = SIMP(statut='o', typ=mode_meca),
                                                 MODELE_SUP = SIMP(statut='o', typ=modele_sdaster),
                                                 MATR_RIGI = SIMP(statut='o', typ=matr_asse_depl_r),
                                                 RESOLUTION = SIMP(statut='f', typ='TXM',
                                                               into=('ES', 'LMME'), defaut='ES'),
                                                 b_resol = BLOC( condition = "RESOLUTION=='LMME'",
                                                                 MATR_MASS = SIMP(statut='o', typ=matr_asse_depl_r),
                                                                ),
                                                 NUME_MODE_MESU   = SIMP(statut='o', typ='I',max='**'),
                                                 NUME_MODE_CALCUL = SIMP(statut='o', typ='I',max='**'),
                                                 MODELE_MODIF = SIMP(statut='o', typ=modele_sdaster),
                                               ),
                             # Si on realise une modification structurale, on donne les DDL capteurs et interface
                             b_modif   = BLOC( condition="MODIFSTRUCT!=None",
                                   GROUP_NO_CAPTEURS  = FACT( statut='f', max='**',
                                                              GROUP_NO = SIMP(statut='o',typ=grno,),
                                                              NOM_CMP  = SIMP(statut='o',typ='TXM', max='**'),
                                                            ),
                                   GROUP_NO_EXTERIEUR = FACT( statut='f', max='**',
                                                              GROUP_NO = SIMP(statut='o',typ=grno,),
                                                              NOM_CMP  = SIMP(statut='o',typ='TXM', max='**'),
                                                            ),
                                               ),
                                          ),
                        );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: sam.cuvilliez at edf.fr

def calc_essai_geomeca_prod(self,                            
                            ESSAI_TD,
                            ESSAI_TND,
                            ESSAI_CISA_C,
                            ESSAI_TND_C,
                            #ESSAI_XXX,
                            **args):
  List_essais = []
  if ESSAI_TD     != None : List_essais += ESSAI_TD.List_F()
  if ESSAI_TND    != None : List_essais += ESSAI_TND.List_F()
  if ESSAI_CISA_C != None : List_essais += ESSAI_CISA_C.List_F()
  if ESSAI_TND_C  != None : List_essais += ESSAI_TND_C.List_F()
  #if ESSAI_XXX    != None : List_essais += ESSAI_XXX.List_F()
  for DicoEssai in List_essais :
    if DicoEssai.has_key('TABLE_RESU'): 
      for Table in DicoEssai['TABLE_RESU']:
        self.type_sdprod(Table,table_sdaster)
  return None 


CALC_ESSAI_GEOMECA = MACRO(nom="CALC_ESSAI_GEOMECA",
                     op=OPS('Macro.calc_essai_geomeca_ops.calc_essai_geomeca_ops'),
                     sd_prod=calc_essai_geomeca_prod,
                     UIinfo={"groupes":("",)},
                     reentrant='n',
                     fr="",
                     MATER       = SIMP(statut='o',typ=mater_sdaster),
                     COMPORTEMENT   = C_COMPORTEMENT(),
                     CONVERGENCE = C_CONVERGENCE(),
                     regles=(AU_MOINS_UN('COMPORTEMENT'), # car COMPORTEMENT est facultatif dans C_COMPORTEMENT
                             AU_MOINS_UN(
                                         'ESSAI_TD'    ,
                                         'ESSAI_TND'   ,
                                         'ESSAI_CISA_C',
                                         'ESSAI_TND_C' ,
                                         #'ESSAI_XXX'   ,
                                         ),),
                     # ---
                     # Essai Triaxial Monotone Draine ('TD')
                     # ---
                     ESSAI_TD = FACT(statut='f',max='**',
 
                          PRES_CONF   = SIMP(statut='o',typ='R',max='**',),
                          EPSI_IMPOSE = SIMP(statut='o',typ='R',max='**',),
                          NB_INST     = SIMP(statut='f',typ='I',val_min=100,defaut=100),

                          TABLE_RESU  = SIMP(statut='f',typ=CO,max='**',validators=NoRepeat(),),
                          GRAPHIQUE   = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                             into=  ('P-Q','EPS_AXI-Q','EPS_AXI-EPS_VOL',),
                                             defaut=('P-Q','EPS_AXI-Q','EPS_AXI-EPS_VOL',),),
                          TABLE_REF   = SIMP(statut='f',typ=table_sdaster,max='**',),

                                      ),

                     # ---
                     #  Essai Triaxial Monotone Non Draine ('TND')
                     # ---
                     ESSAI_TND = FACT(statut='f',max='**',
 
                          PRES_CONF   = SIMP(statut='o',typ='R',max='**',),
                          EPSI_IMPOSE = SIMP(statut='o',typ='R',max='**',),
                          BIOT_COEF   = SIMP(statut='f',typ='R',defaut=1.,),
                          NB_INST     = SIMP(statut='f',typ='I',val_min=100,defaut=100),

                          TABLE_RESU  = SIMP(statut='f',typ=CO,max='**',validators=NoRepeat(),),
                          GRAPHIQUE   = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                             into=  ('P-Q','EPS_AXI-Q','EPS_AXI-PRE_EAU',),
                                             defaut=('P-Q','EPS_AXI-Q','EPS_AXI-PRE_EAU',),),
                          TABLE_REF   = SIMP(statut='f',typ=table_sdaster,max='**',),

                                      ),

                     # ---
                     #  Essai de Cisaillement Cyclique Draine ('CISA_C')
                     # ---
                     ESSAI_CISA_C = FACT(statut='f',max='**',
 
                          PRES_CONF   = SIMP(statut='o',typ='R',max='**',),
                          EPSI_IMPOSE = SIMP(statut='o',typ='R',max='**',),
                          EPSI_ELAS   = SIMP(statut='f',typ='R',defaut=1.E-7,val_max=1.E-7),
                          NB_CYCLE    = SIMP(statut='o',typ='I',val_min=1),
                          NB_INST     = SIMP(statut='f',typ='I',val_min=25,defaut=25),

                          TABLE_RESU  = SIMP(statut='f',typ=CO,max='**',validators=NoRepeat(),),
                          GRAPHIQUE   = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                             into=  ('EPSXY-SIGXY','EPSXY-G','EPSXY-D',),
                                             defaut=('EPSXY-SIGXY','EPSXY-G','EPSXY-D',),),
                          TABLE_REF   = SIMP(statut='f',typ=table_sdaster,max='**',),

                                      ),

                     # ---
                     #  Essai Triaxial Non Draine Cyclique ('TND_C')
                     # ---
                     ESSAI_TND_C = FACT(statut='f',max='**',
 
                          PRES_CONF   = SIMP(statut='o',typ='R',max='**',),
                          SIGM_IMPOSE = SIMP(statut='o',typ='R',max='**',),
                          BIOT_COEF   = SIMP(statut='f',typ='R',defaut=1.,),
                          UN_SUR_K    = SIMP(statut='o',typ='R',),
                          NB_CYCLE    = SIMP(statut='o',typ='I',val_min=1),
                          NB_INST     = SIMP(statut='f',typ='I',val_min=25,defaut=25),

                          TABLE_RESU  = SIMP(statut='f',typ=CO,max='**',validators=NoRepeat(),),
                          GRAPHIQUE   = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                             into=  ('NCYCL-DSIGM','P-Q','SIG_AXI-PRE_EAU',),
                                             defaut=('NCYCL-DSIGM','P-Q','SIG_AXI-PRE_EAU',),),
                          TABLE_REF   = SIMP(statut='f',typ=table_sdaster,max='**',),

                                      ),

                     # ---
                     #  Essai ... ('XXX')
                     # ---
                     #ESSAI_XXX = FACT(statut='f',max='**',
                     #
                     #     PRES_CONF  = SIMP(statut='o',typ='R',max='**',),
                     #     ...
                     #
                     #     TABLE_RESU = SIMP(statut='f',typ=CO,max='**',validators=NoRepeat(),),
                     #     GRAPHIQUE  = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                     #                        into=  ('XXX','XXX','XXX',),
                     #                        defaut=('XXX','XXX','XXX',),),
                     #     TABLE_REF  = SIMP(statut='f',typ=table_sdaster,max='**',),
                     #
                     #                 ),

                    INFO = SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr

def calc_europlexus_prod(self,COURBE=None,**args):
  if COURBE is not None:
      self.type_sdprod(args['TABLE_COURBE'],table_sdaster)
  return evol_noli

CALC_EUROPLEXUS = MACRO(nom="CALC_EUROPLEXUS",
                        op=OPS('Macro.calc_europlexus_ops.calc_europlexus_ops'),
                        sd_prod=calc_europlexus_prod,
                        reentrant='n',
                        UIinfo={"groupes":("Outils-métier","Dynamique",)},
                        fr="Chainage Code_Aster-Europlexus",
                        regles=(PRESENT_ABSENT('ETAT_INIT','MODELE'),
                                PRESENT_ABSENT('ETAT_INIT','CARA_ELEM'),
                                PRESENT_ABSENT('ETAT_INIT','CHAM_MATER'),
                                EXCLUS('ETAT_INIT','FONC_PARASOL'),
                                AU_MOINS_UN('COMPORTEMENT'),),
        LOGICIEL = SIMP(statut='f', typ='TXM', defaut='/home/europlex/EPXD/bin/europlexus'),
        LANCEMENT = SIMP(statut='f', typ='TXM', defaut='OUI',into=('OUI','NON')),

        ETAT_INIT = FACT(statut='f',
           RESULTAT    = SIMP(statut='o',typ=evol_noli),
           CONTRAINTE = SIMP(statut='f', typ='TXM', defaut='NON',into=('OUI','NON')),
           EQUILIBRE  = SIMP(statut='f', typ='TXM', defaut='OUI',into=('OUI','NON')),
           b_niter          =BLOC(condition = "CONTRAINTE == 'NON' ",
                                 NITER = SIMP(statut='f',typ='I',defaut=1),
                                 ),
        ),
        MODELE     = SIMP(statut='f',typ=modele_sdaster),
        CARA_ELEM  = SIMP(statut='f',typ=cara_elem),

        FONC_PARASOL = FACT(statut='f',
           regles=(PRESENT_PRESENT('NFKT','NFKR'),),
           NFKT       = SIMP(statut='f',typ=(fonction_sdaster,)),
           NFKR       = SIMP(statut='f',typ=(fonction_sdaster,)),
           NFAT       = SIMP(statut='f',typ=(fonction_sdaster,)),
           NFAR       = SIMP(statut='f',typ=(fonction_sdaster,)),
           GROUP_MA   = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ),


        CHAM_MATER = SIMP(statut='f',typ=cham_mater),
        COMPORTEMENT  =C_COMPORTEMENT('CALC_EUROPLEXUS'),

        EXCIT      = FACT(statut='o',max='**',
           CHARGE         = SIMP(statut='o',typ=(char_meca,)),
           FONC_MULT      = SIMP(statut='f',typ=(fonction_sdaster,)),
          ),

        DIME = FACT(statut='f', regles=(AU_MOINS_UN('UNITE_DIME','Q4GS','FORCE',
                                                    'PT6L','ZONE','POUT','ECRO',
                                                    'APPU','BLOQ','PRESS','PMAT',
                                                    'DKT3','DEPL','FNOM','TABLE','FTAB',
                                                    'MTTI','NEPE','LIAI',), ),
           UNITE_DIME=SIMP(statut='f',typ='I'),

           Q4GS  = SIMP(statut='f',typ='I'),
           FORCE = SIMP(statut='f',typ='I'),
           PT6L  = SIMP(statut='f',typ='I'),
           ZONE  = SIMP(statut='f',typ='I'),
           POUT  = SIMP(statut='f',typ='I'),
           ECRO  = SIMP(statut='f',typ='I'),
           APPU  = SIMP(statut='f',typ='I'),
           BLOQ  = SIMP(statut='f',typ='I'),
           PRESS = SIMP(statut='f',typ='I',min=2,max=2,),
           PMAT  = SIMP(statut='f',typ='I'),
           DKT3  = SIMP(statut='f',typ='I'),
           DEPL  = SIMP(statut='f',typ='I'),
           FNOM  = SIMP(statut='f',typ='I'),
           TABLE = SIMP(statut='f',typ='I',min=2,max=2,),
           FTAB  = SIMP(statut='f',typ='I'),
           MTTI  = SIMP(statut='f',typ='I'),
           NEPE  = SIMP(statut='f',typ='I'),
           LIAI  = SIMP(statut='f',typ='I'),
             ),

        CALCUL = FACT(statut='o',
           TYPE_DISCRETISATION  = SIMP(statut='o',typ='TXM',defaut='AUTO',into=('AUTO','UTIL')),
           INST_FIN             = SIMP(statut='o',typ='R'),
           INST_INIT            = SIMP(statut='o',typ='R'),
           NMAX                 = SIMP(statut='f',typ='R'),

           b_auto =BLOC( condition = "TYPE_DISCRETISATION=='AUTO'",
              CSTAB  = SIMP(statut='o',typ='R',defaut=0.3),
#              DTMAX  = SIMP(statut='f',typ='R'),
                       ),

           b_util =BLOC( condition = "TYPE_DISCRETISATION=='UTIL'",
              PASFIX   = SIMP(statut='o',typ='R'),
                       ),
           ),


        OBSERVATION     =FACT(statut='f',max='**',
           SUIVI_DDL       = SIMP(statut='o',typ='TXM',defaut="OUI",max=1,into=("OUI","NON")),
        b_suivi          =BLOC(condition = "SUIVI_DDL == 'OUI' ",
                               regles=( AU_MOINS_UN('PAS_NBRE','PAS_INST',),
                                        EXCLUS('PAS_NBRE','PAS_INST',),
                                        EXCLUS('GROUP_NO','TOUT_GROUP_NO',),
                                        EXCLUS('GROUP_MA','TOUT_GROUP_MA',), ),
           NOM_CHAM        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',defaut=('DEPL',),into=('DEPL'
                                         ,'VITE','ACCE','SIEF_ELGA','EPSI_ELGA','VARI_ELGA'),),
           PAS_INST        = SIMP(statut='f',typ='R'),
           PAS_NBRE        = SIMP(statut='f',typ='I'),
           GROUP_NO        = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           GROUP_MA        = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT_GROUP_NO   = SIMP(statut='f',typ='TXM',into=('OUI',),),
           TOUT_GROUP_MA   = SIMP(statut='f',typ='TXM',into=('OUI',),),
                             ),
        ),


        ARCHIVAGE        =FACT(statut='o', regles=( AU_MOINS_UN('PAS_NBRE','PAS_INST',), EXCLUS('PAS_NBRE','PAS_INST',), ),
           PAS_INST     = SIMP(statut='f',typ='R'),
           PAS_NBRE     = SIMP(statut='f',typ='I'),
           CONT_GENER   = SIMP(statut='o',typ='TXM',defaut="OUI",max=1,into=("OUI","NON")),
                             ),
        COURBE  =  FACT(statut='f',max='**', regles=(EXCLUS('GROUP_NO','GROUP_MA')),
           UNITE_ALIT = SIMP(statut='f',typ='I'),
            NOM_CHAM   = SIMP(statut='f',typ='TXM'),
            NOM_CMP    = SIMP(statut='f',typ='TXM'),
#             NOEUD      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
#             MAILLE     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
            GROUP_NO   = SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
            GROUP_MA   = SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1),

            b_maille = BLOC(condition = "GROUP_MA != None", regles=(AU_MOINS_UN('NUM_GAUSS')),
              NUM_GAUSS = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),),
         ),
        b_courbe = BLOC(condition = "COURBE != None",
                        regles=(AU_MOINS_UN('PAS_NBRE_COURBE','PAS_INST_COURBE',),
                                AU_MOINS_UN('TABLE_COURBE',)),
          PAS_INST_COURBE      = SIMP(statut='f',typ='R'),
          PAS_NBRE_COURBE       = SIMP(statut='f',typ='I'),
                  TABLE_COURBE      = SIMP(statut='f', typ=CO),
          ),
        DOMAINES = FACT(statut='f',max='**',
             GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             IDENTIFIANT =  SIMP(statut='f',typ='I'),),
        INTERFACES = FACT(statut='f',max='**',
             GROUP_MA_1 = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             GROUP_MA_2 = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             TOLE        =  SIMP(statut='f',typ='R'),
             IDENT_DOMAINE_1  = SIMP(statut='f',typ='I'),
             IDENT_DOMAINE_2  = SIMP(statut='f',typ='I'),),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=( 1, 2 ) ),
        ) ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: van-xuan.tran at edf.fr
def calc_fatigue_prod(TYPE_CALCUL,OPTION,**args):
  if TYPE_CALCUL == "CUMUL_DOMMAGE" : return cham_elem
  if TYPE_CALCUL == "FATIGUE_MULTI" and OPTION == "DOMA_ELGA": return cham_elem
  if TYPE_CALCUL == "FATIGUE_MULTI" and OPTION == "DOMA_NOEUD": return cham_no_sdaster
  if TYPE_CALCUL == "FATIGUE_VIBR" : return cham_elem
  raise AsException("type de calcul non prevu")

CALC_FATIGUE=OPER(nom="CALC_FATIGUE",op= 151,sd_prod=calc_fatigue_prod,reentrant='n',
                  fr="Calculer un champ de dommage de fatigue subit par une structure et déterminer le plan critique"
                      +" dans lequel le cisaillement est maximal.",
            UIinfo={"groupes":("Post-traitements","Rupture",)},

         TYPE_CALCUL = SIMP(statut='o',typ='TXM',
                               into=("CUMUL_DOMMAGE","FATIGUE_MULTI","FATIGUE_VIBR") ),

         b_cumul_domma   =BLOC(condition = "TYPE_CALCUL == 'CUMUL_DOMMAGE'",
                               fr="Calcul d un champ de dommage subi par une structure.",
           regles=(PRESENT_PRESENT('DOMMAGE','MATER', ),),
           OPTION          =SIMP(statut='o',typ='TXM',
                                 into=("DOMA_ELNO_SIGM","DOMA_ELGA_SIGM",
                                       "DOMA_ELNO_EPSI","DOMA_ELGA_EPSI",
                                       "DOMA_ELNO_EPME","DOMA_ELGA_EPME") ),

             b_sigm   =BLOC(condition = "OPTION == 'DOMA_ELNO_SIGM' or OPTION == 'DOMA_ELGA_SIGM'",
                               fr="Calcul a partir d un champ de contraintes.",
               HISTOIRE        =FACT(statut='o',
               RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,
                                                   evol_noli) ),
               EQUI_GD         =SIMP(statut='f',typ='TXM',defaut="VMIS_SG",
                                 into=("VMIS_SG",) ),
                                   ),
                           ),
             b_epsi   =BLOC(condition = "OPTION != 'DOMA_ELNO_SIGM' and OPTION != 'DOMA_ELGA_SIGM'",
                               fr="Calcul a partir d un champ de déformations.",
               HISTOIRE        =FACT(statut='o',
               RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,
                                                   evol_noli) ),
               EQUI_GD         =SIMP(statut='o',typ='TXM',defaut="INVA_2_SG",
                                 into=("INVA_2_SG",) ),
                                    ),
                           ),
           DOMMAGE         =SIMP(statut='o',typ='TXM',
                               into=("WOHLER","MANSOP_COFFIN","TAHERI_MANSON",
                                     "TAHERI_MIXTE",) ),
           MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
           TAHERI_NAPPE    =SIMP(statut='f',typ=(nappe_sdaster,formule) ),
           TAHERI_FONC     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         b_domma_moda   =BLOC(condition = "TYPE_CALCUL == 'FATIGUE_VIBR'",
                               fr="Calcul d un champ de dommage en dynamique vibratoire",
           regles=(PRESENT_PRESENT('DOMMAGE','MATER', ),),
           OPTION          =SIMP(statut='o',typ='TXM',
                                 into=("DOMA_ELNO_SIGM","DOMA_ELGA_SIGM",) ),
           CORR_SIGM_MOYE = SIMP(statut='o',typ='TXM',into=("GOODMAN","GERBER")),
           HISTOIRE        =FACT(statut='o',
             RESULTAT  =SIMP(statut='o',typ=(evol_elas, evol_noli) ),
             MODE_MECA        =SIMP(statut='o',typ=(mode_meca) ),
             NUME_MODE        =SIMP(statut='o',typ='I',min=1 ,max='**'),
             FACT_PARTICI        =SIMP(statut='o',typ='R',min=1, max='**',defaut=1. ),
             EQUI_GD         =SIMP(statut='f',typ='TXM',defaut="VMIS_SG",
                                 into=("VMIS_SG",) ),
           ),
           DOMMAGE         =SIMP(statut='o',typ='TXM',
                               into=("WOHLER",) ),
           MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
         ),

         b_fatigue_multi   =BLOC(condition = "TYPE_CALCUL == 'FATIGUE_MULTI'",
                                 fr="Plan critique dans le cas de la fatigue multiaxiale à grand nombre de cycles.",
           TYPE_CHARGE   =SIMP(statut='o',typ='TXM',into=("PERIODIQUE","NON_PERIODIQUE") ),
           OPTION        =SIMP(statut='o',typ='TXM',into=("DOMA_ELGA","DOMA_NOEUD") ),
           RESULTAT      =SIMP(statut='o',typ=(evol_elas, evol_noli) ),
           CHAM_MATER    =SIMP(statut='f',typ=(cham_mater) ),
           MAILLAGE      =SIMP(statut='o',typ=maillage_sdaster ),
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_MA      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**' ),
           MAILLE        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**' ),
           GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**' ),
           NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**' ),
           COEF_PREECROU =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           b_period       =BLOC(condition = "TYPE_CHARGE == 'PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',into=("MATAKE_MODI_AC",
                                                              "DANG_VAN_MODI_AC","VMIS_TRESCA","FORMULE_CRITERE") ),
               b_fati_p  =BLOC(condition = "(CRITERE == 'MATAKE_MODI_AC' or CRITERE == 'DANG_VAN_MODI_AC')",
                   METHODE       =SIMP(statut='o',typ='TXM',into=("CERCLE_EXACT",) ),
               ),
               
               b_fati_pf  =BLOC(condition = "(CRITERE == 'FORMULE_CRITERE')",
                   FORMULE_GRDEQ   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                   COURBE_GRD_VIE  = SIMP(statut='o',typ='TXM',into=("WOHLER","MANSON_C","FORM_VIE") ),
                   FORMULE_CRITIQUE = SIMP(statut='f',typ=(fonction_sdaster,formule) ),
                   b_fati_pfvie  = BLOC(condition = "(COURBE_GRD_VIE == 'FORM_VIE')",
                        FORMULE_VIE   =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                  ),
               ),

               INST_INIT_CYCL =SIMP(statut='f',typ='R',min=1, max=1),
               INST_CRIT      =SIMP(statut='f',typ='TXM',into=("RELATIF","ABSOLU",) ),
               regles=(PRESENT_PRESENT('INST_INIT_CYCL','INST_CRIT', ),),
                  b_prec_rela=BLOC(condition="(INST_CRIT=='RELATIF')",
                        PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6),),
                  b_prec_abso=BLOC(condition="(INST_CRIT=='ABSOLU')",
                        PRECISION       =SIMP(statut='o',typ='R'),),
           ),
           b_non_period   =BLOC(condition = "TYPE_CHARGE == 'NON_PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',
                                   into=("MATAKE_MODI_AV","DANG_VAN_MODI_AV","FATESOCI_MODI_AV","FORMULE_CRITERE","VMIS_TRESCA") ),
               b_fati_np  =BLOC(condition =
                               "(CRITERE != 'VMIS_TRESCA')",
                   PROJECTION    =SIMP(statut='o',typ='TXM',into=("UN_AXE", "DEUX_AXES") ),
                   DELTA_OSCI    =SIMP(statut='f',typ='R',defaut= 0.0E+0),
               ),
               b_fati_npf  =BLOC(condition = "(CRITERE == 'FORMULE_CRITERE')",
                   FORMULE_GRDEQ   =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                   COURBE_GRD_VIE  = SIMP(statut='o',typ='TXM',into=("WOHLER","MANSON_C","FORM_VIE") ),
                   b_fati_npfvie  = BLOC(condition = "(COURBE_GRD_VIE == 'FORM_VIE')",
                        FORMULE_VIE   =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                  ),
               ),
           ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def calc_ferraillage_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu")


CALC_FERRAILLAGE=OPER(nom="CALC_FERRAILLAGE",op=175,sd_prod=calc_ferraillage_prod, reentrant='o',
            UIinfo={"groupes":("Post-traitements","Outils-métier",)},
                 fr="calcul de cartes de densité de ferraillage ",

         RESULTAT        =SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans,) ),


#====
# Sélection des numéros d'ordre pour lesquels on fait le calcul :
#====
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

         b_acce_reel     =BLOC(condition="(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
            CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
            b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
            b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),


#
#====
# Définition des grandeurs caractéristiques
#====
#
         TYPE_COMB    =SIMP(statut='o',typ='TXM',into=('ELU','ELS')),

#        mot clé facteur répétable pour assigner les caractéristiques locales par zones topologiques (GROUP_MA)
         AFFE  =FACT(statut='o',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE     =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           ENROBG     =SIMP(statut='o',typ='R'), # enrobage
           CEQUI      =SIMP(statut='f',typ='R'), # coefficient d'équivalence acier/béton  (pour ELS)
           SIGM_ACIER =SIMP(statut='o',typ='R'), # contrainte admissible dans l'acier
           SIGM_BETON =SIMP(statut='o',typ='R'), # contrainte admissible dans le béton
           PIVA       =SIMP(statut='f',typ='R'), # valeur du pivot a  (pour ELU)
           PIVB       =SIMP(statut='f',typ='R'), # valeur du pivot b  (pour ELU)
           ES         =SIMP(statut='f',typ='R'), # valeur du Module d'Young de l'acier (pour ELU)
           ),
      )


##############################################################################################################
# Remarques :
#-----------
#        l'épaisseur des coques sera récupérée automatiquement
#        via le cara_elem sous-jacent au résultat

# Le résultat produit est un champ constant par éléments associé à la grandeur FER2_R
# qui comporte les composantes :
#
#     DNSXI  densité d'acier longitudinal suivant X, peau inf
#     DNSXS  densité d'acier longitudinal suivant X, peau sup
#     DNSYI  densité d'acier longitudinal suivant Y, peau inf
#     DNSYS  densité d'acier longitudinal suivant Y, peau sup
#     DNST   densité d'acier transversal à l'ELU
#     SIGMBE contrainte beton
#     EPSIBE deformation béton

# arrêt en erreur si:
# - EFGE_ELNO n'a pas été précédemment calculé et n'est donc pas présent dans la structure de données RESULTAT
# - si aucun CARA_ELEM n'est récupérable via la structure de données RESULTAT

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
CALC_FLUI_STRU=OPER(nom="CALC_FLUI_STRU",op= 144,sd_prod=melasflu_sdaster,
                    reentrant='n',
                    fr="Calculer les paramètres modaux d'une structure soumise à un écoulement",
            UIinfo={"groupes":("Matrices et vecteurs",)},
         VITE_FLUI       =FACT(statut='f',
                               fr="Définir la plage de vitesse fluide étudiée",
           VITE_MIN        =SIMP(statut='f',typ='R' ),
           VITE_MAX        =SIMP(statut='f',typ='R' ),
           NB_POIN         =SIMP(statut='f',typ='I' ),
         ),
         BASE_MODALE     =FACT(statut='o',

           regles=(AU_MOINS_UN('AMOR_REDUIT','AMOR_UNIF','AMOR_REDUIT_CONN'),),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',max='**'),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**',val_min=0.E+00),
           AMOR_UNIF       =SIMP(statut='f',typ='R',val_min=0.E+00 ),
           AMOR_REDUIT_CONN=SIMP(statut='f',typ='R',max='**',val_min=0.E+00),
         ),
         TYPE_FLUI_STRU  =SIMP(statut='o',typ=type_flui_stru ),
         IMPRESSION      =FACT(statut='f',
                               fr="Choix des informations à imprimer dans le fichier RESULTAT",
           PARA_COUPLAGE   =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           DEFORMEE        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def calc_fonc_interp_prod(FONCTION, NOM_PARA_FONC, **args):
   if   AsType(FONCTION) == nappe_sdaster:
      return nappe_sdaster
   elif AsType(FONCTION) == fonction_sdaster:
      return fonction_sdaster
   elif AsType(FONCTION) == fonction_c:
      return fonction_c
   elif AsType(FONCTION) == formule_c:
      return fonction_c
   elif AsType(FONCTION) == formule:
      if NOM_PARA_FONC != None:
         return nappe_sdaster
      return fonction_sdaster
   raise AsException("type de concept resultat non prevu")

CALC_FONC_INTERP=OPER(nom="CALC_FONC_INTERP",op= 134,sd_prod=calc_fonc_interp_prod,
                      docu="U4.32.01",reentrant='n',
           fr="Définit une fonction (ou une nappe) à partir d'une fonction FORMULE à 1 ou 2 variables",
           UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('VALE_PARA','LIST_PARA'),),
         FONCTION        =SIMP(statut='o',typ=(formule,fonction_sdaster,nappe_sdaster,fonction_c) ),
         VALE_PARA       =SIMP(statut='f',typ='R',max='**'),
         LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
         NOM_RESU        =SIMP(statut='f',typ='TXM'),
         NOM_PARA        =SIMP(statut='f',typ='TXM'),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM'),
         b_eval_nappe    =BLOC(condition = "NOM_PARA_FONC != None",
            regles=(UN_PARMI('VALE_PARA_FONC','LIST_PARA_FONC'),),
            VALE_PARA_FONC  =SIMP(statut='f',typ='R',max='**'),
            LIST_PARA_FONC  =SIMP(statut='f',typ=listr8_sdaster ),
            INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG")),
            PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
            PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def calc_fonction_prod(self, DERIVE, EXTRACTION, INTEGRE, INVERSE, COMB, COMB_C, MULT,
                       ENVELOPPE, FRACTILE, SPEC_OSCI, ASSE, FFT, COMPOSE, CORR_ACCE,
                       PUISSANCE, LISS_ENVELOP, ABS, REGR_POLYNOMIALE, DSP, **args):

   if (INTEGRE     != None): return fonction_sdaster
   if (DERIVE      != None): return fonction_sdaster
   if (INVERSE     != None): return fonction_sdaster
   if (COMB        != None):
      type_vale=AsType(COMB[0]['FONCTION'])
      for mcfact in COMB :
          if(AsType(mcfact['FONCTION'])!=type_vale):
             raise AsException("CALC_FONCTION/COMB : pas de types hétérogènes nappe/fonction")
      return type_vale
   if (COMB_C      != None):
      vale=COMB_C[0]['FONCTION']
      if(AsType(vale) == nappe_sdaster):
         for mcfact in COMB_C[1:] :
             if(AsType(mcfact['FONCTION'])!=nappe_sdaster):
                raise AsException("CALC_FONCTION/COMB_C : pas de types hétérogènes nappe/fonction")
         return nappe_sdaster
      else:
         for mcfact in COMB_C :
             if(AsType(mcfact['FONCTION'])==nappe_sdaster):
                raise AsException("CALC_FONCTION/COMB_C : pas de types hétérogènes nappe/fonction")
         return fonction_c
   if (ENVELOPPE   != None): return AsType(ENVELOPPE[0]['FONCTION'])
   if (FRACTILE    != None): return AsType(FRACTILE[0] ['FONCTION'])
   if (EXTRACTION  != None): return fonction_sdaster
   if (SPEC_OSCI   != None): return nappe_sdaster
   if (DSP         != None): return fonction_sdaster
   if (COMPOSE     != None): return fonction_sdaster
   if (ASSE        != None): return fonction_sdaster
   if (MULT        != None):
      type_vale = AsType(MULT[0]['FONCTION'])
      for mcfact in MULT:
          if(AsType(mcfact['FONCTION']) != type_vale):
             raise AsException("CALC_FONCTION/MULT : pas de types hétérogènes nappe/fonction")
      return type_vale
   if (FFT         != None):
      vale=FFT[0]['FONCTION']
      if (AsType(vale) == fonction_sdaster )  : return fonction_c
      if (AsType(vale) == fonction_c) : return fonction_sdaster
   if (CORR_ACCE   != None): return fonction_sdaster
   if (LISS_ENVELOP!= None): return nappe_sdaster
   if (REGR_POLYNOMIALE != None): return fonction_sdaster
   if (PUISSANCE   != None): return AsType(PUISSANCE[0]['FONCTION'])
   if (ABS         != None): return fonction_sdaster
   raise AsException("type de concept resultat non prevu")


CALC_FONCTION=MACRO(nom="CALC_FONCTION",
                    op=OPS('Macro.calc_fonction_ops.calc_fonction_ops'),
                    sd_prod=calc_fonction_prod,
                    fr="Effectue des opérations mathématiques sur des concepts de type fonction",
                    reentrant='n',
                    UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('DERIVE', 'INTEGRE', 'SPEC_OSCI', 'DSP', 'FFT', 'CORR_ACCE',
                          'COMB', 'COMB_C', 'MULT', 'ASSE', 'INVERSE', 'ABS',
                          'ENVELOPPE', 'COMPOSE', 'EXTRACTION', 'PUISSANCE', 
                          'LISS_ENVELOP', 'FRACTILE', 'REGR_POLYNOMIALE'),),
         FFT             =FACT(statut='f',fr="Transformée de Fourier ou de son inverse",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c) ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="PROL_ZERO",into=("PROL_ZERO","TRONCATURE","COMPLET") ),
           b_syme          =BLOC ( condition = " AsType(FONCTION)==fonction_c ",
             SYME           =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI' ),
           ),
         ),
         DERIVE          =FACT(statut='f',fr="Dérivée d une fonction",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="DIFF_CENTREE",into=("DIFF_CENTREE",) ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
         ),
         INTEGRE         =FACT(statut='f',fr="Intégrale d'une fonction",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster),
           COEF            =SIMP(statut='f',typ='R',defaut= 0.E+0,fr="Valeur de la constante d intégration" ),
         ),
         LISS_ENVELOP    = FACT(statut='f',fr="Lissage d une enveloppe",
           NAPPE           =SIMP(statut='o',typ=nappe_sdaster ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut =0.2),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut =35.5),
           ELARG           =SIMP(statut='f',typ='R',defaut =0.1 ),
           TOLE_LISS       =SIMP(statut='f',typ='R',defaut =0.25 ),
         ),
         REGR_POLYNOMIALE = FACT(statut='f',fr="Régression polynomiale d'une fonction",
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster),
           DEGRE           =SIMP(statut='o',typ='I'),
         ),
        SPEC_OSCI       =FACT(statut='f',fr="Spectre d'oscillateur",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="NIGAM",into=("NIGAM","HARMO","RICE") ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',  max='**'),
           NORME           =SIMP(statut='o',typ='R',fr="Valeur de la norme du spectre d oscillateur" ),
           NATURE          =SIMP(statut='f',typ='TXM',defaut="ACCE",into=("DEPL","VITE","ACCE") ),
           b_methode       =BLOC(condition = "METHODE !='RICE' ",
             NATURE_FONC     =SIMP(statut='f', typ='TXM', defaut="ACCE", into=("ACCE",),),),
           b_rice          =BLOC(condition = "METHODE =='RICE' ",
             DUREE           =SIMP(statut='o', typ='R', val_min=0.,
                                 fr="durée de la phase forte pour facteur de pic"),
             NATURE_FONC     =SIMP(statut='f', typ='TXM', defaut="DSP", into=("DSP",),),),
         ),
         DSP             =FACT(statut='f', fr="Densité spectrale",
           FONCTION        =SIMP(statut='o', typ=fonction_sdaster ),
           AMOR_REDUIT     =SIMP(statut='o', typ='R', val_min=0., val_max=1.),
           NORME           =SIMP(statut='o', typ='R'),
           LIST_FREQ       =SIMP(statut='f', typ=listr8_sdaster ),
           FREQ_PAS            =SIMP(statut='f', typ='R'),
                regles=(UN_PARMI('FREQ_PAS','LIST_FREQ'),),
           FREQ_COUP       =SIMP(statut='o', typ='R', fr="fréquence de coupure" ),
           DUREE           =SIMP(statut='o', typ='R', val_min=0.,
                                 fr="durée de la phase forte pour facteur de peak"),
           FRACT           =SIMP(statut='o', typ='R', defaut=0.5, val_min=0., val_max=1., fr="fractile" ),
         ),
         ABS             =FACT(statut='f',fr="Valeur absolue d'une fonction",
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster,),
         ),
         COMB            =FACT(statut='f',max='**',fr="Combinaison linéaire réelle de fonctions",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster) ),
           COEF            =SIMP(statut='o',typ='R',fr="Coefficient réel de la combinaison linéaire associée à la fonction" ),
         ),
         COMB_C          =FACT(statut='f',max='**',fr="Combinaison linéaire complexe de fonctions",
           regles=(UN_PARMI('COEF_R','COEF_C'),),
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster) ),
           COEF_R          =SIMP(statut='f',typ='R',fr="Coefficient réel de la combinaison linéaire associée à la fonction" ),
           COEF_C          =SIMP(statut='f',typ='C',fr="Coefficient complexe de la combinaison linéaire associée à la fonction" ),
         ),
         MULT            =FACT(statut='f',max='**',fr="Produit de fonctions réelles",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster) ),
         ),
         b_comb          =BLOC ( condition = "COMB != None or COMB_C != None " \
                                             "or REGR_POLYNOMIALE != None or MULT != None",
             LIST_PARA      =SIMP(statut='f',typ=listr8_sdaster ),
         ),
         COMPOSE         =FACT(statut='f',fr="Composition de deux fonctions FONC_RESU(FONC_PARA)",
           FONC_RESU       =SIMP(statut='o',typ=fonction_sdaster),
           FONC_PARA       =SIMP(statut='o',typ=fonction_sdaster),
         ),
         EXTRACTION      =FACT(statut='f',fr="Extraction sur une fonction complexe",
           FONCTION        =SIMP(statut='o',typ=fonction_c),
           PARTIE          =SIMP(statut='o',typ='TXM',into=("REEL","IMAG","MODULE","PHASE"),fr="Partie à extraire"),
         ),
         ENVELOPPE       =FACT(statut='f',fr="Enveloppe d une famille de fonctions",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),max='**' ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="SUP",into=("SUP","INF"),fr="Type de l enveloppe" ),
         ),
         FRACTILE        =FACT(statut='f',fr="Fractile d une famille de fonctions ou de nappes",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),max='**' ),
           FRACT           =SIMP(statut='o',typ='R',defaut=1.,val_min=0.,val_max=1.,fr="Valeur du fractile" ),
         ),
         ASSE            =FACT(statut='f',fr="Concatenation de fonctions",
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster,min=2,max=2 ),
           SURCHARGE       =SIMP(statut='f',typ='TXM',defaut="DROITE",into=("DROITE","GAUCHE")),
         ),
         CORR_ACCE       =FACT(statut='f',fr="Correction d un accelerogramme reel",
            CORR_DEPL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
            FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
         ),
         PUISSANCE       =FACT(statut='f',fr="Fonction élevée à une puissance",
            FONCTION      =SIMP(statut='o', typ=(fonction_sdaster,nappe_sdaster) ),
            EXPOSANT      =SIMP(statut='f', typ='I', defaut=1 ),
         ),
         INVERSE         =FACT(statut='f',fr="Inverse d'une fonction",
            FONCTION      =SIMP(statut='o', typ=fonction_sdaster),
         ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG"),
                               fr="Type d'interpolation pour les abscisses et les ordonnées de la " \
                                  "fonction ou bien pour le paramètre de la nappe."),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM',into=C_PARA_FONCTION() ),
         INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG"),
                                 fr="Type d'interpolation pour les abscisses et les ordonnées de la fonction"),
         PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
CALC_FORC_AJOU=OPER(nom="CALC_FORC_AJOU",op=199,sd_prod=vect_asse_gene,
                   fr="Calculer l'effet de surpression hydrodynamique due au mouvement d'entrainement de la structure"
                       +" en analyse sismique",
                   reentrant ='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},

        regles=(EXCLUS('MODE_MECA','MODELE_GENE'),
                PRESENT_PRESENT( 'MODELE_GENE','NUME_DDL_GENE'),
                UN_PARMI('MONO_APPUI', 'NOEUD','GROUP_NO'),
                UN_PARMI('MONO_APPUI','MODE_STAT')),

         MODELE_FLUIDE   =SIMP(statut='o',typ=modele_sdaster ),
         MODELE_INTERFACE=SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CHARGE          =SIMP(statut='o',typ=char_ther ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene ),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NUME_MODE_MECA  =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         POTENTIEL       =SIMP(statut='f',typ=evol_ther ),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),

         DIRECTION       =SIMP(statut='o',typ='R',max=3),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",),),
         NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca,),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('CALC_FORC_AJOU'),
#-------------------------------------------------------------------
     ) ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr

CALC_FORC_NONL=OPER(nom="CALC_FORC_NONL",op= 183,sd_prod=dyna_trans,reentrant='n',
            fr="Créer un dyna_trans contenant des champs nommés 'DEPL' correspondant à 'FONL_NOEU' ",
            UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
         RESULTAT        =SIMP(statut='o',typ=resultat_sdaster),

         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                        'NOEUD_CMP','LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS'),
                 ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         NOM_CAS         =SIMP(statut='f',typ='TXM' ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
         b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
         b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION       =SIMP(statut='o',typ='R',),),
         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1, defaut="FONL_NOEU",
                               into=("FONL_NOEU",) ),

         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),

         COMPORTEMENT       =C_COMPORTEMENT(),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr
CALC_G=OPER(nom="CALC_G",op=100,sd_prod=table_sdaster,
            fr="Calcul du taux de restitution d'énergie par la méthode theta en thermo-élasticité"
                        +" et les facteurs d'intensité de contraintes.",
                    reentrant='f',
            UIinfo={"groupes":("Post-traitements","Rupture",)},

         THETA          =FACT(statut='o',
           THETA           =SIMP(statut='f',typ=(theta_geom,cham_no_sdaster),),
           FOND_FISS       =SIMP(statut='f',typ=fond_fiss,max=1),
           FISSURE         =SIMP(statut='f',position='global',typ=fiss_xfem,max=1),
           NB_POINT_FOND   =SIMP(statut='f',typ='I',val_min=2),
           regles=(
                   EXCLUS('FOND_FISS','NB_POINT_FOND'),
                   UN_PARMI('THETA','FOND_FISS','FISSURE')
                   ),
          b_theta        =BLOC(condition="THETA == None",fr="calcul de theta",
            regles=(PRESENT_PRESENT('R_INF','R_SUP'),
                PRESENT_PRESENT('R_INF_FO','R_SUP_FO'), ),
             NUME_FOND        =SIMP(statut='f',typ='I',defaut=1),
             R_INF           =SIMP(statut='f',typ='R'),
             R_SUP           =SIMP(statut='f',typ='R'),
             MODULE          =SIMP(statut='f',typ='R',defaut=1.),
             DIRE_THETA      =SIMP(statut='f',typ=cham_no_sdaster ),
             DIRECTION       =SIMP(statut='f',typ='R',max=3,min=3),
             R_INF_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_SUP_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MODULE_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ),
           b_no_fond_fiss      =BLOC(condition="FOND_FISS== None",
             SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
             ),
            ),

         RESULTAT        =SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans,mode_meca,mult_elas),),
                    
         b_no_mult          =BLOC(condition="(AsType(RESULTAT) != mult_elas)",
         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST',
                  'TOUT_MODE','NUME_MODE','LIST_MODE','FREQ','LIST_FREQ'),),

            TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
            LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
            INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
            LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
            TOUT_MODE       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
            LIST_MODE       =SIMP(statut='f',typ=listis_sdaster),
            LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
            FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),

           b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)or(FREQ != None)or(LIST_FREQ != None)",
              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                  b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                      PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                  b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                      PRECISION       =SIMP(statut='o',typ='R'),),
            ),
         ),

         b_mult_elas     =BLOC(condition="(AsType(RESULTAT) == mult_elas)",
            NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**' ),
         ),

         b_no_mult_elas  =BLOC(condition="(AsType(RESULTAT) != mult_elas)",
            EXCIT           =FACT(statut='f',max='**',
               CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),
               FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
               TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
                                 ),
         ),

         COMPORTEMENT       =FACT(statut='f',
               RELATION  =SIMP( statut='o',typ='TXM',into=C_RELATION('CALC_G')),
               DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT",into=("PETIT","PETIT_REAC") ),
             regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
               TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
               GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
               
               b_init          =BLOC(condition="RELATION=='ELAS'",),
                        SIGM_INIT=SIMP(statut='f', typ=(cham_no_sdaster,cham_elem)),
                        ),         
                        
#         ETAT_INIT       =FACT(statut='f',
#           SIGM            =SIMP(statut='f',typ=cham_elem),
#           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
#         ),
         LISSAGE         =FACT(statut='d',
           LISSAGE_THETA   =SIMP(statut='f',typ='TXM',defaut="LEGENDRE",into=("LEGENDRE","LAGRANGE","LAGRANGE_REGU"),),
           LISSAGE_G       =SIMP(statut='f',typ='TXM',defaut="LEGENDRE",into=("LEGENDRE","LAGRANGE",
                                 "LAGRANGE_NO_NO","LAGRANGE_REGU"),),
                b_legen    =BLOC(condition="(LISSAGE_THETA=='LEGENDRE') or (LISSAGE_G=='LEGENDRE')",
                  DEGRE           =SIMP(statut='f',typ='I',defaut=5,into=(0,1,2,3,4,5,6,7) ),
                ),
         ),

         OPTION          =SIMP(statut='o',typ='TXM',max=1,defaut='CALC_G',
                               into=("CALC_G",
                                     "CALC_G_GLOB",
                                     "CALC_K_G",
                                     "G_MAX",
                                     "G_MAX_GLOB",
                                     "G_BILI",
                                     "G_BILI_GLOB",
                                     "CALC_K_MAX"),
                             ),

         b_g_max    =BLOC(condition="(OPTION=='G_MAX') or (OPTION=='G_MAX_GLOB')",
           BORNES          =FACT(statut='o',max='**',
                NUME_ORDRE     =SIMP(statut='o',typ='I'),
                VALE_MIN       =SIMP(statut='o',typ='R'),
                VALE_MAX       =SIMP(statut='o',typ='R'),
                                ),
         ),
         b_k_max    =BLOC(condition="(OPTION=='CALC_K_MAX')",
           SIGNES          =FACT(statut='o',max=1,
                CHARGE_S       =SIMP(statut='o',typ='I',validators=NoRepeat(),max='**'),
                CHARGE_NS      =SIMP(statut='o',typ='I',validators=NoRepeat(),max='**'),
                                ),
         ),

        b_cal_contrainte =BLOC(condition="(COMPORTEMENT!=None and (OPTION=='CALC_G' or OPTION=='CALC_G_GLOB'))",
          CALCUL_CONTRAINTE =SIMP(statut='f',typ='TXM',into=("NON",),),
         ),


         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: renaud.bargellini at edf.fr
#Quoi qu'il en soit, on sort la table GP
#Si on est sans copeau et que l'utilisateur souhaite verifier
#les copeaux automatiquement crees, il peut grace a CHAMP_COP
def calc_gp_prod(self,TRANCHE_2D,GPMAX, **args):
  """Typage des sd_prod
  """
  if TRANCHE_2D!=None:
    if TRANCHE_2D['ZONE_MAIL']== "NON":
      for ss_cop in TRANCHE_2D:
        if ss_cop['CHAMP_VISU']!= None:
          self.type_sdprod(ss_cop['CHAMP_VISU'], cham_elem)
  if GPMAX !=None:
     self.type_sdprod(GPMAX, table_sdaster)
  return table_sdaster


CALC_GP =MACRO(nom="CALC_GP",
                   op=OPS('Macro.calc_gp_ops.calc_gp_ops'),
                   sd_prod=calc_gp_prod,
#                   sd_prod=table_sdaster,
                   UIinfo={"groupes":("Outils-métier","Rupture",)},
                   reentrant='n',
                   fr="calcul du parametre de clivage energetique Gp en 2D et en 3D",
                   regles=UN_PARMI('TRANCHE_2D','TRANCHE_3D'),
         RESULTAT    =SIMP(statut='o',typ=resultat_sdaster,
                                      fr="Resultat d'une commande globale STAT_NON_LINE"),
         LIST_INST   = SIMP(statut='o',typ=(listr8_sdaster) ),
         PRECISION   = SIMP(statut='f',typ='R',validators=NoRepeat(),val_min=0.,val_max=1E-3,defaut=1E-6),
         CRITERE     = SIMP(statut='f',typ='TXM',defaut="ABSOLU",into=("RELATIF","ABSOLU") ),                  
         TRANCHE_2D  = FACT(statut='f',max = 1,
                           ZONE_MAIL     = SIMP(statut='o',typ='TXM',into=("NON","OUI") ),
                           b_cop= BLOC(condition = "ZONE_MAIL=='OUI'",
                                       fr="Les copeaux sont mailles",
                                 GROUP_MA  = SIMP(statut='o', typ=grma, validators=NoRepeat(), max='**'),
                                 TAILLE   =SIMP(statut='o',typ=listr8_sdaster),),
                           b_ss_cop = BLOC(condition="ZONE_MAIL=='NON'",
                                           fr="Les copeaux ne sont pas mailles",
                                 CENTRE           =SIMP(statut='o',typ='R',max=2),
                                 RAYON       =SIMP(statut='o',typ='R',max=1),
                                 ANGLE            =SIMP(statut='o',typ='R',max=1),
                                 TAILLE          =SIMP(statut='o',typ='R',max=1),
                                 NB_ZONE        =SIMP(statut='o',typ='I',),
                                 CHAMP_VISU        =SIMP(statut='f',typ=CO),),
                             ),
         TRANCHE_3D  = FACT(statut='f',max ='**',
                           GROUP_MA  = SIMP(statut='o', typ=grma, validators=NoRepeat(), max='**'),
                             ),
         b_tranche_2d = BLOC(condition="TRANCHE_2D!=None",
                 SYME            =SIMP(statut='o',typ='TXM',into=("NON","OUI"),
                      fr="multiplication par 2 si SYME=OUI"),),
         b_tranche_3d = BLOC(condition="TRANCHE_3D!=None",
                 FOND_FISS       =SIMP(statut='o',typ=fond_fiss,max=1,),),
         GPMAX           = SIMP(statut='f',typ=CO,),
           )

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
#
# MACRO DE COUPLAGE IFS AVEC SATURNE VIA YACS
#
CALC_IFS_DNL= MACRO(nom='CALC_IFS_DNL',
                    op=OPS("Macro.calc_ifs_dnl_ops.calc_ifs_dnl_ops"),
                    sd_prod=evol_noli,
                    reentrant='f',
                    fr="Calcul de l'évolution dynamique d'une structure couplée à un "\
                       "domaine fluide (résolu avec le code Saturne) via YACS",
            UIinfo={"groupes":("Résolution","Dynamique",)},

#IFS
#=>
         GROUP_MA_IFS     =SIMP(statut='o',typ=grma,max='**'),
         NOM_CMP_IFS      =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
         UNITE_NOEUD      =SIMP(statut='f',typ='I',defaut= 81 ),
         UNITE_ELEM       =SIMP(statut='f',typ='I',defaut= 82 ),
         PAS_INIT         =SIMP(statut='o',typ='R' ),
#<=
#IFS
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         MASS_DIAG       =SIMP(statut='f',typ='TXM',into=("OUI","NON",) ),
#IFS
#=>
#(une charge force nodale est fournie par le couplage avec code_saturne
         EXCIT           =FACT(statut='f',max='**',
#<=
#IFS
           regles=(PRESENT_ABSENT('FONC_MULT','ACCE'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","SUIV","DIDI")),
#IFS
#=>
#(une charge force nodale est fournie par le couplage avec code_saturne
#           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),
#<=
#IFS
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         EXCIT_GENE      =FACT(statut='f',max='**',
           FONC_MULT       =SIMP(statut='f',typ=fonction_sdaster,max='**' ),
           VECT_GENE       =SIMP(statut='f',typ=vect_asse_gene,max='**' ),
         ),
         CONTACT         =SIMP(statut='f',typ=char_contact),
         SOUS_STRUC      =FACT(statut='f',min=01,max='**',
                regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                SUPER_MAILLE=SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
                FONC_MULT   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
              ),
         AMOR_RAYL_RIGI = SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE"),),
         AMOR_MODAL      =FACT(statut='f',
           regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
           MODE_MECA       =SIMP(statut='f',typ=mode_meca),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**' ),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           REAC_VITE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         PROJ_MODAL      =FACT(statut='f',max='**',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           regles=(PRESENT_PRESENT('MASS_GENE','RIGI_GENE'),),
           MASS_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           RIGI_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           DEPL_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
           VITE_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
           ACCE_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
         ),
#-------------------------------------------------------------------
         COMPORTEMENT       =C_COMPORTEMENT('DYNA_NON_LINE'),
#-------------------------------------------------------------------
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : ETAT_INIT obligatoire",
         ETAT_INIT       =FACT(statut='o',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI',),
                   EXCLUS('EVOL_NOLI','DEPL',),
                   EXCLUS('EVOL_NOLI','VITE'),
                   EXCLUS('EVOL_NOLI','ACCE'),
                   EXCLUS('EVOL_NOLI','SIGM',),
                   EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
               PRECISION       =SIMP(statut='o',typ='R',),),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant : ETAT_INIT facultatif",
         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI',),
                   EXCLUS('EVOL_NOLI','DEPL',),
                   EXCLUS('EVOL_NOLI','VITE'),
                   EXCLUS('EVOL_NOLI','ACCE'),
                   EXCLUS('EVOL_NOLI','SIGM',),
                   EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
               PRECISION       =SIMP(statut='o',typ='R',),),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
#-------------------------------------------------------------------
#IFS : pas besoin d'INCREMENT
#         INCREMENT       =C_INCREMENT('MECANIQUE'),
#-------------------------------------------------------------------
         SCHEMA_TEMPS     =FACT(statut='o',
            SCHEMA          =SIMP(statut='o',min=1,max=1,typ='TXM',
            into=("DIFF_CENT","TCHAMWA","NEWMARK","HHT","THETA_METHODE","KRENK"),),
            COEF_MASS_SHIFT =SIMP(statut='f',typ='R',defaut= 0.0E+0 ),
            b_tchamwa = BLOC(condition="SCHEMA=='TCHAMWA'",
               PHI          =SIMP(statut='f',typ='R',defaut= 1.05),),

            b_newmark = BLOC(condition="SCHEMA=='NEWMARK'",
               BETA         =SIMP(statut='f',typ='R',defaut= 0.25),
               GAMMA        =SIMP(statut='f',typ='R',defaut= 0.5),),

            b_hht     = BLOC(condition="SCHEMA=='HHT'",
               ALPHA        =SIMP(statut='f',typ='R',defaut= -0.3 ),
               MODI_EQUI    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),),),

            b_theta   = BLOC(condition="SCHEMA=='THETA_METHODE'",
               THETA         =SIMP(statut='f',typ='R',defaut= 1.,val_min=0.5,val_max=100. ),),

            b_krenk   = BLOC(condition="SCHEMA=='KRENK'",
               KAPPA         =SIMP(statut='f',typ='R',defaut= 1.0,val_min=1.0,val_max=100. ),),

            b_explicit= BLOC(condition="SCHEMA=='TCHAMWA'or SCHEMA=='DIFF_CENT'",
               STOP_CFL     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),),
               FORMULATION  =SIMP(statut='o',typ='TXM',into=("ACCELERATION",),),),

            b_implicit= BLOC(condition="SCHEMA!='TCHAMWA'and SCHEMA!='DIFF_CENT'",
               FORMULATION  =SIMP(statut='o',max=1,typ='TXM',into=("DEPLACEMENT","VITESSE","ACCELERATION"),),),
         ),
#-------------------------------------------------------------------
         NEWTON          =C_NEWTON(),
#-------------------------------------------------------------------
         RECH_LINEAIRE   =C_RECH_LINEAIRE(),
#-------------------------------------------------------------------
         CONVERGENCE     =C_CONVERGENCE(),
#-------------------------------------------------------------------
         SOLVEUR         =C_SOLVEUR('CALC_IFS_DNL'),
#-------------------------------------------------------------------
         OBSERVATION     =C_OBSERVATION(),
#-------------------------------------------------------------------
         SUIVI_DDL       =C_SUIVI_DDL(),
#-------------------------------------------------------------------
         AFFICHAGE       =C_AFFICHAGE(),
#-------------------------------------------------------------------
         ARCHIVAGE       =C_ARCHIVAGE(),
#-------------------------------------------------------------------
         CRIT_STAB      =FACT(statut='f',min=1,max=1,
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,val_min=1,defaut=3),
           COEF_DIM_ESPACE =SIMP(statut='f',typ='I',max=1,val_min=2,defaut=5),
           RIGI_GEOM     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           b_char_crit=BLOC(condition="(RIGI_GEOM=='OUI')",
              CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max=2,
                                    fr="Valeur des deux charges critiques délimitant la bande de recherche en HPP"),),
           MODI_RIGI     =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
           TYPE          =SIMP(statut='f',typ='TXM',defaut="FLAMBEMENT",into=("FLAMBEMENT","STABILITE")),
           PREC_INSTAB   =SIMP(statut='f',typ='R',defaut=1.E-6,max=1,),
           SIGNE         =SIMP(statut='f',typ='TXM',defaut=("POSITIF_NEGATIF"),into=("NEGATIF","POSITIF","POSITIF_NEGATIF"),max=1,),
           bloc_rigi_geom=BLOC(condition="(RIGI_GEOM=='NON'or MODI_RIGI=='OUI')",
              DDL_EXCLUS      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=40,
                                    into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                          'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                          'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                          'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                          'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                          'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                          'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                          'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                          'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG','DH')),
           bloc_type_stab =BLOC(condition= "TYPE == 'STABILITE' and RIGI_GEOM == 'NON'",
              DDL_STAB        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=40,
                                       into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                             'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                             'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                             'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                             'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                             'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                             'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                             'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                             'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG','DH')),),
                            ),
           regles         = (EXCLUS('PAS_CALC','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_CALC       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),
         MODE_VIBR     =FACT(statut='f',min=1,max=1,
           MATR_RIGI        =SIMP(statut='f',typ='TXM',defaut="ELASTIQUE",into=("ELASTIQUE","TANGENTE","SECANTE",) ),
           NB_FREQ          =SIMP(statut='f',typ='I',max=1,val_min=1,defaut=3,
                            fr="Nombre de fréquences propres à calculer"),
           COEF_DIM_ESPACE  =SIMP(statut='f',typ='I',max=1,val_min=2,defaut=5),
           BANDE            =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Valeur des deux fréquences délimitant la bande de recherche",),
           regles         = (EXCLUS('PAS_CALC','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_CALC       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),
#-------------------------------------------------------------------

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         b_info=BLOC(condition="(INFO==2)",
               fr="filtre les messages émis dans le .mess selon le type de message demandé",
               INFO_DBG = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                               into=("CONTACT",
                                     "MECA_NON_LINE",
                                     "PILOTAGE",
                                     "FACTORISATION",
                                     "APPARIEMENT"),
                             ),
                    ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
CALC_INTE_SPEC=OPER(nom="CALC_INTE_SPEC",op= 120,sd_prod=interspectre,
                    fr="Calcul d'une matrice interspectrale à partir d'une fonction du temps",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         INST_INIT       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         INST_FIN        =SIMP(statut='o',typ='R' ),
         DUREE_ANALYSE   =SIMP(statut='f',typ='R' ),
         DUREE_DECALAGE  =SIMP(statut='f',typ='R' ),
         NB_POIN         =SIMP(statut='o',typ='I' ),
         FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
         TITRE           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: romeo.fernandes at edf.fr


CALC_MAC3COEUR = MACRO(nom="CALC_MAC3COEUR",
                       op=OPS("Mac3coeur.calc_mac3coeur_ops.calc_mac3coeur_ops"),
                       sd_prod=evol_noli,

         TYPE_COEUR   = SIMP(statut='o',typ='TXM',into=("MONO","TEST","900","1300","N4","EPR"),position='global' ),
         # TYPE DE COEUR A CONSIDERER
         TABLE_N      = SIMP(statut='o',typ=table_sdaster),         # TABLE INITIALE DES DAMAC A L INSTANT N
         MAILLAGE_N   = SIMP(statut='f',typ=maillage_sdaster),        # MAILLAGE EN ATTENDANT MIEUX ???

         LAME = FACT(statut='f',max=1,
                     fr="Estimation des lames d'eau entre AC",
               TABLE_NP1    = SIMP(statut='o',typ=table_sdaster),         # TABLE INITIALE DES DAMAC A L INSTANT N+1
               MAILLAGE_NP1 = SIMP(statut='o',typ=maillage_sdaster),),        # MAILLAGE EN ATTENDANT MIEUX ???

         DEFORMATION  = FACT(statut='f',max=1,
                      fr="Estimation des deformations des AC",
               RESU_INIT    = SIMP(statut='f',typ=resultat_sdaster),
               NIVE_FLUENCE = SIMP(statut='o',typ='R',validators=NoRepeat(),max=1), # FLUENCE MAXIMALE DANS LE COEUR
               UNITE_THYC      = SIMP(statut='o',typ='I', max=1),
               
               # choix du maintien dans le cas mono-assemblage
               b_maintien_mono = BLOC(condition = "TYPE_COEUR == 'MONO'",

                    TYPE_MAINTIEN = SIMP(statut='o',typ='TXM',into=("FORCE","DEPL_PSC"), ),
                    
                    b_maintien_mono_force = BLOC(condition = "TYPE_MAINTIEN == 'FORCE'",
                                 fr="valeur de l'effort de maintien imposée",
                                 FORCE_MAINTIEN           =SIMP(statut='o',typ='R', max=1),),
                     
                                       ),
                
               # choix du maintien dans le cas d'un coeur à plusieurs assemblages
               b_maintien_coeur = BLOC(condition = "TYPE_COEUR != 'MONO'",

                    TYPE_MAINTIEN = SIMP(statut='f',typ='TXM',into=("DEPL_PSC",),defaut="DEPL_PSC" ),
                                       
                                       ),
                   
                                 ),

);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
CALC_MATR_AJOU=OPER(nom="CALC_MATR_AJOU",op= 152,sd_prod=matr_asse_gene_r,
                    fr="Calcul des matrices de masse, d'amortissement ou de rigidité ajoutés",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(EXCLUS('MODE_MECA','CHAM_NO','MODELE_GENE'),
                 PRESENT_ABSENT('NUME_DDL_GENE','CHAM_NO'),
                 PRESENT_PRESENT('MODELE_GENE','NUME_DDL_GENE'),),
         MODELE_FLUIDE   =SIMP(statut='o',typ=modele_sdaster ),
         MODELE_INTERFACE=SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CHARGE          =SIMP(statut='o',typ=char_ther ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene ),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NUME_MODE_MECA  =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         OPTION          =SIMP(statut='o',typ='TXM',into=("MASS_AJOU","AMOR_AJOU","RIGI_AJOU") ),
         POTENTIEL       =SIMP(statut='f',typ=evol_ther ),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('CALC_MATR_AJOU'),
#-------------------------------------------------------------------
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def calc_matr_elem_prod(OPTION,**args):
  if OPTION == "RIGI_MECA"        : return matr_elem_depl_r
  if OPTION == "RIGI_FLUI_STRU"   : return matr_elem_depl_r
  if OPTION == "MASS_MECA"        : return matr_elem_depl_r
  if OPTION == "MASS_FLUI_STRU"   : return matr_elem_depl_r
  if OPTION == "RIGI_GEOM"        : return matr_elem_depl_r
  if OPTION == "RIGI_ROTA"        : return matr_elem_depl_r
  if OPTION == "MECA_GYRO"        : return matr_elem_depl_r
  if OPTION == "RIGI_GYRO"        : return matr_elem_depl_r
  if OPTION == "AMOR_MECA"        : return matr_elem_depl_r
  if OPTION == "IMPE_MECA"        : return matr_elem_depl_r
  if OPTION == "ONDE_FLUI"        : return matr_elem_depl_r
  if OPTION == "AMOR_MECA_ABSO"   : return matr_elem_depl_r
  if OPTION == "RIGI_MECA_HYST"   : return matr_elem_depl_c
  if OPTION == "RIGI_THER"        : return matr_elem_temp_r
  if OPTION == "MASS_MECA_DIAG"   : return matr_elem_depl_r
  if OPTION == "RIGI_ACOU"        : return matr_elem_pres_c
  if OPTION == "MASS_ACOU"        : return matr_elem_pres_c
  if OPTION == "AMOR_ACOU"        : return matr_elem_pres_c
  raise AsException("type de concept resultat non prevu")

CALC_MATR_ELEM=OPER(nom="CALC_MATR_ELEM",op=   9,sd_prod=calc_matr_elem_prod
                    ,fr="Calcul des matrices élémentaires",reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},

         OPTION          =SIMP(statut='o',typ='TXM',
                               into=("RIGI_MECA","MASS_MECA","RIGI_GEOM",
                                     "AMOR_MECA","RIGI_THER","IMPE_MECA",
                                     "ONDE_FLUI","AMOR_MECA_ABSO","MASS_FLUI_STRU","RIGI_FLUI_STRU",
                                     "RIGI_ROTA","MECA_GYRO","RIGI_GYRO","MASS_MECA_DIAG","RIGI_ACOU",
                                     "MASS_ACOU","AMOR_ACOU","RIGI_MECA_HYST") ),
         MODELE            =SIMP(statut='o',typ=modele_sdaster ),

         # mots clés facultatifs que l'on a du mal à mettre dans les blocs
         # sans gener MACRO_MATR_ASSE :
         #------------------------------------------------------------------
         INST=SIMP(statut='f',typ='R',defaut= 0.E+0 ),


         b_rigi_meca = BLOC( condition = "OPTION=='RIGI_MECA'",
           CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0 ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_mass_meca   =BLOC(condition = "(OPTION=='MASS_MECA') or (OPTION=='MASS_MECA_DIAG')",
           CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),

         b_rigi_geom       =BLOC(condition = "OPTION=='RIGI_GEOM'",
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           SIEF_ELGA         =SIMP(statut='o',typ=cham_elem ),
           STRX_ELGA         =SIMP(statut='f',typ=cham_elem ),
           MODE_FOURIER      =SIMP(statut='f',typ='I',defaut= 0 ),
         ),

         b_rigi_rota       =BLOC(condition = "OPTION=='RIGI_ROTA'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHARGE            =SIMP(statut='o',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_meca_gyro = BLOC( condition = "OPTION=='MECA_GYRO'",
           CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_gyro = BLOC( condition = "OPTION=='RIGI_GYRO'",
           CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_amor_meca       =BLOC(condition = "OPTION=='AMOR_MECA'",
           regles=(AU_MOINS_UN('CARA_ELEM','RIGI_MECA'),
                   ENSEMBLE('RIGI_MECA','MASS_MECA','CHAM_MATER'), ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
           RIGI_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           MASS_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),

         b_amor_meca_abso  =BLOC(condition = "OPTION=='AMOR_MECA_ABSO'",
           regles=(AU_MOINS_UN('CARA_ELEM','RIGI_MECA'),
                   ENSEMBLE('RIGI_MECA','MASS_MECA','CHAM_MATER'), ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           RIGI_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           MASS_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),

         b_rigi_meca_hyst  =BLOC( condition = "OPTION=='RIGI_MECA_HYST'",
           CHARGE            =SIMP(statut='f',typ=char_meca ,validators=NoRepeat(),max='**' ),
           CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           RIGI_MECA         =SIMP(statut='o',typ=matr_elem_depl_r ),
         ),

         b_rigi_ther       =BLOC(condition = "OPTION=='RIGI_THER'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           MODE_FOURIER      =SIMP(statut='f',typ='I',defaut= 0 ),
           CHARGE            =SIMP(statut='f',typ=char_ther,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_acou       =BLOC(condition = "OPTION=='RIGI_ACOU'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='f',typ=char_acou ,validators=NoRepeat(),max='**' ),
         ),

         b_mass_acou       =BLOC(condition = "(OPTION=='MASS_ACOU') or (OPTION=='AMOR_ACOU')",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='f',typ=char_acou ,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_flui       =BLOC(condition = "OPTION=='RIGI_FLUI_STRU'",
           CARA_ELEM         =SIMP(statut='o',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca ,validators=NoRepeat(),max='**' ),
         ),

         b_mass_flui       =BLOC(condition = "OPTION=='MASS_FLUI_STRU'",
           CARA_ELEM         =SIMP(statut='o',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca ,validators=NoRepeat(),max='**'),
         ),

         b_impe_meca       =BLOC(condition = "(OPTION=='IMPE_MECA') or (OPTION=='ONDE_FLUI')",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: renaud.bargellini at edf.fr
CALC_META=OPER(nom="CALC_META",op=194,sd_prod=evol_ther,reentrant='o',
            UIinfo={"groupes":("Post-traitements","Thermique",)},
               fr="Calcule l'évolution métallurgique à partir du résultat d'un calcul thermique",

     regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),

     MODELE          =SIMP(statut='f',typ=modele_sdaster ),
     CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
     RESULTAT        =SIMP(statut='o',typ=evol_ther ),

     OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(phenomene='METALLURGIE',),),

     TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
     GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                           fr="le calcul ne sera effectué que sur ces mailles là"),
     MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**',
                           fr="le calcul ne sera effectué que sur ces mailles là"),

     b_meta =BLOC(condition= "au_moins_un(OPTION, ('META_ELNO','META_NOEU'))",
       ETAT_INIT       =FACT(statut='o',
          regles=(UN_PARMI('EVOL_THER', 'META_INIT_ELNO'),),
          EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
          META_INIT_ELNO  =SIMP(statut='f',typ=carte_sdaster ),
          b_etat     =BLOC(condition="EVOL_THER != None",
             regles=(UN_PARMI('NUME_INIT', 'INST_INIT',),),
             NUME_INIT       =SIMP(statut='f',typ='I'),
             INST_INIT       =SIMP(statut='f',typ='R'),
             b_inst     =BLOC(condition="INST_INIT != None",
                CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                    PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                    PRECISION       =SIMP(statut='o',typ='R',),),
             ),
          ),
       ),

       COMPORTEMENT      =FACT(statut='o',max=1,
         RELATION        =SIMP(statut='o',typ='TXM',into=("ACIER","ZIRC",) ),
         ACIER           =SIMP(statut='c',typ='I',defaut=7,into=(7,) ),
         ZIRC            =SIMP(statut='c',typ='I',defaut=4,into=(4,) ),

         regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma, validators=NoRepeat(), max='**'),
         MAILLE          =SIMP(statut='f',typ=ma, validators=NoRepeat(), max='**'),
                             ),
                 ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def calc_miss_sdprod(self, TYPE_RESU, **kwargs):
    """Typage des structures de données produites"""
    if TYPE_RESU in ('TABLE', 'TABLE_CONTROL'):
        return table_sdaster
    elif TYPE_RESU == 'HARM_GENE':
        return harm_gene
    elif TYPE_RESU == 'TRAN_GENE':
        return tran_gene
    else:
        return None

CALC_MISS = MACRO(nom="CALC_MISS",
                  op=OPS('Macro.calc_miss_ops.calc_miss_ops'),
                  sd_prod=calc_miss_sdprod,
                  fr="Préparation des données, exécution du logiciel Miss3D, et post-traitement",
                  UIinfo={"groupes":("Résolution","Outils-métier",)},

    TYPE_RESU   = SIMP(statut='o', typ='TXM',
                       into=('HARM_GENE', 'TRAN_GENE', 'TABLE', 'TABLE_CONTROL',
                             'FICHIER', 'FICHIER_TEMPS'),
                       fr="Type de résultat produit en post-traitement. FICHIER : pas de post-traitement"),
    PROJET      = SIMP(statut='f', typ='TXM', defaut='MODELE',
                       fr="Nom de l'étude Miss"),
    REPERTOIRE  = SIMP(statut='f', typ='TXM',
                       fr="Répertoire de travail de Miss"),
    VERSION     = SIMP(statut='f', typ='TXM', into=("V6.6","V6.5"), defaut="V6.6",
                       fr="Version de Miss utilisée"),

    TABLE_SOL   = SIMP(statut='o', typ=table_sdaster,
                       fr="Table des propriétés du sol"),

    # pas de post-traitement
    b_basic   = BLOC(condition="TYPE_RESU in ('FICHIER', 'TABLE_CONTROL')",
                       regles=(UN_PARMI('MACR_ELEM_DYNA', 'BASE_MODALE'),
                               ENSEMBLE('GROUP_MA_FLU_STR', 'GROUP_MA_FLU_SOL', 'GROUP_MA_SOL_SOL'),),
        MACR_ELEM_DYNA  = SIMP(statut='f', typ=macr_elem_dyna,
                               fr="Macro élément produit en amont"),
        BASE_MODALE     = SIMP(statut='f', typ=mode_meca,
                               fr="Base de modes"),
        b_base_modale = BLOC(condition="BASE_MODALE is not None",
            MATR_RIGI       = SIMP(statut='f', typ=(matr_asse_depl_r, matr_asse_depl_c),),
            MATR_MASS       = SIMP(statut='f', typ=matr_asse_depl_r ),
        ),
        AMOR_REDUIT     = SIMP(statut='f', typ='R', max='**'),
        GROUP_MA_INTERF = SIMP(statut='o', typ=grma, max='**',
                               fr="Groupe de mailles de l'interface"),
        GROUP_MA_FLU_STR = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles fluide-structure"),
        GROUP_MA_FLU_SOL = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles fluide-sol"),
        GROUP_MA_SOL_SOL = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles sol-sol"),
        UNITE_IMPR_ASTER = SIMP(statut='f', typ='I',
                                fr="Unité des résultats transmis par Code_Aster à Miss"),
        UNITE_RESU_IMPE  = SIMP(statut='f', typ='I',
                                fr="Unité logique des impédances écrites par Miss"),
        UNITE_RESU_FORC  = SIMP(statut='f', typ='I',
                                fr="Unité logique des forces sismiques écrites par Miss"),
    ),
    # post-traitement : passage du domaine de Laplace au domaine temporel
    b_fichier_temps   = BLOC(condition="TYPE_RESU == 'FICHIER_TEMPS'",
                       regles=(UN_PARMI('MACR_ELEM_DYNA', 'BASE_MODALE'),
                               AU_MOINS_UN('UNITE_RESU_RIGI','UNITE_RESU_AMOR','UNITE_RESU_MASS'),
                               PRESENT_PRESENT('UNITE_RESU_AMOR', 'MATR_GENE'),
                               PRESENT_PRESENT('UNITE_RESU_MASS', 'MATR_GENE'),),
        MACR_ELEM_DYNA  = SIMP(statut='f', typ=macr_elem_dyna,
                               fr="Macro élément produit en amont"),
        BASE_MODALE     = SIMP(statut='f', typ=mode_meca,
                               fr="Base de modes"),
        b_base_modale = BLOC(condition="BASE_MODALE is not None",
            MATR_RIGI       = SIMP(statut='f', typ=(matr_asse_depl_r, matr_asse_depl_c),),
            MATR_MASS       = SIMP(statut='f', typ=matr_asse_depl_r ),
        ),
        AMOR_REDUIT     = SIMP(statut='f', typ='R', max='**'),
        GROUP_MA_INTERF = SIMP(statut='o', typ=grma, max='**',
                               fr="Groupe de mailles de l'interface"),
        UNITE_IMPR_ASTER = SIMP(statut='f', typ='I',
                                fr="Unité des résultats transmis par Code_Aster à Miss"),
        UNITE_RESU_RIGI =SIMP(statut='f',typ='I'),
        UNITE_RESU_AMOR =SIMP(statut='f',typ='I'),
        UNITE_RESU_MASS =SIMP(statut='f',typ='I'),
        INST_FIN       = SIMP(statut='f', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='f', typ='R', fr="Pas de temps du calcul"),
        PRECISION      = SIMP(statut='f',typ='R',defaut=0.000001),
        COEF_SURECH    = SIMP(statut='f',typ='I',defaut=1 ),
        MATR_GENE       =FACT(statut='f', max = 1,
                     DECOMP_IMPE= SIMP(statut='f',typ='TXM',defaut='PRODUIT',into=('PRODUIT','SANS_PRODUIT')),
                     AMOR_HYST  = SIMP(statut='o',typ='TXM',into=('DANS_IMPEDANCE','DANS_MATR_AMOR'),
                     fr="Indique comment l'amortissement hysteretique est pris en compte"),
                 b_amor_nohyst = BLOC(condition="AMOR_HYST == 'DANS_MATR_AMOR'",
                     MATR_MASS  = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_depl_r ) ),
                     MATR_RIGI  = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c,matr_asse_depl_r ) ),
                     MATR_AMOR  = SIMP(statut='o',typ=(matr_asse_gene_r,matr_asse_gene_c,matr_asse_depl_r ) ),
                   ), 
                 b_amor_hyst = BLOC(condition="AMOR_HYST == 'DANS_IMPEDANCE'",
                    regles = (AU_MOINS_UN('MATR_MASS','MATR_RIGI','MATR_AMOR'),),
                     MATR_MASS  = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_depl_r ) ),
                     MATR_RIGI  = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c,matr_asse_depl_r ) ),
                     MATR_AMOR  = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c,matr_asse_depl_r ) ),
                   ), 
                               ),
        EXCIT_SOL       =FACT(statut='f', max = 1,
                          regles = (AU_MOINS_UN('CHAM_X','CHAM_Y','CHAM_Z'),),
                               UNITE_RESU_FORC  =SIMP(statut='o',typ='I',
                                                      fr="Unité logique des forces sismiques écrites par Miss"),
                               NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut='DEPL',
                                                     into=('ACCE','VITE','DEPL') ),
                               CHAM_X    = SIMP(statut='f', typ=fonction_sdaster,),
                               CHAM_Y    = SIMP(statut='f', typ=fonction_sdaster,),
                               CHAM_Z    = SIMP(statut='f', typ=fonction_sdaster,),
                               ),
    ),    
    # si post-traitement
    b_donnees   = BLOC(condition="TYPE_RESU not in ('FICHIER', 'FICHIER_TEMPS', 'TABLE_CONTROL')",
                       regles=(ENSEMBLE('GROUP_MA_FLU_STR', 'GROUP_MA_FLU_SOL', 'GROUP_MA_SOL_SOL'),
                               UN_PARMI('MATR_AMOR', 'AMOR_REDUIT'),),
        MACR_ELEM_DYNA  = SIMP(statut='f', typ=macr_elem_dyna,
                               fr="Macro élément produit en amont"),
        BASE_MODALE     = SIMP(statut='o', typ=mode_meca,
                               fr="Base de modes"),
        MATR_RIGI       = SIMP(statut='o', typ=(matr_asse_depl_r, matr_asse_depl_c),),
        MATR_MASS       = SIMP(statut='o', typ=matr_asse_depl_r ),        
        MATR_AMOR       = SIMP(statut='f', typ=matr_asse_depl_r ),
        AMOR_REDUIT     = SIMP(statut='f', typ='R', max='**'),
        GROUP_MA_INTERF = SIMP(statut='o', typ=grma, max='**',
                               fr="Groupe de mailles de l'interface"),
        GROUP_MA_FLU_STR = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles fluide-structure"),
        GROUP_MA_FLU_SOL = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles fluide-sol"),
        GROUP_MA_SOL_SOL = SIMP(statut='f', typ=grma, max='**',
                               fr="Groupe de mailles sol-sol"),
        UNITE_IMPR_ASTER = SIMP(statut='f', typ='I',
                                fr="Unité des résultats transmis par Code_Aster à Miss"),
        UNITE_RESU_IMPE  = SIMP(statut='f', typ='I',
                                fr="Unité logique des impédances à relire."),
        UNITE_RESU_FORC  = SIMP(statut='f', typ='I',
                                fr="Unité logique des forces sismiques à relire"),
    ),
    # Paramètres du calcul Miss
    PARAMETRE   = FACT(statut='o',
                       regles=(PRESENT_PRESENT('OFFSET_MAX', 'OFFSET_NB'),
                               PRESENT_PRESENT('FREQ_MIN', 'FREQ_MAX','FREQ_PAS'),
                               UN_PARMI('FREQ_MIN', 'LIST_FREQ', 'FREQ_IMAG'),
                               PRESENT_PRESENT('SPEC_MAX', 'SPEC_NB'),),
        FREQ_MIN       = SIMP(statut='f', typ='R'),
        FREQ_MAX       = SIMP(statut='f', typ='R'),
        FREQ_PAS       = SIMP(statut='f', typ='R'),
        LIST_FREQ      = SIMP(statut='f', typ='R', max='**'),
        FREQ_IMAG      = SIMP(statut='f', typ='R'),
        Z0             = SIMP(statut='f', typ='R', defaut=0.),
        SURF           = SIMP(statut='f', typ='TXM', into=("OUI","NON",), defaut="NON"),
        ISSF           = SIMP(statut='f', typ='TXM', into=("OUI","NON",), defaut="NON"),
        ALLU           = SIMP(statut='f', typ='R', defaut=0.),
        RFIC           = SIMP(statut='f', typ='R', defaut=0.),

        ALGO           = SIMP(statut='f', typ='TXM', into=("DEPL","REGU")),
        DREF           = SIMP(statut='f', typ='R'),
        SPEC_MAX       = SIMP(statut='f', typ='R'),
        SPEC_NB        = SIMP(statut='f', typ='I'),
        OFFSET_MAX     = SIMP(statut='f', typ='R'),
        OFFSET_NB      = SIMP(statut='f', typ='I'),
        TYPE           = SIMP(statut='f', typ='TXM', into=("BINAIRE","ASCII",), defaut="ASCII"),
    ),
    # Post-traitement type 1 - tran_gene
    b_post_tran_gene = BLOC(condition="TYPE_RESU == 'TRAN_GENE'",
                       regles=(AU_MOINS_UN('ACCE_X', 'ACCE_Y', 'ACCE_Z','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               PRESENT_ABSENT('ACCE_X','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               PRESENT_ABSENT('ACCE_Y','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               PRESENT_ABSENT('ACCE_Z','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                              ),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        GROUP_NO       = SIMP(statut='f', typ=grno, max='**',),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_X         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='o', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='o', typ='R', fr="Pas de temps du calcul"),
    ),
    # Post-traitement type 1 - harm_gene
    b_post_harm_gene  = BLOC(condition="TYPE_RESU == 'HARM_GENE'",
                       regles=(#AU_MOINS_UN('EXCIT_HARMO', 'ACCE_X', 'ACCE_Y', 'ACCE_Z',),
                               AU_MOINS_UN('EXCIT_HARMO', 'ACCE_X', 'ACCE_Y', 'ACCE_Z','DEPL_X','DEPL_Y','DEPL_Z'),
                               PRESENT_ABSENT('EXCIT_HARMO', 'ACCE_X', 'ACCE_Y', 'ACCE_Z', 'INST_FIN'),
                               PRESENT_ABSENT('EXCIT_HARMO', 'DEPL_X', 'DEPL_Y', 'DEPL_Z'),
                               PRESENT_ABSENT('ACCE_X','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               PRESENT_ABSENT('ACCE_Y','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               PRESENT_ABSENT('ACCE_Z','DEPL_X', 'DEPL_Y', 'DEPL_Z',),
                               ENSEMBLE('INST_FIN', 'PAS_INST'),),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        GROUP_NO       = SIMP(statut='f', typ=grno, max='**',),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_X         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        DEPL_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='f', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='f', typ='R', fr="Pas de temps du calcul"),
        # identique à EXCIT de DYNA_LINE_HARM au type attendu pour VECT_ASSE près
        EXCIT_HARMO    = FACT(statut='f', max='**',
                              regles=(UN_PARMI('VECT_ASSE', 'CHARGE'),
                                      UN_PARMI('FONC_MULT', 'FONC_MULT_C', 'COEF_MULT', 'COEF_MULT_C'),),
            VECT_ASSE     = SIMP(statut='f', typ=cham_no_sdaster,),
            CHARGE        = SIMP(statut='f', typ=char_meca),
            FONC_MULT_C   = SIMP(statut='f', typ=(fonction_c, formule_c),),
            COEF_MULT_C   = SIMP(statut='f', typ='C'),
            FONC_MULT     = SIMP(statut='f', typ=(fonction_sdaster, nappe_sdaster, formule) ),
            COEF_MULT     = SIMP(statut='f', typ='R'),
            PHAS_DEG      = SIMP(statut='f', typ='R', defaut=0.),
            PUIS_PULS     = SIMP(statut='f', typ='I', defaut=0),
        ),
    ),
    # Post-traitement type 2
    b_post_table = BLOC(condition="TYPE_RESU == 'TABLE'",
                        regles=(AU_MOINS_UN('ACCE_X', 'ACCE_Y', 'ACCE_Z'),),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        GROUP_NO       = SIMP(statut='o', typ=grno, max='**',
                              fr="Liste des groupes de noeud de post-traitement"),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='o', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='o', typ='R', fr="Pas de temps du calcul"),
        NORME          = SIMP(statut='o', typ='R',
                              fr="Valeur de la norme du spectre d'oscillateur" ),
        AMOR_SPEC_OSCI      = SIMP(statut='o', typ='R', max='**',
                                   fr="Amortissement du spectre d'oscillateur"),
        LIST_FREQ_SPEC_OSCI = SIMP(statut='f', typ=listr8_sdaster,
                                   fr="Fréquences utilisées pour le calcul du spectre d'oscillateur"),
    ),

    # Post-traitement type 3 - points de controle
    b_post_control = BLOC(condition="TYPE_RESU == 'TABLE_CONTROL'",
                          regles=(PRESENT_PRESENT('ACCE_X', 'INST_FIN'),
                                  PRESENT_PRESENT('ACCE_Y', 'INST_FIN'),
                                  PRESENT_PRESENT('ACCE_Z', 'INST_FIN'),
                                  ENSEMBLE('INST_FIN', 'PAS_INST', 'NORME', 'AMOR_SPEC_OSCI'),),
        GROUP_MA_CONTROL = SIMP(statut='f', typ=grma, max='**',
                                fr="Groupe de mailles des points de contrôle"),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='f', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='f', typ='R', fr="Pas de temps du calcul"),
        NORME          = SIMP(statut='f', typ='R',
                              fr="Valeur de la norme du spectre d'oscillateur" ),
        AMOR_SPEC_OSCI      = SIMP(statut='f', typ='R', max='**',
                                   fr="Amortissement du spectre d'oscillateur"),
        LIST_FREQ_SPEC_OSCI = SIMP(statut='f', typ=listr8_sdaster,
                                   fr="Fréquences utilisées pour le calcul du spectre d'oscillateur"),
    ),

    INFO        = SIMP(statut='f', typ='I', defaut=1, into=(1,2)),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr


def calc_modal_prod(self,AMORTISSEMENT,**args):
  if AMORTISSEMENT=="NON": return mode_meca
  if AMORTISSEMENT=="OUI": return mode_meca_c
  raise AsException("type de concept resultat non prevu")


CALC_MODAL=MACRO(nom="CALC_MODAL",
                 op=OPS('Macro.calc_modal_ops.calc_modal_ops'),
                 UIinfo={"groupes":("Résolution","Dynamique",)},
                 sd_prod=calc_modal_prod,
                 fr="Calcul des modes propres reels ou complexes dans une seule commande",
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         AMORTISSEMENT    =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         INST            =SIMP(statut='f',typ='R',defaut=0.),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="SORENSEN",
                               into=("TRI_DIAG","JACOBI","SORENSEN","QZ") ),
         b_tri_diag =BLOC(condition = "METHODE == 'TRI_DIAG'",
           PREC_ORTHO      =SIMP(statut='f',typ='R',defaut= 1.E-12,val_min=0.E+0 ),
           NMAX_ITER_ORTHO =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
           PREC_LANCZOS    =SIMP(statut='f',typ='R',defaut= 1.E-8,val_min=0.E+0 ),
           NMAX_ITER_QR    =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ),
         ),
         b_jacobi =BLOC(condition = "METHODE == 'JACOBI'",
           PREC_BATHE      =SIMP(statut='f',typ='R',defaut= 1.E-10,val_min=0.E+0 ),
           NMAX_ITER_BATHE =SIMP(statut='f',typ='I',defaut= 40,val_min=0 ),
           PREC_JACOBI     =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           NMAX_ITER_JACOBI=SIMP(statut='f',typ='I',defaut= 12,val_min=0 ),
         ),
         b_sorensen =BLOC(condition = "METHODE == 'SORENSEN'",
           PREC_SOREN      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),
           NMAX_ITER_SOREN =SIMP(statut='f',typ='I',defaut= 20,val_min=0 ),
           PARA_ORTHO_SOREN=SIMP(statut='f',typ='R',defaut= 0.717),
         ),
         b_qz =BLOC(condition = "METHODE == 'QZ'",
           TYPE_QZ      =SIMP(statut='f',typ='TXM',defaut="QZ_SIMPLE",into=("QZ_QR","QZ_SIMPLE","QZ_EQUI") ),
         ),
         MODE_RIGIDE          =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                               fr="Calcul des modes de corps rigide, uniquement pour la méthode TRI_DIAG" ),
         CALC_FREQ       =FACT(statut='d',min=0,
             OPTION      =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","PLUS_GRANDE","BANDE","CENTRE","TOUT"),
                                   fr="Choix de l option et par conséquent du shift du problème modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites fréquences propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut=10,val_min=0 ),
             ),
             b_plus_grande =BLOC(condition = "OPTION == 'PLUS_GRANDE'",fr="Recherche des plus grandes fréquences propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut=1,val_min=0 ),
             ),
             b_centre       =BLOC(condition = "OPTION == 'CENTRE'",
                                  fr="Recherche des fréquences propres les plus proches d une valeur donnée",
               FREQ            =SIMP(statut='o',typ='R',
                                     fr="Fréquence autour de laquelle on cherche les fréquences propres"),
               AMOR_REDUIT     =SIMP(statut='f',typ='R',),
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande         =BLOC(condition = "(OPTION == 'BANDE')",
                                   fr="Recherche des fréquences propres dans une bande donnée",
               FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max=2,
                                     fr="Valeurs des deux fréquences délimitant la bande de recherche"),
             ),
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG","COMPLEXE"),
                                   fr="Choix du pseudo-produit scalaire pour la résolution du problème quadratique" ),
             regles=(EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
             COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0 ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
             STOP_BANDE_VIDE =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),

        VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3,val_min=0.E+0 ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0,
                                 fr="Valeur limite admise pour l ereur a posteriori des modes" ),
           STURM           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mohamed.torkhani at edf.fr


CALC_MODE_ROTATION=MACRO(nom="CALC_MODE_ROTATION",
                         op=OPS('Macro.calc_mode_rotation_ops.calc_mode_rotation_ops'),
                         sd_prod=table_container,
                         reentrant='n',
                         fr="calculer les fréquences et modes d'un système en fonction des " \
                            "vitesses de rotation",
                         UIinfo={"groupes":("Résolution","Dynamique",)},

                  MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r ),
                  MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r ),
                  MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),
                  MATR_GYRO       =SIMP(statut='f',typ=matr_asse_depl_r ),
                  VITE_ROTA       =SIMP(statut='f',typ='R',max='**'),

                  METHODE         =SIMP(statut='f',typ='TXM',defaut="QZ",
                                        into=("QZ","SORENSEN",) ),

                  CALC_FREQ       =FACT(statut='d',min=0,
                         OPTION      =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","CENTRE",),
                                           fr="Choix de l option et par conséquent du shift du problème modal" ),
                  b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites valeurs propres",
                              NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
                              ),
                  b_centre       =BLOC(condition = "OPTION == 'CENTRE'",
                                fr="Recherche des valeurs propres les plus proches d une valeur donnée",
                              FREQ            =SIMP(statut='o',typ='R',
                                                     fr="Fréquence autour de laquelle on cherche les fréquences propres"),
                              AMOR_REDUIT     =SIMP(statut='f',typ='R',),
                              NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
                              ),
                             ),

                  VERI_MODE       =FACT(statut='d',min=0,
                  STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
                  SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
                  PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3 ),
                  STURM           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),),
);

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix at edf.fr
CALC_POINT_MAT=OPER(nom="CALC_POINT_MAT",op=33,sd_prod=table_sdaster,reentrant='f',
            UIinfo={"groupes":("Résolution",)},
            fr="Intégrer une loi de comportement",
     MATER           =SIMP(statut='o',typ=mater_sdaster,max=1),
     COMPORTEMENT    =C_COMPORTEMENT('CALC_POINT_MAT'),
     INCREMENT       =C_INCREMENT('MECANIQUE'),
     NEWTON          =C_NEWTON(),
     CONVERGENCE     =C_CONVERGENCE(),

    # --MASSIF : orientation du materiau (monocristal, orthotropie)
     MASSIF          =FACT(statut='f',max='**',
                    regles=(UN_PARMI('ANGL_REP','ANGL_EULER'),),
         ANGL_REP        =SIMP(statut='f',typ='R',min=1,max=3),
         ANGL_EULER      =SIMP(statut='f',typ='R',min=1,max=3),
      ),
    ## ANGLE : rotation de ANGLE autour de Z uniquement, et seulement pour les déformations imposées.
     ANGLE      =SIMP(statut='f',typ='R',max=1, defaut=0.),
     INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2)),

     regles=(
             EXCLUS('SIXX','EPXX',),
             EXCLUS('SIYY','EPYY',),
             EXCLUS('SIZZ','EPZZ',),
             EXCLUS('SIXY','EPXY',),
             EXCLUS('SIXZ','EPXZ',),
             EXCLUS('SIYZ','EPYZ',),

             ENSEMBLE('F11','F12','F13','F21','F22','F23','F31','F32','F33',),),

     SIXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     SIYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     SIZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     SIXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     SIXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     SIYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),

     EPXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     EPYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     EPZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     EPXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     EPXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     EPYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),

     F11 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F12 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F13 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F21 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F22 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F23 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F31 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F32 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
     F33 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),

     MATR_C1=FACT(statut='f',max='**',
           VALE          =SIMP(statut='o',typ='R',max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
           NUME_COLONNE  =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=12 ),
                              ),
     MATR_C2=FACT(statut='f',max='**',
           VALE          =SIMP(statut='o',typ='R',max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
           NUME_COLONNE  =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=12 ),
                              ),
     VECT_IMPO=FACT(statut='f',max=6,
           VALE          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
                              ),
     SIGM_INIT=FACT(statut='f',
            SIXX = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
            SIYY = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
            SIZZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
            SIXY = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
            SIXZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
            SIYZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
                       ),
     EPSI_INIT=FACT(statut='f',
            EPXX = SIMP(statut='o',typ='R',max=1),
            EPYY = SIMP(statut='o',typ='R',max=1),
            EPZZ = SIMP(statut='o',typ='R',max=1),
            EPXY = SIMP(statut='o',typ='R',max=1),
            EPXZ = SIMP(statut='o',typ='R',max=1),
            EPYZ = SIMP(statut='o',typ='R',max=1),
                       ),
     VARI_INIT=FACT(statut='f',
            VALE = SIMP(statut='o',typ='R',max='**'),
                       ),
     FORMAT_TABLE    =SIMP(statut='f',typ='TXM',max=1,into=("CMP_COLONNE","CMP_LIGNE",),defaut=("CMP_COLONNE"),),

     NB_VARI_TABLE  =SIMP(statut='f',typ='I',max=1,),

     OPER_TANGENT  =SIMP(statut='f',typ='TXM',max=1,into=("OUI","NON",),defaut="NON",),

     ARCHIVAGE       =FACT(statut='f',
       LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
       INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
       PAS_ARCH        =SIMP(statut='f',typ='I' ),
       PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-6),
                           ),


     # on permet certaines variables de commandes scalaires, définies par une fonction du temps
     # un mot clé caché qui ne sert qu'à boucler sur les VARC possibles :
     LIST_NOM_VARC =SIMP(statut='c',typ='TXM', defaut=("TEMP","CORR","IRRA","HYDR","SECH","EPSA",
                                                           "M_ACIER","M_ZIRC","NEUT1","NEUT2")),

     AFFE_VARC    = FACT(statut='f',max='**',
      NOM_VARC        =SIMP(statut='o',typ='TXM', into=("TEMP","CORR","IRRA","HYDR","SECH","M_ACIER","M_ZIRC",
                                                        "EPSA","NEUT1","NEUT2")),
      VALE_FONC   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),

      # VALE_REF est nécessaire pour certaines VARC :
      B_VALE_REF          =BLOC(condition="NOM_VARC in ('TEMP', 'SECH')",
           VALE_REF          =SIMP(statut='o',typ='R'),
      ),
      ),



     );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: sylvie.michel-ponnelle at edf.fr


CALC_PRECONT=MACRO(nom="CALC_PRECONT",
                   op=OPS('Macro.calc_precont_ops.calc_precont_ops'),
                   sd_prod=evol_noli,
                   fr="Imposer la tension définie par le BPEL dans les cables",
                   reentrant='f',UIinfo={"groupes":("Modélisation",)},
         reuse =SIMP(statut='f',typ='evol_noli'),
         MODELE           =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER       =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM        =SIMP(statut='o',typ=cara_elem),
         CABLE_BP         =SIMP(statut='o',typ=cabl_precont,validators=NoRepeat(),max='**'),
         CABLE_BP_INACTIF =SIMP(statut='f',typ=cabl_precont,validators=NoRepeat(),max='**'),
         INCREMENT        =C_INCREMENT('MECANIQUE'),
         RECH_LINEAIRE    =C_RECH_LINEAIRE(),
         CONVERGENCE      =C_CONVERGENCE(),
         ETAT_INIT       =FACT(statut='f',
            regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI',),
                    EXCLUS('EVOL_NOLI','DEPL',),
                    EXCLUS('EVOL_NOLI','SIGM',),
                    EXCLUS('EVOL_NOLI','VARI',),
                    EXCLUS('NUME_ORDRE','INST'), ),
            DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
            SIGM            =SIMP(statut='f',typ=(carte_sdaster,cham_elem)),
            VARI            =SIMP(statut='f',typ=cham_elem),
            EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
            NUME_ORDRE      =SIMP(statut='f',typ='I'),
            INST            =SIMP(statut='f',typ='R'),
            CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
            b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                PRECISION       =SIMP(statut='o',typ='R',),),
            NUME_DIDI       =SIMP(statut='f',typ='I'),
            INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
          ),
         METHODE = SIMP(statut='d',typ='TXM',defaut="NEWTON",into=("NEWTON","IMPLEX")),
         b_meth_newton = BLOC(condition = "METHODE == 'NEWTON'",
                           NEWTON = C_NEWTON(),
                        ),
         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('CALC_PRECONT'),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),

         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_meca),
         ),

         COMPORTEMENT       =C_COMPORTEMENT(),
  )  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

# person_in_charge: mathieu.corus at edf.fr


CALC_SPEC=MACRO(nom="CALC_SPEC",
                op=OPS('Macro.calc_spec_ops.calc_spec_ops'),
                sd_prod=interspectre,
                reentrant='n',
                fr="Calcule une matrice interspectrale ou des fonctions de transferts",
                UIinfo={"groupes":("Fonctions",)},
         TAB_ECHANT      =FACT(statut='f',
           NOM_TAB                  =SIMP(statut='o',typ=table_sdaster),
           LONGUEUR_DUREE           =SIMP(statut='f',typ='R'),
           LONGUEUR_POURCENT        =SIMP(statut='f',typ='R'),
           LONGUEUR_NB_PTS          =SIMP(statut='f',typ='I'),
           RECOUVREMENT_DUREE       =SIMP(statut='f',typ='R'),
           RECOUVREMENT_POURCENT    =SIMP(statut='f',typ='R'),
           RECOUVREMENT_NB_PTS      =SIMP(statut='f',typ='I'),
                              ),
         ECHANT          =FACT(statut='f',max='**',
           NUME_ORDRE_I    =SIMP(statut='o',typ='I' ),
           NUME_MES        =SIMP(statut='o',typ='I' ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster),
                              ),
#-- Cas de la matrice interspectrale --#
         INTERSPE        =FACT(statut='f',
           FENETRE         =SIMP(statut='f',typ='TXM',defaut="RECT",into=("RECT","HAMM","HANN","EXPO","PART",)),
           BLOC_DEFI_FENE  =BLOC(condition = "FENETRE == 'EXPO' or FENETRE == 'PART' ",
             DEFI_FENE       =SIMP(statut='f',typ='R',max='**'),
                                 ),
                              ),
#-- Cas des transferts - estimateurs H1 / H2 / Hv + Coherence --#
         TRANSFERT       =FACT(statut='f',
           ESTIM           =SIMP(statut='f',typ='TXM',defaut="H1",into=("H1","H2","CO",)),
           REFER           =SIMP(statut='o',typ='I',max='**'),
           FENETRE         =SIMP(statut='f',typ='TXM',defaut="RECT",into=("RECT","HAMM","HANN","EXPO","PART",)),
#           DEFI_FENE       =SIMP(statut='f',typ='R',max='**'),
           BLOC_DEFI_FENE  =BLOC(condition = "FENETRE == 'EXPO' or FENETRE == 'PART' ",
             DEFI_FENE       =SIMP(statut='f',typ='R',max='**'),
                                 ),
                              ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
CALC_STABILITE=MACRO(nom="CALC_STABILITE",sd_prod=table_container,
               op=OPS('Macro.calc_stabilite_ops.calc_stabilite_ops'),
               fr="post-traitement modes non-linéaires : filtre resultats et calcul de stabilité",
               reentrant='f',
               UIinfo={"groupes":("Résolution","Dynamique",)},

               reuse =SIMP(statut='f',typ='table_container'),

               MODE_NON_LINE = SIMP(statut='o',typ=table_container,max=1),
               SCHEMA_TEMPS = FACT(statut='d',max=1,
                                   SCHEMA = SIMP(statut='f',typ='TXM',into=('NEWMARK',),defaut='NEWMARK'),
                                   b_newmark= BLOC(condition="SCHEMA=='NEWMARK'",
                                                NB_INST = SIMP(statut='f',typ='I',defaut= 1000 ),
                                                ),
                                  ),
               TOLERANCE  = SIMP(statut='f',typ='R',defaut= 1.E-2 ),

               FILTRE = FACT(statut='f',max=1,regles=(UN_PARMI('NUME_ORDRE','FREQ_MIN',),),
                             NUME_ORDRE = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                             FREQ_MIN = SIMP(statut='f',typ='R' ),
                             b_freq_min = BLOC(condition = "FREQ_MIN != None",
                                               FREQ_MAX = SIMP(statut='o',typ='R' ),
                                               PRECISION = SIMP(statut='f',typ='R',defaut= 1.E-3 ),
                                               ),
                             ),

               INFO = SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;




# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def calc_table_prod(self, TABLE, ACTION, **kargs):
   """Typage du concept produit.
   """
   l_typ = [AsType(TABLE),]
   for mcf in ACTION:
      dmc = mcf.cree_dict_valeurs(mcf.mc_liste)
      if dmc.get('TABLE') != None:
         l_typ.append(AsType(dmc['TABLE']))
   # une table_fonction étant une table
   if table_fonction in l_typ:
      return table_fonction
   elif table_container in l_typ:
      return table_container
   else:
      return table_sdaster

CALC_TABLE=MACRO(nom="CALC_TABLE",
                 op=OPS('Macro.calc_table_ops.calc_table_ops'),
                 sd_prod=calc_table_prod,
                 fr="Opérations sur une table",
                 UIinfo={"groupes":("Tables",)},
                 reentrant='f',
   TABLE  = SIMP(statut='o',typ=table_sdaster),
   ACTION = FACT(statut='o', max='**',
                    fr = "Suite des opérations à effectuer sur la table",
      OPERATION = SIMP(statut='o', typ='TXM',
                  into=('FILTRE', 'EXTR', 'RENOMME', 'TRI', 'COMB', 'AJOUT_LIGNE',
                        'OPER', 'SUPPRIME', 'AJOUT_COLONNE')),

      b_filtre = BLOC(condition="OPERATION == 'FILTRE'",
                      fr="Sélectionne les lignes de la table vérifiant un critère",
         NOM_PARA  = SIMP(statut='o',typ='TXM'),
         CRIT_COMP = SIMP(statut='f',typ='TXM',defaut="EQ",
                          into=('EQ','NE','GT','LT','GE','LE','REGEXP',
                                'VIDE','NON_VIDE','MAXI','MAXI_ABS','MINI','MINI_ABS'),),
         b_vale = BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
            regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
            VALE   = SIMP(statut='f',typ='R',max='**'),
            VALE_I = SIMP(statut='f',typ='I',max='**'),
            VALE_C = SIMP(statut='f',typ='C',max='**'),
            VALE_K = SIMP(statut='f',typ='TXM',max='**'),
         ),
         b_regexp = BLOC(condition = "CRIT_COMP == 'REGEXP'",
            VALE_K = SIMP(statut='o',typ='TXM',),
         ),
         b_crit = BLOC(condition = "CRIT_COMP in ('EQ','NE')",
            CRITERE   = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            PRECISION = SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ),
      ),

      b_extr = BLOC(condition="OPERATION ==  'EXTR'",
                    fr="Extrait une ou plusieurs colonnes de la table",
         NOM_PARA = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                         fr="Noms des colonnes à extraire"),
      ),

      b_suppr = BLOC(condition="OPERATION ==  'SUPPRIME'",
                    fr="Supprime une ou plusieurs colonnes de la table",
         NOM_PARA = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                         fr="Noms des colonnes à supprimer"),
      ),

      b_renomme = BLOC(condition="OPERATION == 'RENOMME'",
                       fr="Renomme un ou plusieurs paramètres de la table",
         NOM_PARA = SIMP(statut='o', typ='TXM', validators=NoRepeat(), min=2, max=2,
                         fr="Couple (ancien nom du paramètre, nouveau nom du paramètre)",),
      ),

      b_tri = BLOC(condition="OPERATION == 'TRI'",
                   fr="Ordonne les lignes de la table selon les valeurs d'un ou plusieurs paramètres",
         NOM_PARA = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
         ORDRE    = SIMP(statut='f',typ='TXM',defaut="CROISSANT",
                         into=("CROISSANT","DECROISSANT") ),
      ),

      b_comb = BLOC(condition="OPERATION == 'COMB'",
                    fr="Combine deux tables ayant éventuellement des paramètres communs",
         TABLE    = SIMP(statut='o',typ=table_sdaster,
                         fr="Table dont les colonnes vont venir surcharger la table initiale"),
         NOM_PARA = SIMP(statut='f',typ='TXM',max='**',
                         fr="Noms des paramètres dont les valeurs doivent etre identiques dans les deux tables "\
                            "pour que les colonnes soient combinées"),
         RESTREINT = SIMP(statut='f', typ='TXM', into=('OUI', 'NON'), defaut='NON',
                          fr="Restreint la fusion uniquement aux lignes où les NOM_PARA sont communs"),
         FORMAT_R       =SIMP(statut='f',typ='TXM'),
      ),

      b_ajout_lig = BLOC(condition="OPERATION == 'AJOUT_LIGNE'",
                    fr="Ajoute une ligne à la table initiale",
         NOM_PARA = SIMP(statut='o',typ='TXM',max='**',
                         fr="Noms des paramètres dont les valeurs sont fournies sous VALE"),
         VALE     = SIMP(statut='o',typ=not_checked,max='**', fr='Valeurs des paramètres'),
      ),

      b_ajout_col = BLOC(condition="OPERATION == 'AJOUT_COLONNE'",
                    fr="Ajoute une colonne constante à la table initiale",
         NOM_PARA = SIMP(statut='o',typ='TXM',max='**',
                         fr="Noms des paramètres des colonnes à ajouter"),
         VALE   = SIMP(statut='o', typ=not_checked, max='**',
                       fr="Valeur constante pour chaque colonne"),
      ),

      b_oper = BLOC(condition="OPERATION == 'OPER'",
                    fr="Applique une formule dans laquelle les variables sont les paramètres de la table",
         FORMULE  = SIMP(statut='o',typ=formule,
                         fr="Formule à appliquer aux colonnes de la table"),
         NOM_PARA = SIMP(statut='o',typ='TXM',
                         fr="Nom de la nouvelle colonne"),
         NOM_COLONNE = SIMP(statut='f',typ='TXM', max='**',
                         fr="Nom des colonnes à utiliser en tant que paramètres de la formule"),
      ),
   ),

   TITRE = SIMP(statut='f',typ='TXM',max='**',
                fr="Titre de la table produite"),
   INFO  = SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

CALC_THETA=OPER(nom="CALC_THETA",op=54,sd_prod=theta_geom,reentrant='n',
            UIinfo={"groupes":("Post-traitements","Rupture",)},
                fr="Définir un champ theta pour le calcul du taux de restitution d'énergie"
                    +" ou des facteurs d'intensité de contraintes",
         regles=(UN_PARMI('THETA_2D','THETA_3D'),
                 PRESENT_ABSENT('THETA_2D','DIRE_THETA'),
                 EXCLUS('DIRECTION','DIRE_THETA'),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         THETA_3D        =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_NO','NOEUD'),
                   UN_PARMI('MODULE','MODULE_FO'),
                   ENSEMBLE('MODULE_FO','R_INF_FO','R_SUP_FO'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           MODULE          =SIMP(statut='f',typ='R'),
           R_INF           =SIMP(statut='f',typ='R'),
           R_SUP           =SIMP(statut='f',typ='R'),
           MODULE_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           R_INF_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           R_SUP_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                         ),
         b_theta_3d     =BLOC(condition="THETA_3D != None",
           FOND_FISS       =SIMP(statut='o',typ=fond_fiss),),
         DIRE_THETA      =SIMP(statut='f',typ=cham_no_sdaster ),
         DIRECTION       =SIMP(statut='f',typ='R',max='**'),
         THETA_2D        =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           MODULE          =SIMP(statut='o',typ='R'),
           R_INF           =SIMP(statut='o',typ='R'),
           R_SUP           =SIMP(statut='o',typ='R'),
         ),
         IMPRESSION      =FACT(statut='f',
           UNITE           =SIMP(statut='f',typ='I',defaut=8),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="EXCEL",into=("EXCEL","AGRAF") ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def calc_vect_elem_prod(OPTION,**args):
  if OPTION == "CHAR_MECA" :      return vect_elem_depl_r
  if OPTION == "CHAR_THER" :      return vect_elem_temp_r
  if OPTION == "CHAR_ACOU" :      return vect_elem_pres_c
  raise AsException("type de concept resultat non prevu")

CALC_VECT_ELEM=OPER(nom="CALC_VECT_ELEM",op=8,sd_prod=calc_vect_elem_prod,reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
                    fr="Calcul des seconds membres élémentaires",
         OPTION          =SIMP(statut='o',typ='TXM',into=("CHAR_MECA","CHAR_THER","CHAR_ACOU") ),
         b_char_meca     =BLOC(condition = "OPTION=='CHAR_MECA'",
           regles=(AU_MOINS_UN('CHARGE','MODELE'),),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           MODELE          =SIMP(statut='f',typ=modele_sdaster),
           b_charge     =BLOC(condition = "CHARGE != None", fr="modèle ne contenant pas de sous-structure",
              CHAM_MATER   =SIMP(statut='f',typ=cham_mater),
              CARA_ELEM    =SIMP(statut='f',typ=cara_elem),
              INST         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
              MODE_FOURIER =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           b_modele     =BLOC(condition = "(MODELE != None)",fr="modèle contenant une sous-structure",
              SOUS_STRUC      =FACT(statut='o',min=01,
                regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                SUPER_MAILLE=SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
              ),
           ),
         ),
         b_char_ther     =BLOC(condition = "OPTION=='CHAR_THER'",
           CARA_ELEM        =SIMP(statut='f',typ=cara_elem),
           CHARGE           =SIMP(statut='o',typ=char_ther,validators=NoRepeat(),max='**'),
           INST             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),

         b_char_acou     =BLOC(condition = "OPTION=='CHAR_ACOU'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater),
           CHARGE            =SIMP(statut='o',typ=char_acou,validators=NoRepeat(),max='**'),
         ),
) ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr

CALCUL=OPER(nom="CALCUL",op=26,sd_prod=table_container,reentrant='f',
            UIinfo={"groupes":("Résolution",)},
            fr="Calculer des objets élémentaires comme une matrice tangente, intégrer une loi de comportement, etc...",
     OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut="COMPORTEMENT",
                           into=( "COMPORTEMENT","MATR_TANG_ELEM","FORC_INTE_ELEM","FORC_NODA_ELEM"),),
     MODELE          =SIMP(statut='o',typ=modele_sdaster),
     CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
     CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
     TABLE           =SIMP(statut='f',typ=table_container),
     EXCIT           =FACT(statut='o',max='**',
       CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
       FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
       TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE",)),

     ),
     DEPL            =SIMP(statut='o',typ=cham_no_sdaster ),
     INCR_DEPL       =SIMP(statut='o',typ=cham_no_sdaster ),
     SIGM            =SIMP(statut='o',typ=cham_elem),
     VARI            =SIMP(statut='o',typ=cham_elem),
     INCREMENT       =FACT(statut='o',
          LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
          NUME_ORDRE      =SIMP(statut='o',typ='I'),),
     COMPORTEMENT       =C_COMPORTEMENT('CALCUL'),
     INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
) ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: sylvie.granet at edf.fr
#from Macro.chainage_thm_ops import chainage_thm_ops

def chainage_thm_prod(self,TYPE_CHAINAGE,TYPE_RESU = None,**args) :

  if TYPE_CHAINAGE == "MECA_HYDR" : return evol_varc

  if TYPE_CHAINAGE == "HYDR_MECA" :
    if TYPE_RESU == "CHAM_NO" :
      return cham_no_sdaster
    elif TYPE_RESU == "EVOL_VARC" :
      return evol_varc

  if TYPE_CHAINAGE == "INIT" :
    matr_mh  = args['MATR_MH']
    matr_hm1 = args['MATR_HM1']
    matr_hm2 = args['MATR_HM2']

    self.type_sdprod(matr_mh,corresp_2_mailla)
    self.type_sdprod(matr_hm1,corresp_2_mailla)
    self.type_sdprod(matr_hm2,corresp_2_mailla)
    return None

  raise AsException("type de chainage THM non prevu")

CHAINAGE_THM=MACRO(nom="CHAINAGE_THM",
                   op=OPS('Macro.chainage_thm_ops.chainage_thm_ops'),
                   sd_prod=chainage_thm_prod,
                   reentrant='n',
                   UIinfo={"groupes":("Résultats et champs",)},
                   docu="Ux.xx.xx",
                   fr="Calcul des variables de commande pour le chaînage THM",

         TYPE_CHAINAGE  = SIMP(statut='o',typ='TXM',
                               into=("HYDR_MECA","MECA_HYDR","INIT",),
                               fr="Sens du chaînage ou initialisation des matrices de projection"),

         # Cas HYDR_MECA :

         b_hydr_meca    = BLOC(condition = "TYPE_CHAINAGE == 'HYDR_MECA'",fr="Chaînage hydraulique vers mécanique",

             RESU_HYDR       = SIMP(statut='o',typ=resultat_sdaster,fr="Résultat hydraulique à chaîner" ),
             MODELE_MECA     = SIMP(statut='o',typ=modele_sdaster  ,fr="Modèle d'arrivée mécanique"),
             TYPE_RESU       = SIMP(statut='f',typ='TXM',into=("EVOL_VARC","CHAM_NO"),defaut="EVOL_VARC", ),
             MATR_HM1        = SIMP(statut='o',typ=corresp_2_mailla,),
             MATR_HM2        = SIMP(statut='o',typ=corresp_2_mailla,),

             b_type_resu     = BLOC(condition = "TYPE_RESU == 'EVOL_VARC'",fr="Instant obligatoire si TYPE_RESU=EVOL_VARC",
                                   INST = SIMP(statut='o',typ='R',validators=NoRepeat(),min=1,max=1),

           ),),

         # Cas MECA_HYDR :

         b_meca_hydr    = BLOC(condition = "TYPE_CHAINAGE == 'MECA_HYDR'",fr="Chaînage mécanique vers hydraulique",

             RESU_MECA       = SIMP(statut='o',typ=resultat_sdaster,fr="Résultat mécanique à chaîner" ),
             MODELE_HYDR     = SIMP(statut='o',typ=modele_sdaster  ,fr="Modèle d'arrivée hydraulique"),

             MATR_MH         = SIMP(statut='o',typ=corresp_2_mailla,),
             INST            = SIMP(statut='o',typ='R',validators=NoRepeat(),min=1,max=1),
           ),

         # Cas INIT :

         b_init    = BLOC(condition = "TYPE_CHAINAGE == 'INIT'",fr="Calcul des matrices de projection",

             MODELE_MECA     = SIMP(statut='o',typ=modele_sdaster  ,fr="Modèle mécanique"),
             MODELE_HYDR     = SIMP(statut='o',typ=modele_sdaster  ,fr="Modèle hydraulique"),

             MATR_MH         = SIMP(statut='o',typ=CO,),
             MATR_HM1        = SIMP(statut='o',typ=CO,),
             MATR_HM2        = SIMP(statut='o',typ=CO,),
           ),

         INFO     = SIMP(statut='f',typ='I',defaut=1,into=( 1, 2 ) ),

) ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
COMB_FOURIER=OPER(nom="COMB_FOURIER",op= 161,sd_prod=comb_fourier,
                  reentrant='n',fr="Recombiner les modes de Fourier d'une SD Résultat dans des directions particulières",
            UIinfo={"groupes":("Post-traitements",)},
         RESULTAT        =SIMP(statut='o',typ=(fourier_elas,fourier_ther),),
         ANGLE           =SIMP(statut='o',typ='R',max='**'),
         NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=6,into=("DEPL","REAC_NODA",
                               "SIEF_ELGA","EPSI_ELNO","SIGM_ELNO","TEMP","FLUX_ELNO"),),
) ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr
def comb_matr_asse_prod(COMB_R,COMB_C,CALC_AMOR_GENE,**args):
  if COMB_C != None:
    type_mat = AsType(COMB_C[0]['MATR_ASSE'])
    if type_mat in  (matr_asse_depl_c,matr_asse_depl_r) : return matr_asse_depl_c
    if type_mat in  (matr_asse_gene_c,matr_asse_gene_r) : return matr_asse_gene_c
    if type_mat in  (matr_asse_temp_c,matr_asse_temp_r) : return matr_asse_temp_c
    if type_mat in  (matr_asse_pres_c,matr_asse_pres_r) : return matr_asse_pres_c
  elif COMB_R != None:
    type_mat = AsType(COMB_R[0]['MATR_ASSE'])
    if type_mat in  (matr_asse_depl_c,matr_asse_depl_r) : return matr_asse_depl_r
    if type_mat in  (matr_asse_temp_c,matr_asse_temp_r) : return matr_asse_temp_r
    if type_mat in  (matr_asse_pres_c,matr_asse_pres_r) : return matr_asse_pres_r
    if type_mat in  (matr_asse_gene_c,matr_asse_gene_r) : return matr_asse_gene_r
  elif CALC_AMOR_GENE != None: return matr_asse_gene_r
  raise AsException("type de concept resultat non prevu")

COMB_MATR_ASSE=OPER(nom="COMB_MATR_ASSE",op=  31,sd_prod=comb_matr_asse_prod,
                    fr="Effectuer la combinaison linéaire de matrices assemblées",
                    reentrant='f',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(UN_PARMI('COMB_R','COMB_C','CALC_AMOR_GENE' ),),
         COMB_R          =FACT(statut='f',max='**',
           PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
           MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_temp_c
                                                ,matr_asse_pres_r,matr_asse_pres_c,matr_asse_gene_r,matr_asse_gene_c ) ),
           COEF_R          =SIMP(statut='o',typ='R' ),
         ),
         COMB_C          =FACT(statut='f',max='**',
           regles=(UN_PARMI('COEF_R','COEF_C' ),),
           MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_temp_c
                                                ,matr_asse_pres_r,matr_asse_pres_c,matr_asse_gene_r,matr_asse_gene_c ) ),
           COEF_R          =SIMP(statut='f',typ='R' ),
           COEF_C          =SIMP(statut='f',typ='C' ),
         ),
         CALC_AMOR_GENE   =FACT(statut='f',
           RIGI_GENE    = SIMP(statut='o', typ=matr_asse_gene_r),
           MASS_GENE    = SIMP(statut='o', typ=matr_asse_gene_r),
           regles=(UN_PARMI('AMOR_REDUIT','LIST_AMOR' ),),
           AMOR_REDUIT  = SIMP(statut='f',typ='R',max='**'),
           LIST_AMOR    = SIMP(statut='f',typ=listr8_sdaster ),
         ),
         SANS_CMP        =SIMP(statut='f',typ='TXM',into=("LAGR",) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: sylvie.audebert at edf.fr
COMB_SISM_MODAL=OPER(nom="COMB_SISM_MODAL",op= 109,sd_prod=mode_meca,
                     fr="Réponse sismique par recombinaison modale par une méthode spectrale",
                     reentrant='n',
            UIinfo={"groupes":("Post-traitements","Dynamique",)},
         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','FREQ','NUME_MODE','LIST_FREQ','LIST_ORDRE'),
                 UN_PARMI('AMOR_REDUIT','LIST_AMOR','AMOR_GENE' ),
                 UN_PARMI('MONO_APPUI','MULTI_APPUI' ),),
         MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         b_freq          =BLOC(condition = "FREQ != None or LIST_FREQ != None",
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
         MODE_CORR       =SIMP(statut='f',typ=mode_meca ),
         FREQ_COUP = SIMP(statut='f',typ='R',min=1,max=1),

         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r ),

         MASS_INER       =SIMP(statut='f',typ=table_sdaster ),
         CORR_FREQ       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),

         EXCIT           =FACT(statut='o',max='**',
           regles=(UN_PARMI('AXE','TRI_AXE','TRI_SPEC' ),),
           AXE             =SIMP(statut='f',typ='R',max=3,fr="Excitation suivant un seul axe",),
           TRI_AXE         =SIMP(statut='f',typ='R',max=3,fr="Excitation suivant les trois axes mais avec le meme spectre",),
           TRI_SPEC        =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Excitation suivant les trois axes  avec trois spectres"),
           b_axe           =BLOC(condition = "AXE != None",fr="Excitation suivant un seul axe",
             SPEC_OSCI       =SIMP(statut='o',typ=(nappe_sdaster,formule),),
             ECHELLE         =SIMP(statut='f',typ='R',),
           ),
           b_tri_axe       =BLOC(condition = "TRI_AXE != None",fr="Excitation suivant les trois axes mais avec le meme spectre",
             SPEC_OSCI       =SIMP(statut='o',typ=(nappe_sdaster,formule),),
             ECHELLE         =SIMP(statut='f',typ='R',),
           ),
           b_tri_spec      =BLOC(condition = "TRI_SPEC != None",fr="Excitation suivant les trois axes  avec trois spectres",
             SPEC_OSCI       =SIMP(statut='o',typ=(nappe_sdaster,formule),min=3,max=3 ),
             ECHELLE         =SIMP(statut='f',typ='R',min=3,max=3),
           ),
           NATURE          =SIMP(statut='f',typ='TXM',defaut="ACCE",into=("ACCE","VITE","DEPL") ),
           b_mult_appui    =BLOC(condition = "(MULTI_APPUI != None)",
                                 regles=(UN_PARMI('NOEUD','GROUP_NO' ),),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),)
         ),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="excitation imposée unique" ),
         MULTI_APPUI      =SIMP(statut='f',typ='TXM',position='global',into=("DECORRELE","CORRELE"),
                                 fr="excitation imposée unique" ),
         b_decorrele     =BLOC(condition = "MULTI_APPUI == 'DECORRELE' ",
           GROUP_APPUI     =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO' ),),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),),

         ),
         b_correle =BLOC(condition = "MULTI_APPUI == 'CORRELE' ",
           COMB_MULT_APPUI =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           TYPE_COMBI      =SIMP(statut='f',typ='TXM',into=("QUAD","LINE",) ),),
         ),

         COMB_MODE       =FACT(statut='o',
           TYPE            =SIMP(statut='o',typ='TXM',into=("SRSS","CQC","DSC","ABS","DPC","GUPTA") ),
           DUREE           =SIMP(statut='f',typ='R' ),
         b_gupta =BLOC(condition = "TYPE == 'GUPTA' ",
           FREQ_1      =SIMP(statut='o',typ='R',),
           FREQ_2      =SIMP(statut='o',typ='R',),
         ),      
         ),
         COMB_DIRECTION  =FACT(statut='f',
           TYPE            =SIMP(statut='f',typ='TXM',into=("QUAD","NEWMARK") ),
         ),
         COMB_DEPL_APPUI=FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','LIST_CAS'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           LIST_CAS       =SIMP(statut='f',typ='I',max='**'),
           TYPE_COMBI      =SIMP(statut='f',typ='TXM',into=("QUAD","LINE","ABS") ),
         ),
         DEPL_MULT_APPUI =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO'),
                   AU_MOINS_UN('DX','DY','DZ' ),),
           NOM_CAS         =SIMP(statut='o',typ='TXM',max='**'),
           NUME_CAS        =SIMP(statut='o',typ='I',max='**'),
           MODE_STAT       =SIMP(statut='o',typ=mode_meca, ),
           NOEUD_REFE      =SIMP(statut='f',typ=no),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DX              =SIMP(statut='f',typ='R' ),
           DY              =SIMP(statut='f',typ='R' ),
           DZ              =SIMP(statut='f',typ='R' ),
         ),
         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=9,
                               into=("DEPL","VITE","ACCE_ABSOLU","SIGM_ELNO","SIEF_ELGA",
                                     "EFGE_ELNO","REAC_NODA","FORC_NODA",
                                     "SIPO_ELNO") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
         IMPRESSION      =FACT(statut='f',max='**',
           regles=(EXCLUS('TOUT','NIVEAU'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NIVEAU          =SIMP(statut='f',typ='TXM',into=("SPEC_OSCI","MASS_EFFE","MAXI_GENE"),validators=NoRepeat(),max=3 ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def copier_prod(CONCEPT,**args):
   return AsType(CONCEPT)

# liste des types de concept acceptes par la commande :
copier_ltyp=(
  cabl_precont,
  listr8_sdaster,
  listis_sdaster,
  fonction_sdaster,
  nappe_sdaster,
  table_sdaster,
  maillage_sdaster,
  modele_sdaster,
  evol_elas,
  evol_noli,
  evol_ther,
)

COPIER=OPER(nom="COPIER",op= 185,sd_prod=copier_prod,reentrant='f',
            UIinfo={"groupes":("Gestion du travail",)},
            fr="Copier un concept utilisateur sous un autre nom",

            CONCEPT = SIMP(statut='o',typ=copier_ltyp,),
            INFO   = SIMP(statut='f', typ='I', into=(1, 2), defaut=1, ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def crea_champ_prod(TYPE_CHAM,**args):
  if TYPE_CHAM[0:5] == "CART_" :
     return carte_sdaster
  elif TYPE_CHAM[0:5] == "NOEU_" :
     return cham_no_sdaster
  elif TYPE_CHAM[0:2] == "EL"    :
     return cham_elem
  else :
     raise AsException("type de concept resultat_sdaster non prevu")


CREA_CHAMP=OPER(nom="CREA_CHAMP",op= 195,sd_prod=crea_champ_prod,
                fr="Création d'un champ ",reentrant='f',
            UIinfo={"groupes":("Résultats et champs",)},

       # TYPE_CHAM doit etre de la forme : CART_xx, NOEU_xx, ELEM_xx, ELGA_xx ou ELNO_xx
       # ou xx est le nom d'une grandeur définie dans le catalogue des grandeurs
         TYPE_CHAM       =SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO()),

#        SI CREATION D'UN CHAM_NO, POUR IMPOSER LA NUMEROTATION DES DDLS :
#        ------------------------------------------------------------------
         regles=(EXCLUS('NUME_DDL','CHAM_NO',)),
         NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster) ),
         CHAM_NO         =SIMP(statut='f',typ=(cham_no_sdaster) ),


#        AUTORISE-T-ON LE PROLONGEMENT DU CHAMP PAR ZERO ?
#        ------------------------------------------------------------------
#        CE MOT CLE N'A DE SENS QUE DANS 2 CAS DE FIGURE :
#          - POUR LES CHAM_ELEM (AVEC LE MOT CLE MODELE)
#          - POUR LES CHAM_NO SI ON IMPOSE LEUR NUMEROTATION
         b_prol_zero  =BLOC(condition = "NUME_DDL != None or CHAM_NO != None or (TYPE_CHAM != None and TYPE_CHAM[0:2] == 'EL')",
                 PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",)),),


#        SI CREATION D'UN CHAM_ELEM, POUR POUVOIR AIDER A L'ALLOCATION DU CHAMP :
#        (PAR DEFAUT : TOU_INI_ELNO/_ELGA/_ELEM)
#        ------------------------------------------------------------------
         OPTION         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),),


#        Si creation d'un cham_elem avec sous-points, pour que tous les sous-points
#        soient affectes : on duplique la valeur sur tous les sous-points
#        ------------------------------------------------------------------
         AFFE_SP         =FACT(statut='f',max=1,
             CARA_ELEM          =SIMP(statut='o',typ=cara_elem,min=1,max=1),
                             ),


#        LE MOT-CLE OPERATION EST OBLIGATOIRE. IL PERMET LE BON AIGUILLAGE.
#        ------------------------------------------------------------------
         OPERATION       =SIMP(statut='o',typ='TXM',into=("AFFE","ASSE","EVAL","EXTR","DISC","NORMALE","R2C","C2R","COMB") ),

#        ------------------------------------------------------------------
         b_norm          =BLOC(condition = "OPERATION == 'NORMALE'",
                               regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),),
             MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
             GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                             ),
#        ------------------------------------------------------------------
         b_affe          =BLOC(condition = "OPERATION == 'AFFE'",
             regles=(UN_PARMI('MAILLAGE','MODELE'),),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             AFFE            =FACT(statut='o',max='**',
                regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD',),
                        UN_PARMI('VALE','VALE_I','VALE_C','VALE_F', ),),
                TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
                MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
                NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
                NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
                VALE            =SIMP(statut='f',typ='R',max='**' ),
                VALE_I          =SIMP(statut='f',typ='I',max='**' ),
                VALE_C          =SIMP(statut='f',typ='C',max='**' ),
                VALE_F          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
                                   ),
                             ),
#        ------------------------------------------------------------------
         b_asse          =BLOC(condition = "OPERATION == 'ASSE'",
             regles=(UN_PARMI('MAILLAGE','MODELE'),),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             ASSE            =FACT(statut='o',max='**',
                regles=(AU_MOINS_UN('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD',),
                PRESENT_PRESENT('NOM_CMP_RESU','NOM_CMP', ),),
                TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                CHAM_GD         =SIMP(statut='o',typ=cham_gd_sdaster),
                NOM_CMP         =SIMP(statut='f',typ='TXM',max='**' ),
                NOM_CMP_RESU    =SIMP(statut='f',typ='TXM',max='**' ),
                CUMUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                COEF_R          =SIMP(statut='f',typ='R',defaut= 1. ),
                COEF_C          =SIMP(statut='f',typ='C',max=1),
                                    ),
                             ),
#        ------------------------------------------------------------------
         b_comb          =BLOC(condition = "OPERATION == 'COMB'",
                               fr="Pour faire une combinaison linéaire de cham_no ayant meme profil",
             COMB            =FACT(statut='o',max='**',
                CHAM_GD         =SIMP(statut='o',typ=cham_no_sdaster),
                COEF_R          =SIMP(statut='o',typ='R'),
                                   ),
                             ),
#        ------------------------------------------------------------------
         b_eval          =BLOC(condition = "OPERATION == 'EVAL'",
             CHAM_F          =SIMP(statut='o',typ=cham_gd_sdaster),
             CHAM_PARA       =SIMP(statut='o',typ=cham_gd_sdaster,max='**'),
                             ),
#        ------------------------------------------------------------------
         b_r2c           =BLOC(condition = "OPERATION == 'R2C'",
             CHAM_GD          =SIMP(statut='o',typ=cham_gd_sdaster),
                             ),
#        ------------------------------------------------------------------
         b_c2r           =BLOC(condition = "OPERATION == 'C2R'",
             CHAM_GD          =SIMP(statut='o',typ=cham_gd_sdaster),
             PARTIE           =SIMP(statut='o',typ='TXM',into=('REEL','IMAG','MODULE','PHASE'),),
                             ),
#        ------------------------------------------------------------------
         b_disc          =BLOC(condition = "OPERATION == 'DISC'",
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             CHAM_GD         =SIMP(statut='o',typ=cham_gd_sdaster),
                             ),
#        ------------------------------------------------------------------
         b_extr          =BLOC(condition = "OPERATION == 'EXTR'",
             regles=(AU_MOINS_UN('MAILLAGE','FISSURE','RESULTAT','TABLE','CARA_ELEM','CHARGE'),
                     PRESENT_ABSENT('MAILLAGE','FISSURE','RESULTAT','CARA_ELEM','CHARGE'),
                     PRESENT_ABSENT('FISSURE','MAILLAGE','RESULTAT','TABLE','CARA_ELEM','CHARGE'),
                     PRESENT_ABSENT('RESULTAT','FISSURE','MAILLAGE','TABLE','CARA_ELEM','CHARGE'),
                     PRESENT_ABSENT('TABLE','RESULTAT','FISSURE','CARA_ELEM','CHARGE'),
                     PRESENT_ABSENT('CARA_ELEM','MAILLAGE','TABLE','RESULTAT','FISSURE','CHARGE'),
                     PRESENT_ABSENT('CHARGE','MAILLAGE','TABLE','RESULTAT','FISSURE','CARA_ELEM'),
                     ),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             FISSURE         =SIMP(statut='f',typ=(fiss_xfem) ),
             RESULTAT        =SIMP(statut='f',typ=(resultat_sdaster) ),
             TABLE           =SIMP(statut='f',typ=(table_sdaster),min=1,max=1),
             CARA_ELEM       =SIMP(statut='f',typ=(cara_elem),min=1,max=1),
             CHARGE          =SIMP(statut='f',typ=(char_meca),min=1,max=1),
             b_extr_maillage =BLOC(condition = "MAILLAGE != None and TABLE == None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=("GEOMETRIE",)),
             ),

             b_extr_cara_elem =BLOC(condition = "CARA_ELEM != None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),
                 into=('.CARGENBA', '.CARMASSI', '.CARCABLE', '.CARCOQUE', '.CARGEOBA', '.CARDISCK',
                       '.CARARCPO', '.CARGENPO', '.CARDISCM', '.CARORIEN', '.CARDISCA', '.CVENTCXF',
                       '.CARPOUFL', '.CARGEOPO', '.CARDNSCK', '.CARDNSCM', '.CARDNSCA', '.CARDINFO',
                       '.CAFIBR',   '.CANBSP',)),
             ),

             b_extr_charge =BLOC(condition = "CHARGE != None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),
                 into=('.CHME.EPSIN', '.CHME.F1D1D', '.CHME.F1D2D', '.CHME.F1D3D', '.CHME.F2D2D',
                       '.CHME.F2D3D', '.CHME.F3D3D', '.CHME.FCO2D', '.CHME.FCO3D', '.CHME.FELEC',
                       '.CHME.FL101', '.CHME.FL102', '.CHME.FLUX',  '.CHME.FORNO', '.CHME.IMPE',
                       '.CHME.ONDE',  '.CHME.ONDPL', '.CHME.ONDPR', '.CHME.PESAN', '.CHME.PRESS',
                       '.CHME.ROTAT', '.CHME.SIGIN', '.CHME.SIINT', '.CHME.VNOR',)),
             ),

             b_extr_fissure  = BLOC(condition = "FISSURE != None",
                 NOM_CHAM=SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=("LTNO","LNNO",
                               "GRLTNO","GRLNNO","STNO","STNOR","BASLOC","GRI.LNNO","GRI.LTNO","GRI.GRLNNO","GRI.GRLTNO")),

             ),

             b_extr_table    =BLOC(condition = "TABLE != None",
                      MODELE          =SIMP(statut='f',typ=(modele_sdaster),),
                 ),
             b_extr_resultat =BLOC(condition = "RESULTAT != None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
                 TYPE_MAXI       =SIMP(statut='f',typ='TXM',into=("MAXI","MINI","MAXI_ABS","MINI_ABS","NORM_TRAN",) ),

                 # si TYPE_MAXI, on spécifie en général plusieurs numéros d'ordre :
                 b_type_maxi =BLOC(condition = "TYPE_MAXI != None",
                      TYPE_RESU       =SIMP(statut='o',typ='TXM',defaut="VALE",into=("VALE","INST",) ),

                      regles=(EXCLUS('TOUT_ORDRE','LIST_INST','LIST_FREQ','NUME_ORDRE','INST',
                                      'FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGLE'),),
                      TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                      LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
                      LIST_FREQ       =SIMP(statut='f',typ=(listr8_sdaster) ),
                      NUME_ORDRE      =SIMP(statut='f',typ='I',max='**'),
                      INST            =SIMP(statut='f',typ='R',max='**'),
                      FREQ            =SIMP(statut='f',typ='R',max='**'),
                      NUME_MODE       =SIMP(statut='f',typ='I',max='**'),
                      NOEUD_CMP       =SIMP(statut='f',typ='TXM',max='**'),
                      NOM_CAS         =SIMP(statut='f',typ='TXM',max='**'),
                      ANGLE           =SIMP(statut='f',typ='R',max='**'),
                 ),

                 # si .not. TYPE_MAXI, on ne doit spécifier qu'un seul numéro d'ordre :
                 b_non_type_maxi =BLOC(condition = "TYPE_MAXI == None",
                      regles=(EXCLUS('NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGLE'),),
                      NUME_ORDRE      =SIMP(statut='f',typ='I'),
                      INST            =SIMP(statut='f',typ='R'),
                      FREQ            =SIMP(statut='f',typ='R'),
                      NUME_MODE       =SIMP(statut='f',typ='I'),
                      NOEUD_CMP       =SIMP(statut='f',typ='TXM',max=2),
                      NOM_CAS         =SIMP(statut='f',typ='TXM'),
                      ANGLE           =SIMP(statut='f',typ='R'),

                      INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN",) ),
                 ),

                 CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
                 b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                     PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                 b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                     PRECISION       =SIMP(statut='o',typ='R',),),

         ),  # fin bloc b_extr


               ),
# FIN DU CATALOGUE : INFO,TITRE ET TYPAGE DU RESULTAT :
#-----------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr

def crea_elem_ssd_prod(self,NUME_DDL,**args):
    if NUME_DDL:
        self.type_sdprod(NUME_DDL,nume_ddl_sdaster)
    return macr_elem_dyna

CREA_ELEM_SSD=MACRO(nom="CREA_ELEM_SSD",
                    op=OPS('Macro.crea_elem_ssd_ops.crea_elem_ssd_ops'),
                    sd_prod=crea_elem_ssd_prod,
                    reentrant='n',
                    fr="Creation de macro-element dynamique en enchainant les commandes : "\
                       "CALC_MATR_ELEM, NUME_DDL, ASSE_MATRICE, MODE_ITER_SIMULT, "\
                       "DEFI_INTERF_DYNA, DEFI_BASE_MODALE et MACR_ELEM_DYNA",
                    UIinfo={"groupes":("Matrices/vecteurs",)},

# pour CAL_MATR_ELEM + NUME_DDL + ASSE_MATRICE + MODE_ITER_SIMULT + MODE_STATIQUE
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         NUME_DDL        =SIMP(statut='f',typ=CO,defaut=None),
         CHARGE          =SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**'),

# pour DEFI_INTERF_DYNA
         INTERFACE       =FACT(statut='o',max='**',
           regles=(ENSEMBLE('NOM','TYPE'),
                   UN_PARMI('NOEUD','GROUP_NO'),),
           NOM             =SIMP(statut='f',typ='TXM' ),
           TYPE            =SIMP(statut='f',typ='TXM',into=("MNEAL","CRAIGB","CB_HARMO",) ),
           NOEUD           =SIMP(statut='f',typ=no,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           FREQ            =SIMP(statut='f',typ='R',defaut= 1.),
         ),

# pour DEFI_BASE_MODALE
         BASE_MODALE = FACT(statut='o',max = 1,
           TYPE   =SIMP(statut='o',typ='TXM',max=1,into=('CLASSIQUE','RITZ',),),
           b_ritz = BLOC(condition = "TYPE == 'RITZ' ",fr="Base de type Ritz",
             TYPE_MODE  = SIMP(statut='f',typ='TXM',into=('STATIQUE','INTERFACE',),defaut='INTERFACE',),
             b_intf = BLOC(condition = "TYPE_MODE == 'INTERFACE' ",
                      NMAX_MODE_INTF  =SIMP(statut='f',typ='I',defaut=10,val_min=1),),
           ),
         ),

         INFO          =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

#-------------------------------------------------------------------
# Catalogue commun SOLVEUR (pour MODE_ITER_SIMULT, MODE_STATIQUE, DEFI_BASE_MODALE)
         SOLVEUR         =C_SOLVEUR('CREA_ELEM_SSD'),
#-------------------------------------------------------------------

# pour le calcul modal
         CALC_FREQ       =FACT(statut='d',min=0,
             STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             OPTION      =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","BANDE","CENTRE","SANS"),
                                   fr="Choix de l option et par consequent du shift du probleme modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites valeurs propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_centre       =BLOC(condition = "OPTION == 'CENTRE'",
                                  fr="Recherche des valeurs propres les plus proches d une valeur donnee",
               FREQ            =SIMP(statut='o',typ='R',
                                     fr="Frequence autour de laquelle on cherche les frequences propres"),
               AMOR_REDUIT     =SIMP(statut='f',typ='R',),
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande         =BLOC(condition = "(OPTION == 'BANDE')",
                                   fr="Recherche des valeurs propres dans une bande donnee",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 9999,val_min=0 ),
               FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max='**',
                                     fr="Valeurs des frequences delimitant les bandes de recherche"),
             ),
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG","COMPLEXE"),
                                   fr="Choix du pseudo-produit scalaire pour la resolution du probleme quadratique" ),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
           ),


)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
CREA_MAILLAGE=OPER(nom="CREA_MAILLAGE",op= 167,sd_prod=maillage_sdaster,
            reentrant='n',fr="Crée un maillage à partir d'un maillage existant",
            UIinfo={"groupes":("Maillage",)},
         regles=(UN_PARMI('COQU_VOLU', 'CREA_FISS', 'CREA_GROUP_MA', 'CREA_MAILLE', 'CREA_POI1',
                        'DETR_GROUP_MA', 'ECLA_PG', 'HEXA20_27', 'LINE_QUAD', 'MODI_MAILLE',
                        'QUAD_LINE', 'REPERE','RESTREINT','PENTA15_18','GEOM_FIBRE'),),



         # le MAILLAGE est inutile si ECLA_PG et GEOM_FIBRE
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         GEOM_FIBRE           = SIMP(statut='f',max=1,typ=gfibre_sdaster),

         CREA_POI1       =FACT(statut='f',max='**',fr="Création de mailles de type POI1 à partir de noeuds",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD' ),),
           NOM_GROUP_MA    =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         ),
         CREA_MAILLE     =FACT(statut='f',max='**',fr="Duplication de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM' ),
           PREF_NUME       =SIMP(statut='f',typ='I' ),
         ),
         CREA_GROUP_MA   =FACT(statut='f',max='**',fr="Duplication de mailles et création de groupes de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           NOM             =SIMP(statut='o',typ='TXM'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM' ),
           PREF_NUME       =SIMP(statut='f',typ='I' ),
         ),
         DETR_GROUP_MA   =FACT(statut='f',fr="Destruction de groupes de mailles",
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           NB_MAILLE       =SIMP(statut='f',typ='I',defaut= 0,
                                 fr="Nombre minimal de mailles que doit contenir le groupe pour etre détruit",  ),
         ),
         RESTREINT   =FACT(statut='f',fr="Restreindre un maillage à des groupes de mailles",max=1,
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           TOUT_GROUP_MA   =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           TOUT_GROUP_NO   =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON'),),
         ),
         COQU_VOLU   =FACT(statut='f',
                           fr="Creation de mailles volumiques à partir de mailles surfaciques",
           NOM             =SIMP(statut='o',typ='TXM'),
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max ='**'),
           EPAIS           =SIMP(statut='o',typ='R' ),
           PREF_MAILLE     =SIMP(statut='f',typ='TXM',defaut="MS" ),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS" ),
           PREF_NUME       =SIMP(statut='f',typ='I'  ,defaut=1 ),
           PLAN            =SIMP(statut='o',typ='TXM',into=("SUP","MOY","INF")),
           b_MOY =BLOC(condition = "PLAN == 'MOY'",
             TRANSLATION   =SIMP(statut='o',typ='TXM',into=("SUP","INF") ),
           ),
         ),
         MODI_MAILLE     =FACT(statut='f',max='**',fr="Modification du type de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma  ,validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='o',typ='TXM',into=("TRIA6_7","QUAD8_9","SEG3_4","QUAD_TRIA3"),validators=NoRepeat(),
                                 fr="Choix de la transformation" ),
           b_NOS =BLOC(condition = "OPTION == 'TRIA6_7'  or  OPTION == 'QUAD8_9'  or  OPTION == 'SEG3_4'",
             PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
             PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
           ),
           b_QTR =BLOC(condition = "OPTION == 'QUAD_TRIA3'",
             PREF_MAILLE     =SIMP(statut='f',typ='TXM',defaut="MS" ),
             PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
           ),
         ),
         CREA_FISS = FACT(statut='f',max='**',fr="Creation d'une fissure potentielle avec elts de joint ou elts à disc",
           NOM             =SIMP(statut='o',typ='TXM'),
           GROUP_NO_1      =SIMP(statut='o',typ=grno),
           GROUP_NO_2      =SIMP(statut='o',typ=grno),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM'),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut=1 ),
         ),
         LINE_QUAD     =FACT(statut='f',fr="Passage linéaire -> quadratique",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma  ,validators=NoRepeat(),max='**'),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
         ),
         HEXA20_27     =FACT(statut='f',fr="Passage HEXA20 -> HEXA27",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma  ,validators=NoRepeat(),max='**'),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
         ),
         PENTA15_18     =FACT(statut='f',fr="Passage PENTA15 -> PENTA18",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma  ,validators=NoRepeat(),max='**'),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
         ),
         QUAD_LINE     =FACT(statut='f',fr="Passage quadratique -> linéaire",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma  ,validators=NoRepeat(),max='**'),
         ),
         REPERE          =FACT(statut='f',max='**',
                               fr="changement de repère servant à déterminer les caractéristiques d'une section de poutre",
           TABLE           =SIMP(statut='o',typ=table_sdaster,
                                 fr="Nom de la table contenant les caractéristiques de la section de poutre" ),
           NOM_ORIG        =SIMP(statut='f',typ='TXM',into=("CDG","TORSION"),fr="Origine du nouveau repère" ),
           NOM_ROTA        =SIMP(statut='f',typ='TXM',into=("INERTIE",),fr="Direction du repére"  ),
           b_cdg =BLOC(condition = "NOM_ORIG == 'CDG'",
             GROUP_MA        =SIMP(statut='f',typ=grma,
                                   fr="Nom du groupe de mailles dont le centre de gravité sera l origine du nouveau repère"),
           ),
         ),
         ECLA_PG         =FACT(statut='f',
                               fr="Eclatement des mailles en petites mailles contenant chacune un seul point de gauss",
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SHRINK          =SIMP(statut='f',typ='R',defaut= 0.9, fr="Facteur de réduction" ),
           TAILLE_MIN      =SIMP(statut='f',typ='R',defaut= 0.0, fr="Taille minimale d'un coté" ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO('ELGA'),),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
#
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
def crea_resu_prod(TYPE_RESU,**args):
  if TYPE_RESU == "EVOL_ELAS"    : return evol_elas
  if TYPE_RESU == "EVOL_NOLI"    : return evol_noli
  if TYPE_RESU == "EVOL_THER"    : return evol_ther
  if TYPE_RESU == "MULT_ELAS"    : return mult_elas
  if TYPE_RESU == "MODE_MECA"    : return mode_meca
  if TYPE_RESU == "DYNA_TRANS"   : return dyna_trans
  if TYPE_RESU == "DYNA_HARMO"   : return dyna_harmo
  if TYPE_RESU == "FOURIER_ELAS" : return fourier_elas
  if TYPE_RESU == "FOURIER_THER" : return fourier_ther
  if TYPE_RESU == "EVOL_VARC"    : return evol_varc
  if TYPE_RESU == "EVOL_CHAR"    : return evol_char
  raise AsException("type de concept resultat non prevu")

CREA_RESU=OPER(nom="CREA_RESU",op=124,sd_prod=crea_resu_prod,reentrant='f',
            UIinfo={"groupes":("Resultats et champs",)},
               fr="Creer ou enrichir une structure de donnees resultat a partir de champs aux noeuds",

         OPERATION =SIMP(statut='o',typ='TXM',into=("AFFE","ASSE","ECLA_PG","PERM_CHAM","PROL_RTZ","PREP_VRC1","PREP_VRC2",),
                         fr="choix de la fonction a activer",),
                         
         TYPE_RESU    =SIMP(statut='o',position='global',typ='TXM',
                            into=(
                                  # pour bloc AFFE                         
                                    "MODE_MECA","MULT_ELAS","EVOL_ELAS","EVOL_NOLI","DYNA_HARMO","DYNA_TRANS",
                                    "FOURIER_ELAS","EVOL_THER","EVOL_VARC","EVOL_CHAR","FOURIER_THER"
                                  # pour bloc ASSE 
                                  # "EVOL_THER "
                                  # pour bloc ECLA_PG
                                  # "EVOL_ELAS","EVOL_NOLI","EVOL_THER" 
                                  # pour bloc PERM_CHAM
                                  # "EVOL_NOLI"
                                  # pour bloc PROL_RTZ
                                  # "EVOL_THER"
                                  # pour bloc PREP_VRC1
                                  # "EVOL_THER"
                                  # pour bloc PREP_VRC2
                                  # "EVOL_THER"
                                  ),
                           ),


         # Creation par affectation de champs :
         #-------------------------------------
         b_affe       =BLOC(condition = "OPERATION == 'AFFE'",

           b_type_resu    =BLOC(condition = "TYPE_RESU == 'EVOL_CHAR'",
             NOM_CHAM     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=("PRES",
                                    "FSUR_2D","FSUR_3D","FVOL_2D","FVOL_3D","VITE_VENT")),
           ),

           b_evol_char    =BLOC(condition = "TYPE_RESU != 'EVOL_CHAR'",
             NOM_CHAM     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
           ),

           b_mode       =BLOC(condition = "au_moins_un(TYPE_RESU, ('MODE_MECA', 'DYNA_HARMO', 'DYNA_TRANS'))",
             MATR_RIGI     =SIMP(statut='f',typ=matr_asse_depl_r,),
             MATR_MASS     =SIMP(statut='f',typ=matr_asse_depl_r,),
           ),          
#
#  pour ajouter un comportement dans la SD
#                
           COMPORTEMENT     =C_COMPORTEMENT(),
#
#  pour ajouter une charge dans la SD
#     
           b_evol_elas  = BLOC(condition="TYPE_RESU=='EVOL_ELAS'",
           EXCIT           =FACT(statut='f',max='**',
             CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
             FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),),
            ),
      
           b_evol_ther  = BLOC(condition="TYPE_RESU=='EVOL_THER'",
           EXCIT           =FACT(statut='f',max='**',
             CHARGE          =SIMP(statut='o',typ=(char_ther,char_cine_ther)),
             FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),),
            ),
      
           b_evol_noli  = BLOC(condition="TYPE_RESU=='EVOL_NOLI'",
           EXCIT           =FACT(statut='f',max='**',
            CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
            FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                  into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
            DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
            DIRECTION       =SIMP(statut='f',typ='R',max='**'),
            NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),),
           ),


           AFFE         =FACT(statut='o',max='**',
             CHAM_GD       =SIMP(statut='o',typ=(cham_gd_sdaster)),
             MODELE        =SIMP(statut='f',typ=modele_sdaster),
             CHAM_MATER    =SIMP(statut='f',typ=cham_mater),
             CARA_ELEM     =SIMP(statut='f',typ=cara_elem),

#
             b_mult_elas     =BLOC(condition = "TYPE_RESU == 'MULT_ELAS' ",
                NOM_CAS         =SIMP(statut='f',typ='TXM' ),
                CHARGE          =SIMP(statut='f',typ=(char_meca),max='**'),
             ),
             b_evol          =BLOC(condition = "au_moins_un(TYPE_RESU, ('EVOL_ELAS', 'EVOL_NOLI', \
                                        'EVOL_THER', 'EVOL_VARC', 'EVOL_CHAR', 'DYNA_TRANS'))",
                regles=(UN_PARMI('INST','LIST_INST'),),
                INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
                NUME_INIT       =SIMP(statut='f',typ='I', val_min=1),
                NUME_FIN        =SIMP(statut='f',typ='I', val_min=1),
                PRECISION       =SIMP(statut='f',typ='R',defaut= 0.0 ),
                CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             ),
             b_fourier_elas  =BLOC(condition = "(TYPE_RESU == 'FOURIER_ELAS') ",
                NUME_MODE       =SIMP(statut='f',typ='I'),
                TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="SYME",into=("SYME","ANTI","TOUS") ),
                CHARGE          =SIMP(statut='f',typ=(char_meca),max='**'),
             ),
             b_fourier_ther  =BLOC(condition = "(TYPE_RESU == 'FOURIER_THER') ",
                NUME_MODE       =SIMP(statut='f',typ='I'),
                TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="SYME",into=("SYME","ANTI","TOUS") ),
             ),
             b_mode       =BLOC(condition = "TYPE_RESU == 'MODE_MECA'",
                NUME_MODE       =SIMP(statut='f',typ='I'),
                FREQ            =SIMP(statut='f',typ='R'),
             ),
             b_dyna_harmo       =BLOC(condition = "TYPE_RESU == 'DYNA_HARMO'",
                regles=(UN_PARMI('FREQ','LIST_FREQ',),),
                FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
                CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                PRECISION       =SIMP(statut='f',typ='R',defaut=0.0),
             ),
           ),
         ),


         # Creation par assemblage d'evol_ther :
         #-----------------------------------------
         b_asse       =BLOC(condition = "OPERATION == 'ASSE'",
           ASSE         =FACT(statut='o',max='**',
             RESULTAT       =SIMP(statut='o',typ=evol_ther),
             TRANSLATION    =SIMP(statut='f',typ='R',defaut= 0. ),
           ),
         ),


         b_ecla_pg    =BLOC(condition = "OPERATION == 'ECLA_PG'",

           ECLA_PG         =FACT(statut='o',
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO('ELGA'),),
             MODELE_INIT     =SIMP(statut='o',typ=modele_sdaster),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             RESU_INIT       =SIMP(statut='o',typ=resultat_sdaster),
             MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
           ),
         ),


         b_perm_cham =BLOC(condition = "OPERATION == 'PERM_CHAM'",

           NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","SIEF_ELGA","VARI_ELGA","STRX_ELGA"),
                                 validators=NoRepeat(),max='**'),
           RESU_INIT       =SIMP(statut='o',typ=evol_noli),
           INST_INIT       =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
               PRECISION       =SIMP(statut='o',typ='R',),),
           MAILLAGE_INIT   =SIMP(statut='o',typ=maillage_sdaster,),
           RESU_FINAL      =SIMP(statut='o',typ=evol_noli,),
           MAILLAGE_FINAL  =SIMP(statut='o',typ=maillage_sdaster,),
           PERM_CHAM       =FACT(statut='o',max='**',
              GROUP_MA_FINAL =SIMP(statut='o',typ=grma),
              GROUP_MA_INIT  =SIMP(statut='o',typ=grma),
              TRAN           =SIMP(statut='o',typ='R',min=3,max=3),
              PRECISION      =SIMP(statut='f',typ='R',defaut=1.0E-3),
           ),
         ),

         b_prol_rtz   =BLOC(condition = "OPERATION == 'PROL_RTZ'",

           PROL_RTZ        =FACT(statut='o',
              regles=(EXCLUS('INST','LIST_INST'),),
              MAILLAGE_FINAL  =SIMP(statut='o',typ=maillage_sdaster,),
              TABLE           =SIMP(statut='o',typ=table_sdaster,fr="Table issue de post_releve_t"),
              INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
              LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
              b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)",
                 CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                 b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                     PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                 b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                     PRECISION       =SIMP(statut='o',typ='R',),),
              ),
              PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU",),),
              PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU",),),
              REPERE          =SIMP(statut='o',typ='TXM',into=("CYLINDRIQUE",),),
              ORIGINE         =SIMP(statut='o',typ='R',min=3,max=3),
              AXE_Z           =SIMP(statut='o',typ='R',min=3,max=3),
           ),
         ),

         b_prep_vrc1      =BLOC(condition = "OPERATION == 'PREP_VRC1'",
           # calculer la temperature dans les couches des coques multicouche a partir d'un champ de fonctions
           # de fonctions du temps et de l'espace (epaisseur)

           PREP_VRC1        =FACT(statut='o',max=1,
             CHAM_GD       =SIMP(statut='o',typ=(cham_gd_sdaster)), # carte de fonctions du temps et de l'epaisseur
             MODELE        =SIMP(statut='o',typ=modele_sdaster),    # modele mecanique contenant les coques multicouche
             CARA_ELEM     =SIMP(statut='o',typ=cara_elem),         # CARA_ELEM pour connaitre EPAIS et COQU_NCOU
             INST          =SIMP(statut='o',typ='R',validators=NoRepeat(),max='**'),
           ),
         ),

         b_prep_vrc2      =BLOC(condition = "OPERATION == 'PREP_VRC2'",
           # calculer la temperature dans les couches des coques multicouche a partir d'un evol_ther "coque"
           # contenant TEMP_MIL/TEMP_INF/TEMP_SUP

           PREP_VRC2        =FACT(statut='o',max=1,
             EVOL_THER     =SIMP(statut='o',typ=(evol_ther)),       # evol_ther de type "coque" (TEMP_MIL/TEMP_INF/TEMP_SUP)
             MODELE        =SIMP(statut='o',typ=modele_sdaster),    # modele mecanique contenant les coques multicouche
             CARA_ELEM     =SIMP(statut='o',typ=cara_elem),         # CARA_ELEM pour connaitre EPAIS et COQU_NCOU

             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),

           ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def crea_table_prod(TYPE_TABLE, **args):
   """Typage du concept résultat
   """
   if TYPE_TABLE == 'TABLE_FONCTION':
      return table_fonction
   elif TYPE_TABLE == 'TABLE_CONTENEUR':
      return table_container
   else:
      return table_sdaster

CREA_TABLE=OPER(nom="CREA_TABLE",op=36,sd_prod=crea_table_prod,
                fr="Création d'une table à partir d'une fonction ou de deux listes",
                reentrant='f',
                UIinfo={"groupes":("Tables",)},

           regles=(EXCLUS('FONCTION','LISTE','RESU'),),

           LISTE=FACT(statut='f',max='**',
                 fr="Creation d'une table a partir de listes",
                 regles=(UN_PARMI('LISTE_I','LISTE_R','LISTE_K')),
                        PARA     =SIMP(statut='o',typ='TXM'),
                        TYPE_K   =SIMP(statut='f',typ='TXM',defaut='K8',
                                    into=('K8','K16','K24')),
                        NUME_LIGN=SIMP(statut='f',typ='I',max='**'),
                        LISTE_I  =SIMP(statut='f',typ='I',max='**'),
                        LISTE_R  =SIMP(statut='f',typ='R',max='**'),
                        LISTE_K  =SIMP(statut='f',typ='TXM', max='**'),
           ),
           FONCTION=FACT(statut='f',
                    fr="Creation d'une table a partir d'une fonction",
                        FONCTION=SIMP(statut='o',typ=(fonction_c,fonction_sdaster)),
                        PARA=SIMP(statut='f',typ='TXM',min=2,max=2),
           ),
           RESU=FACT(statut='f',max=1,
                fr="Creation d'une table a partir d'un resultat ou d'un champ",
                regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                        UN_PARMI('TOUT_CMP','NOM_CMP'),
                        PRESENT_ABSENT('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD',),
                        AU_MOINS_UN('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD',),
                        ),
                        CHAM_GD  =SIMP(statut='f',typ=cham_gd_sdaster),
                        RESULTAT =SIMP(statut='f',typ=(resultat_sdaster) ),
                        b_resultat   =BLOC(condition = "RESULTAT != None",
                               regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST',
                                              'MODE','LIST_MODE','FREQ','LIST_FREQ'),),
                               NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
                               TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               NUME_ORDRE      =SIMP(statut='f',typ='I',max='**'),
                               LIST_ORDRE      =SIMP(statut='f',typ=(listis_sdaster) ),
                               INST            =SIMP(statut='f',typ='R',max='**'),
                               LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
                               MODE            =SIMP(statut='f',typ='I',max='**'),
                               LIST_MODE       =SIMP(statut='f',typ=(listis_sdaster) ),
                               FREQ            =SIMP(statut='f',typ='R',max='**'),
                               LIST_FREQ       =SIMP(statut='f',typ=(listr8_sdaster) ),
                               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
                               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                                       PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                                       PRECISION       =SIMP(statut='o',typ='R',),),
                            ),
                        b_cham_gd   =BLOC(condition = "CHAM_GD != None",
                               CARA_ELEM       =SIMP(statut='f',typ=cara_elem),),
                      TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                      NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
                      TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                      GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                      GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                      MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                      NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                      ),

           TYPE_TABLE = SIMP(statut='f', typ='TXM', defaut="TABLE",
                             into=('TABLE', 'TABLE_FONCTION', 'TABLE_CONTENEUR'),),

           TITRE=SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr

DEBUG=PROC(nom="DEBUG",op=137,
            UIinfo={"groupes":("Utilitaires",)},
               fr="Permettre de changer entre 2 commandes quelques variables globales de debug",

     SDVERI          =SIMP(fr="vérifie la conformité des SD produites par les commandes",
                           statut='f',typ='TXM',into=('OUI','NON')),
     JXVERI          =SIMP(fr="vérifie l intégrité de la segmentation mémoire",
                           statut='f',typ='TXM',into=('OUI','NON')),
     JEVEUX          =SIMP(fr="force les déchargement sur disque",
                           statut='f',typ='TXM',into=('OUI','NON')),
     IMPR_MACRO      =SIMP(fr="affichage des sous-commandes produites par les macros dans le fichier mess",
                           statut='f',typ='TXM',into=("OUI","NON")),
 );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
DEBUT=MACRO(nom="DEBUT",
            op=OPS("Cata.ops.build_debut"),
            repetable='n',
            UIinfo={"groupes":("Gestion du travail",)},
            fr="Ouverture d'une étude. Allocation des ressources mémoire et disque et fichiers",
            sd_prod=ops.DEBUT,

         PAR_LOT         =SIMP(fr="mode de traitement des commandes",statut='f',typ='TXM',
                           into=("OUI","NON"),defaut="OUI"),
         IMPR_MACRO      =SIMP(fr="affichage des sous-commandes produites par les macros dans le fichier mess",
                           statut='f',typ='TXM',into=("OUI","NON"),defaut="NON"),
#         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
#                               typ='TXM',defaut="NON",into=("OUI","NON",) ),
         BASE            =FACT(fr="définition des paramètres associés aux bases JEVEUX",
                               statut='f',min=1,max=2,
           FICHIER         =SIMP(fr="nom de la base",statut='o',typ='TXM',
                                 into=('GLOBALE','VOLATILE'),),
           TITRE           =SIMP(statut='f',typ='TXM'),
           CAS             =SIMP(statut='f',typ='TXM'),
           NMAX_ENRE       =SIMP(fr="nombre maximum d enregistrements",statut='f',typ='I'),
           LONG_ENRE       =SIMP(fr="longueur des enregistrements",statut='f',typ='I'),
           LONG_REPE       =SIMP(fr="longueur du répertoire",statut='f',typ='I'),
         ),

         CATALOGUE       =FACT(statut='f',min=1,max=10,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I'),
         ),

         CODE            =FACT(fr="paramètres réservés aux cas-tests",
                               statut='f',min=1,max=1,
           NIV_PUB_WEB     =SIMP(statut='o',typ='TXM',into=('INTERNET','INTRANET')),
           VISU_EFICAS     =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI'),
         ),

         ERREUR          =FACT(fr="comportement en cas d'erreur",statut='f',min=1,max=1,
           ERREUR_F        =SIMP(statut='f',typ='TXM',into=('ABORT','EXCEPTION'),),
         ),

         DEBUG           =FACT(fr="option de déboggage reservée aux développeurs",
                               statut='f',min=1,max=1,
           JXVERI          =SIMP(fr="vérifie l intégrité de la segmentation mémoire",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           SDVERI          =SIMP(fr="vérifie la conformité des SD produites par les commandes",
                                 statut='f',typ='TXM',into=('OUI','NON')),
           JEVEUX          =SIMP(fr="force les déchargement sur disque",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           ENVIMA          =SIMP(fr="imprime les valeurs définies dans ENVIMA",
                                 statut='f',typ='TXM',into=('TEST',)),
           HIST_ETAPE = SIMP(fr="permet de conserver toutes les étapes du jeu de commandes",
                             statut='f', typ='TXM', into=('OUI', 'NON'), defaut='NON'),
         ),

         MESURE_TEMPS     =FACT(fr="Pour afficher le temps des principales étapes de calcul",
                               statut='d',min=1,max=1,
           NIVE_DETAIL      =SIMP(fr="niveau de détail des impressions",
                                 statut='f',typ='I',into=(0,1,2,3),defaut=1),
                                 # 0 : rien
                                 # 1 : impression en fin de commande des mesures principales
                                 # 2 : impression en fin de commande des mesures principales et secondaires
                                 # 3 : impression des mesures principales et secondaires pour chaque pas de temps
           MOYENNE     =SIMP(fr="affichage des moyennes et écart-types en parallèle",
                                  statut='f',typ='TXM',into=('OUI','NON',),defaut='NON'),
         ),

         MEMOIRE         =FACT(fr="mode de gestion mémoire utilisé",statut='d',min=1,max=1,
           TAILLE_BLOC       =SIMP(statut='f',typ='R',defaut=800.),
           TAILLE_GROUP_ELEM =SIMP(statut='f',typ='I',defaut=1000),
         ),

         RESERVE_CPU     =FACT(fr="reserve de temps pour terminer une execution",statut='d',max=1,
           regles=(EXCLUS('VALE','POURCENTAGE'),),
#          par défaut VALE fixée à 10. dans le FORTRAN si CODE présent
           VALE            =SIMP(statut='f',typ='I',val_min=0,),
#          par défaut 10% dans le FORTRAN
           POURCENTAGE     =SIMP(statut='f',typ='R',val_min=0.,val_max=1.0),
#          valeur en secondes de la réserve maximum bornée à 900 secondes
           BORNE           =SIMP(statut='f',typ='I',val_min=0,defaut=900),),

         IGNORE_ALARM = SIMP(statut='f', typ='TXM', max='**', fr="Alarmes que l'utilisateur souhaite délibérément ignorer"),

         LANG = SIMP(statut='f', typ='TXM',
                     fr="Permet de choisir la langue utilisée pour les messages (si disponible)",
                     ang="Allows to choose the language used for messages (if available)"),

         INFO     = SIMP(statut='f', typ='I', defaut=1, into=(1,2),),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr
DEFI_BASE_MODALE=OPER(nom="DEFI_BASE_MODALE",op=  99,sd_prod=mode_meca,
                     reentrant='f',
                     fr="Définit la base d'une sous-structuration dynamique ou d'une recombinaison modale",
            UIinfo={"groupes":("Matrices et vecteurs","Dynamique",)},
         regles=(UN_PARMI('CLASSIQUE','RITZ','DIAG_MASS','ORTHO_BASE'),),
         CLASSIQUE       =FACT(statut='f',
           INTERF_DYNA     =SIMP(statut='o',typ=interf_dyna_clas ),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca,max='**' ),
           NMAX_MODE       =SIMP(statut='f',typ='I',defaut=10,max='**' ),
         ),
         RITZ            =FACT(statut='f',max='**',
           regles=(UN_PARMI('MODE_MECA','BASE_MODALE','MODE_INTF'),),
           MODE_MECA       =SIMP(statut='f',typ=mode_meca,max='**'  ),
           NMAX_MODE       =SIMP(statut='f',typ='I',max='**'),
           BASE_MODALE     =SIMP(statut='f',typ=mode_meca ),
           MODE_INTF       =SIMP(statut='f',typ=(mode_meca,mult_elas), ),
         ),
         b_ritz          =BLOC(condition = "RITZ != None",
           INTERF_DYNA     =SIMP(statut='f',typ=interf_dyna_clas ),
           NUME_REF        =SIMP(statut='f',typ=nume_ddl_sdaster ),
           ORTHO           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                               fr="Reorthonormalisation de la base de Ritz" ),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           b_ortho          =BLOC(condition = "ORTHO == 'OUI' ",
             MATRICE          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ) ),
               ),
         ),
        DIAG_MASS        =FACT(statut='f',max='**',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca,max='**'  ),
           MODE_STAT       =SIMP(statut='o',typ=mode_meca ),
         ),
        ORTHO_BASE        =FACT(statut='f',max='**',
           BASE       =SIMP(statut='o',typ=(mode_meca,mult_elas)),
           MATRICE    =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ) ),
         ),

#-------------------------------------------------------------------
#       Catalogue commun SOLVEUR
        SOLVEUR         =C_SOLVEUR('DEFI_BASE_MODALE'),
#-------------------------------------------------------------------



        TITRE           =SIMP(statut='f',typ='TXM',max='**'),
        INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: sylvie.michel-ponnelle at edf.fr


DEFI_CABLE_BP=MACRO(nom="DEFI_CABLE_BP",
                    op=OPS('Macro.defi_cable_bp_ops.defi_cable_bp_ops'),
                    sd_prod=cabl_precont,
                    fr="Calculer les profils initiaux de tension le long des cables " \
                       "de précontrainte d'une structure en béton",
                    reentrant='n',UIinfo={"groupes":("Modélisation",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
         GROUP_MA_BETON  =SIMP(statut='o',typ=grma,max='**'),
         DEFI_CABLE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('NOEUD_ANCRAGE','GROUP_NO_ANCRAGE'),),
           MAILLE          =SIMP(statut='f',typ=ma,min=2,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD_ANCRAGE   =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=2),
           GROUP_NO_ANCRAGE=SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           TENSION_CT      =SIMP(statut='f',typ=table_sdaster),
         ),
         ADHERENT        =SIMP(statut='o',typ='TXM',defaut='OUI',into=("OUI","NON") ),
         TYPE_ANCRAGE    =SIMP(statut='o',typ='TXM',min=2,max=2,into=("ACTIF","PASSIF") ),
         TENSION_INIT    =SIMP(statut='o',typ='R',val_min=0.E+0 ),
         RECUL_ANCRAGE   =SIMP(statut='o',typ='R',val_min=0.E+0 ),
         b_adherent=BLOC(condition="(ADHERENT=='OUI')",
            TYPE_RELAX      =SIMP(statut='o',typ='TXM',into=("SANS","BPEL","ETCC_DIRECT","ETCC_REPRISE"),defaut="SANS",),
                b_relax_bpel  =BLOC(condition = "TYPE_RELAX =='BPEL'",
                       R_J   =SIMP(statut='o',typ='R',val_min=0.E+0),
                                                ),
                b_relax_etcc  =BLOC(condition = "((TYPE_RELAX=='ETCC_DIRECT') or (TYPE_RELAX=='ETCC_REPRISE'))",
                      NBH_RELAX   =SIMP(statut='o',typ='R',val_min=0.E+0),
                       ),
#         PERT_ELAS       =SIMP(statut='o',typ='TXM',into=("OUI","NON"),defaut="NON"),
#           b_pert_elas   =BLOC(condition = "PERT_ELAS=='OUI'",
#                  EP_BETON  = SIMP(statut='o',typ='R',val_min=0.E+0),
#                  ESP_CABLE = SIMP(statut='o',typ='R',val_min=0.E+0)
#                  ) ,
            CONE            =FACT(statut='f',
                RAYON             =SIMP(statut='o',typ='R',val_min=0.E+0 ),
                LONGUEUR          =SIMP(statut='o',typ='R',val_min=0.E+0 ),
                PRESENT           =SIMP(statut='o',typ='TXM',min=2,max=2,into=("OUI","NON") ),
              ),
            ),
         b_non_adherent=BLOC(condition="(ADHERENT=='NON')",
            TYPE_RELAX      =SIMP(statut='c',typ='TXM',into=("SANS",),defaut="SANS",),
            ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: sylvie.michel-ponnelle at edf.fr

DEFI_CABLE_OP=OPER(nom="DEFI_CABLE_OP",op= 180,sd_prod=cabl_precont,reentrant='n',
            fr="Définit les profils initiaux de tension d'une structure en béton le long des cables de précontrainte"
               +" (utilisée par la macro DEFI_CABLE_BP)",
            UIinfo={"groupes":("Modélisation",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
         GROUP_MA_BETON  =SIMP(statut='o',typ=grma,max='**'),
         DEFI_CABLE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('NOEUD_ANCRAGE','GROUP_NO_ANCRAGE'),),
           MAILLE          =SIMP(statut='f',typ=ma,min=2,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD_ANCRAGE   =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=2),
           GROUP_NO_ANCRAGE=SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           GROUP_NO_FUT    =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           TENSION_CT      =SIMP(statut='f',typ=table_sdaster),
         ),
         ADHERENT        =SIMP(statut='o',typ='TXM',defaut='OUI',into=("OUI","NON") ),
         TYPE_ANCRAGE    =SIMP(statut='o',typ='TXM',min=2,max=2,into=("ACTIF","PASSIF") ),
         TENSION_INIT    =SIMP(statut='o',typ='R',val_min=0.E+0 ),
         RECUL_ANCRAGE   =SIMP(statut='o',typ='R',val_min=0.E+0 ),
         TYPE_RELAX      =SIMP(statut='o',typ='TXM',into=("SANS","BPEL","ETCC_DIRECT","ETCC_REPRISE"),defaut="SANS",),
         R_J             =SIMP(statut='f',typ='R',val_min=0.E+0),
         NBH_RELAX       =SIMP(statut='f',typ='R',val_min=0.E+0),
#         PERT_ELAS       =SIMP(statut='o',typ='TXM',into=("OUI","NON"),defaut="NON"),
#         EP_BETON        =SIMP(statut='f',typ='R',val_min=0.E+0),
#         ESP_CABLE       =SIMP(statut='f',typ='R',val_min=0.E+0),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         CONE            =FACT(statut='f',min=0,
           RAYON             =SIMP(statut='o',typ='R',val_min=0.E+0 ),
           LONGUEUR          =SIMP(statut='o',typ='R',val_min=0.E+0, defaut=0.E+0 ),
           PRESENT           =SIMP(statut='o',typ='TXM',min=2,max=2,into=("OUI","NON") ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix at edf.fr
DEFI_COMPOR=OPER(nom="DEFI_COMPOR",op=59,sd_prod=compor_sdaster,
                   fr="Définir le comportement d'un monocristal, d'un polycristal ou de groupes de fibres",
                   reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
# on exclut MULTIFBRE de MONOCRISTAL ou POLYCRISTAL car la structure de données n'est pas organisée pareil pour ces cas
                  regles=(UN_PARMI('MONOCRISTAL','POLYCRISTAL','MULTIFIBRE'),
                 PRESENT_PRESENT('MULTIFIBRE','GEOM_FIBRE','MATER_SECT'),
                         ),
          MONOCRISTAL    =FACT(statut='f', max=5,
             MATER           =SIMP(statut='o', typ=mater_sdaster, max=1),
             ECOULEMENT      =SIMP(statut='o', typ='TXM', max=1,
                   into=('MONO_VISC1', 'MONO_VISC2', 'MONO_DD_KR', 'MONO_DD_CFC', 'MONO_DD_CFC_IRRA',
                         'MONO_DD_CC', 'MONO_DD_CC_IRRA', 'MONO_DD_FAT',),
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écoulement viscoplastique"),
             ELAS            =SIMP(statut='f', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le comportement élastique (un et un seul)"),
             b_non_dd =BLOC(condition="ECOULEMENT=='MONO_VISC1' or ECOULEMENT=='MONO_VISC2'",
                   ECRO_ISOT       =SIMP(statut='o', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écrouissage isotrope"),
                   ECRO_CINE       =SIMP(statut='o', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écrouissage cinématique"),
                   FAMI_SYST_GLIS  =SIMP(statut='f',typ='TXM', max=1,
                                into=('OCTAEDRIQUE','BCC24','CUBIQUE1','CUBIQUE2','ZIRCONIUM','UNIAXIAL','UTILISATEUR'),
                                ),
                   b_util =BLOC(condition="FAMI_SYST_GLIS=='UTILISATEUR' ",
                          TABL_SYST_GLIS =SIMP(statut='f', typ=table_sdaster, max=1,),
                           ),
                                ),
             b_dd_kr =BLOC(condition="ECOULEMENT=='MONO_DD_KR' ",
                   FAMI_SYST_GLIS  =SIMP(statut='f',typ='TXM', max=1,
                                into=('BCC24','UTILISATEUR'),defaut=('BCC24',),),
                   b_util =BLOC(condition="FAMI_SYST_GLIS=='UTILISATEUR' ",
                          TABL_SYST_GLIS =SIMP(statut='f', typ=table_sdaster, max=1,),
                           ),
                                ),
             b_ecp_cfc =BLOC(condition="ECOULEMENT=='MONO_DD_FAT' ",
                   FAMI_SYST_GLIS  =SIMP(statut='f',typ='TXM', max=1,
                                into=('OCTAEDRIQUE','UTILISATEUR',),defaut=('OCTAEDRIQUE',),),
                                ),
             b_dd_cfc =BLOC(condition="ECOULEMENT=='MONO_DD_CFC'  or ECOULEMENT=='MONO_DD_CFC_IRRA'",
                   FAMI_SYST_GLIS  =SIMP(statut='f',typ='TXM', max=1,
                                into=('OCTAEDRIQUE','UTILISATEUR',),defaut=('OCTAEDRIQUE',),),
                   b_util =BLOC(condition="FAMI_SYST_GLIS=='UTILISATEUR' ",
                          TABL_SYST_GLIS =SIMP(statut='f', typ=table_sdaster, max=1,),
                           ),
                                ),
             b_dd_cc =BLOC(condition="ECOULEMENT=='MONO_DD_CC' or ECOULEMENT=='MONO_DD_CC_IRRA' ",
                   FAMI_SYST_GLIS  =SIMP(statut='f',typ='TXM', max=1,
                                into=('CUBIQUE1','UTILISATEUR',),defaut=('CUBIQUE1',),),
                   b_util =BLOC(condition="FAMI_SYST_GLIS=='UTILISATEUR' ",
                          TABL_SYST_GLIS =SIMP(statut='f', typ=table_sdaster, max=1,),
                           ),
                                ),
                                ),

          MATR_INTER =SIMP(statut='f', typ=table_sdaster, max=1,),

          ROTA_RESEAU =SIMP(statut='f', typ='TXM', max=1,into=('NON','POST','CALC'),defaut='NON',
                   fr="rotation de reseau : NON, POST, CALC"),

          POLYCRISTAL    =FACT(statut='f', max='**',
           regles=(UN_PARMI('ANGL_REP','ANGL_EULER'),),
             MONOCRISTAL     =SIMP(statut='o', typ=compor_sdaster, max=1),
             FRAC_VOL  =SIMP(statut='o', typ='R', max=1,fr="fraction volumique de la phase correspondant au monocristal"),
             ANGL_REP  =SIMP(statut='f',typ='R',max=3,fr="orientation du monocristal : 3 angles nautiques en degrés"),
             ANGL_EULER=SIMP(statut='f',typ='R',max=3,fr="orientation du monocristal : 3 angles d'Euler   en degrés"),
                                ),


          b_poly      =BLOC( condition = "POLYCRISTAL!='None'",
          LOCALISATION     =SIMP(statut='f', typ='TXM', max=1, into=('BZ', 'BETA', 'RL',),
                fr="Donner le nom de la règle de localisation"),

           b_beta      =BLOC( condition = "LOCALISATION=='BETA'",
             DL            =SIMP(statut='o',typ='R',max=1),
             DA            =SIMP(statut='o',typ='R',max=1),
             ),
             ),

#####################################################################################
          GEOM_FIBRE = SIMP(statut='f',max=1,typ=gfibre_sdaster,
                   fr="Donner le nom du concept regroupant tous les groupes de fibres (issu de DEFI_GEOM_FIBRE)"),
          MATER_SECT = SIMP(statut='f',max=1,typ=mater_sdaster,
                   fr="Donner le nom du materiau pour les caracteristiques homogeneisees sur la section"),
          MULTIFIBRE    = FACT(statut='f',max='**',
          GROUP_FIBRE        =SIMP(statut='o', typ='TXM', max='**'),
             MATER           =SIMP(statut='o', typ=mater_sdaster, max=1,
                                   fr="Donner le nom du materiau pour le groupe de fibres"),
             RELATION        =SIMP(statut='f', typ='TXM', max=1,defaut="ELAS",into=C_RELATION('DEFI_COMPOR'),
                                  fr="Donner le nom de la relation incrementale pour le groupe de fibres",
                                  ),
           RELATION_KIT    =SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                 into=(
# MECA KIT_DDI
                                       "VMIS_ISOT_TRAC",
                                       "VMIS_ISOT_LINE",
                                       "VMIS_ISOT_PUIS",
                                       "GRANGER_FP",
                                       "GRANGER_FP_INDT",
                                       "GRANGER_FP_V",
                                       "BETON_UMLV_FP",
                                       "ROUSS_PR",
                                       "BETON_DOUBLE_DP",
                                       ),),
# on pourrait ajouter TOUT_GROUP_FIBRE

                                ) );

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
DEFI_COMPOSITE=OPER(nom="DEFI_COMPOSITE",op=56,sd_prod=mater_sdaster,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
                    fr="Déterminer les caractéristiques matériaux homogénéisées d'une coque multicouche à partir"
                        +" des caractéristiques de chaque couche",
         COUCHE          =FACT(statut='o',max='**',
           EPAIS           =SIMP(statut='o',typ='R',val_min=0.E+0 ),
           MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
           ORIENTATION     =SIMP(statut='f',typ='R',defaut= 0.E+0,
                                 val_min=-90.E+0,val_max=90.E+0   ),
         ),
         IMPRESSION      =FACT(statut='f',
           UNITE           =SIMP(statut='f',typ='I',defaut=8),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
DEFI_CONSTANTE=OPER(nom="DEFI_CONSTANTE",op=   2,sd_prod=fonction_sdaster,
                    fr="Définir la valeur d'une grandeur invariante",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         VALE            =SIMP(statut='o',typ='R',),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
#
DEFI_CONTACT=OPER(nom       = "DEFI_CONTACT",
                  op        = 30,
                  sd_prod   = char_contact,
                  fr        = "Définit les zones soumises à des conditions de contact unilatéral avec ou sans frottement",
                  #en        = "Allows the definition of contact surfaces as well as unilateral conditions",
                  reentrant = 'n',
                  UIinfo    = {"groupes":("Modélisation",)},

# MODELE

         MODELE          =SIMP(statut='o',typ=modele_sdaster,),
         INFO            =SIMP(statut='f',typ='I',into=(1,2),),

# FORMULATION (UNIQUE PAR OCCURRENCE DE DEFI_CONTACT)

         FORMULATION     =SIMP(statut='o',
                               position='global',
                               typ='TXM',
                               fr="Choix d'une formulation de contact ou de liaisons unilatérales",
                               defaut="DISCRETE",
                               into=("DISCRETE","CONTINUE","XFEM","LIAISON_UNIL",),),

# PARAMETRE GENERAL : FROTTEMENT

         FROTTEMENT      =SIMP(statut='f',
                               position='global',
                               typ='TXM',
                               fr="Choix d'un modèle de frottement (uniquement pour les formulations de contact)",
                               defaut="SANS",
                               into=("COULOMB","SANS",)),

### PARAMETRES GENERAUX (UNIQUEMENT POUR LE CONTACT MAILLE, NE DEPENDENT PAS DE LA ZONE DE CONTACT)

         b_contact_mail=BLOC(condition = "((FORMULATION == 'CONTINUE') or (FORMULATION == 'DISCRETE'))",
#          ARRET DU CALCUL POUR LE MODE SANS RESOLUTION DU CONTACT
           STOP_INTERP   = SIMP(statut='f',
                                typ='TXM',
                                fr="Arrête le calcul dès qu'une interpénétration est détectée en mode RESOLUTION='NON'",
                                defaut="NON",
                                into=("OUI","NON")),
#          LISSAGE DES NORMALES PAR MOYENNATION AUX NOEUDS
           LISSAGE       = SIMP(statut='f',
                                typ='TXM',
                                fr="Lissage des normales par moyennation aux noeuds",
                                defaut="NON",
                                into=("OUI","NON")),
#          VERIFICATION DE L'ORIENTATION ET DE LA COHERENCE DES NORMALES
           VERI_NORM       =SIMP(statut='f',
                                 typ='TXM',
                                 fr="Vérification de l'orientation (sortante) des normales aux surfaces",
                                 defaut="OUI",
                                 into=("OUI","NON"),),
           ),

### PARAMETRES GENERAUX (UNIQUEMENT POUR LE CONTACT, NE DEPENDENT PAS DE LA ZONE DE CONTACT)

         b_contact=BLOC(condition = "FORMULATION != 'LIAISON_UNIL' ",

# PARAMETRE GENERAL : BOUCLE DE GEOMETRIE - Cas discret

           b_bouc_geom_maild=BLOC(condition = "FORMULATION == 'DISCRETE'",
                                  ALGO_RESO_GEOM = SIMP(statut='f',
                                                        typ='TXM',
                                                        into=("POINT_FIXE",),
                                                        defaut="POINT_FIXE"),
                                  REAC_GEOM = SIMP(statut='f',
                                                   typ='TXM',
                                                   into=("AUTOMATIQUE","CONTROLE","SANS",),
                                                   defaut="AUTOMATIQUE"),
                                  b_automatique = BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                                       ITER_GEOM_MAXI = SIMP(statut='f',typ='I',defaut=10),
                                       RESI_GEOM      = SIMP(statut='f',typ='R',defaut=0.01)),
                                  b_controle    = BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                       NB_ITER_GEOM   = SIMP(statut='f',typ='I',defaut = 2)),
                                  )),

# PARAMETRE GENERAL : BOUCLE DE GEOMETRIE - Cas continu

           b_bouc_geom_mailc=BLOC(condition = "FORMULATION == 'CONTINUE'",
                                  ALGO_RESO_GEOM = SIMP(statut='f',
                                                        typ='TXM',
                                                        into=("POINT_FIXE","NEWTON",),
                                                        defaut="POINT_FIXE"),
                                  b_algo_reso_geomNE = BLOC(condition = "ALGO_RESO_GEOM=='NEWTON'",
                                    RESI_GEOM      = SIMP(statut='f',typ='R',defaut=0.000001),),

                                  b_algo_reso_geomPF = BLOC(condition = "ALGO_RESO_GEOM=='POINT_FIXE'",
                                     REAC_GEOM = SIMP(statut='f',
                                                   typ='TXM',
                                                   into=("AUTOMATIQUE","CONTROLE","SANS",),
                                                   defaut="AUTOMATIQUE"),
                                    b_automatique = BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                                       ITER_GEOM_MAXI = SIMP(statut='f',typ='I',defaut=10),
                                       RESI_GEOM      = SIMP(statut='f',typ='R',defaut=0.01)),
                                    b_controle    = BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                       NB_ITER_GEOM   = SIMP(statut='f',typ='I',defaut = 2)))
                                   ),

# PARAMETRE GENERAL : BOUCLE DE GEOMETRIE - Cas XFEM

           b_bouc_geom_xfem=BLOC(condition = "FORMULATION == 'XFEM' ",
                                 ALGO_RESO_GEOM = SIMP(statut='f',
                                                        typ='TXM',
                                                        into=("POINT_FIXE",),
                                                        defaut="POINT_FIXE"),
                                 REAC_GEOM =SIMP(statut='f',
                                                 typ='TXM',
                                                 into=("AUTOMATIQUE","CONTROLE","SANS",),
                                                 defaut="SANS",
                                                 ),
                                 b_automatique = BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                                   ITER_GEOM_MAXI = SIMP(statut='f',typ='I',defaut=10),
                                   RESI_GEOM      = SIMP(statut='f',typ='R',defaut=0.0001),
                                   ),
                                 b_controle    = BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                   NB_ITER_GEOM   = SIMP(statut='f',typ='I',defaut = 2),
                                   ),
                                 ),


# PARAMETRE GENERAL : BOUCLE DE CONTACT

           b_bouc_cont_disc=BLOC(condition = "FORMULATION == 'DISCRETE' ",
                                 ITER_CONT_MULT = SIMP(statut='f',typ='I',defaut = 4),
                                 ),


           b_bouc_cont_cont=BLOC(condition = "FORMULATION == 'CONTINUE' ",
                                 ALGO_RESO_CONT = SIMP(statut='f',typ='TXM',defaut="NEWTON",
                                                      into=("POINT_FIXE","NEWTON")),
                                 b_algo_reso_contPF = BLOC(condition = "ALGO_RESO_CONT=='POINT_FIXE'",
                                   ITER_CONT_TYPE = SIMP(statut='f',typ='TXM',defaut="MAXI",
                                                      into=("MULT","MAXI")),
                                   b_bouc_cont_mult = BLOC(condition = "ITER_CONT_TYPE=='MULT'",
                                     ITER_CONT_MULT = SIMP(statut='f',typ='I',defaut = 4),
                                     ),
                                   b_bouc_cont_maxi = BLOC(condition = "ITER_CONT_TYPE=='MAXI'",
                                     ITER_CONT_MAXI = SIMP(statut='f',typ='I',defaut = 30),
                                     ),
                                   )
                                 ),

           b_bouc_cont_xfem=BLOC(condition = "FORMULATION == 'XFEM' ",
                                 ITER_CONT_TYPE= SIMP(statut='f',typ='TXM',defaut="MAXI",
                                                      into=("MULT","MAXI")),
                                 b_bouc_cont_mult = BLOC(condition = "ITER_CONT_TYPE=='MULT'",
                                                         ITER_CONT_MULT = SIMP(statut='f',typ='I',defaut = 4),
                                   ),
                                 b_bouc_cont_maxi = BLOC(condition = "ITER_CONT_TYPE=='MAXI'",
                                                         ITER_CONT_MAXI = SIMP(statut='f',typ='I',defaut = 30),
                                   ),
                                 ),

# PARAMETRE GENERAL : BOUCLE DE FROTTEMENT - Cas continu

           b_bouc_frot_cont= BLOC(condition = "FROTTEMENT=='COULOMB' and FORMULATION == 'CONTINUE' ",
                                  ALGO_RESO_FROT = SIMP(statut='f',
                                                        typ='TXM',
                                                        into=("POINT_FIXE","NEWTON",),
                                                        defaut="NEWTON"),
                                  b_algo_reso_frotPF = BLOC(condition = "ALGO_RESO_FROT=='POINT_FIXE'",
                                    ITER_FROT_MAXI = SIMP(statut='f',typ='I',defaut=10),
                                    RESI_FROT      = SIMP(statut='f',typ='R',defaut=0.0001),
                                  ),
                                  b_algo_reso_frotNE = BLOC(condition = "ALGO_RESO_FROT=='NEWTON'",

                                    RESI_FROT      = SIMP(statut='f',typ='R',defaut=0.0001),
                                    ADAPT_COEF     = SIMP(statut='f',
                                                          typ='TXM',
                                                          defaut="NON",
                                                          into=("OUI","NON")),
                                  ),
                              ),


# PARAMETRE GENERAL : BOUCLE DE FROTTEMENT - Cas XFEM

           b_bouc_frot_xfem= BLOC(condition = "FROTTEMENT=='COULOMB' and FORMULATION == 'XFEM' ",
                                  ITER_FROT_MAXI = SIMP(statut='f',typ='I',defaut=10),
                                  RESI_FROT      = SIMP(statut='f',typ='R',defaut=0.0001),
                                  ),

# PARAMETRES GENERAUX : METHODES DISCRETES

           b_para_discret  = BLOC(condition = "FORMULATION == 'DISCRETE' ",
#                                 ## METHODES DE DUALISATION ##
                                  STOP_SINGULIER= SIMP(statut='f',
                                                       typ='TXM',
                                                       fr="Tient compte de la singularité de la matrice de contact",
                                                       defaut="OUI",
                                                       into=("OUI","NON"),),
                                  NB_RESOL      = SIMP(statut='f',
                                                       typ='I',
                                                fr="Nombre de résolutions simultanées pour la construction du complément de Schur",
                                                       defaut=10,),
#                                 ## GCP ##
                                  RESI_ABSO     = SIMP(statut='f',
                                                       typ='R',
                                                  fr="Critère de convergence (niveau d'interpénétration autorisé pour 'GCP')",),
                                  ITER_GCP_MAXI = SIMP(statut='f',
                                                       typ='I',
                                                       fr="Nombre d'itérations maximal ('GCP')",
                                                       defaut=0,),
                                  RECH_LINEAIRE = SIMP(statut='f',
                                                       typ='TXM',
                                                  fr="Autorisation de sortie du domaine admissible lors de la recherche linéaire",
                                                       defaut="ADMISSIBLE",
                                                       into=("ADMISSIBLE","NON_ADMISSIBLE"),),
                                  PRE_COND      = SIMP(statut='f',
                                                       typ='TXM',
                                                       fr="Choix d'un préconditionneur (accélère la convergence de 'GCP')",
                                                       defaut="SANS",
                                                       into=("DIRICHLET","SANS"),),
                                  b_dirichlet   = BLOC (condition = "PRE_COND == 'DIRICHLET'",
                                     COEF_RESI     = SIMP(statut='f',
                                                          typ='R',
                                                   fr="Activation du préconditionneur quand le résidu a été divisé par COEF_RESI",
                                                          defaut = -1.0,),
                                     ITER_PRE_MAXI = SIMP(statut='f',
                                                          typ='I',
                                                          fr="Nombre d'itérations maximal pour le préconditionneur ('GCP')",
                                                          defaut=0,),
                                  ),
                                  ),

## AFFECTATIONS (ZONES PAR ZONES)

# AFFECTATION - CAS LIAISON_UNILATERALE

         b_affe_unil     = BLOC(condition = "FORMULATION == 'LIAISON_UNIL'",
                                ZONE=FACT(statut='o',
                                          max='**',
# -- Liaison unilatérale
                                          regles=(UN_PARMI('GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
                                          GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
                                          MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                          GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
                                          NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
#
                                          NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
                                          COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),),
                                          COEF_MULT       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
# -- Incompatibilité avec CL
                                          SANS_NOEUD      =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
                                          SANS_GROUP_NO   =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),


                                          ),
                                ),

# AFFECTATION - CAS DISCRET

         b_affe_discret  = BLOC(condition = "FORMULATION == 'DISCRETE'",
                                ZONE=FACT(statut='o',
                                          max='**',
# -- Appariement
                                          APPARIEMENT     =SIMP(statut='f',typ='TXM',defaut="MAIT_ESCL",
                                                                into=("NODAL","MAIT_ESCL"),),
#
                                          regles=(UN_PARMI('GROUP_MA_ESCL','MAILLE_ESCL'),
                                                  UN_PARMI('GROUP_MA_MAIT','MAILLE_MAIT'),),
                                          GROUP_MA_MAIT   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max=1),
                                          MAILLE_MAIT     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                          GROUP_MA_ESCL   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max=1),
                                          MAILLE_ESCL     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
#
                                          NORMALE         =SIMP(statut='f',typ='TXM',defaut="MAIT",
                                                                into=("MAIT","MAIT_ESCL","ESCL"),),
#
                                          VECT_MAIT       =SIMP(statut='f',typ='TXM',defaut="AUTO",
                                                                into=("AUTO","FIXE","VECT_Y")),

                                          b_nmait_fixe=BLOC(condition = "VECT_MAIT == 'FIXE'",
                                            MAIT_FIXE     =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),

                                          b_nmait_vecty=BLOC(condition = "VECT_MAIT == 'VECT_Y'",
                                            MAIT_VECT_Y   =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),
#
                                          VECT_ESCL       =SIMP(statut='f',typ='TXM',defaut="AUTO",
                                                                into=("AUTO","FIXE","VECT_Y")),

                                          b_nescl_fixe=BLOC(condition = "VECT_ESCL == 'FIXE'",
                                            ESCL_FIXE     =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),

                                          b_nescl_vecty=BLOC(condition = "VECT_ESCL == 'VECT_Y'",
                                            ESCL_VECT_Y   =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),
#
                                          TYPE_APPA       =SIMP(statut='f',typ='TXM',defaut="PROCHE",
                                                           into  =("PROCHE","FIXE")),

                                          b_appa_fixe     =BLOC(condition = "TYPE_APPA == 'FIXE'",
                                            DIRE_APPA     =SIMP(statut='f',typ='R',min=3,max=3),
                                            ),
#
                                          DIST_POUTRE     =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
                                          DIST_COQUE      =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
                                          b_cara=BLOC(condition = "DIST_POUTRE == 'OUI' or DIST_COQUE == 'OUI'",
                                            CARA_ELEM     =SIMP(statut='o',typ=(cara_elem) ),
                                            ),

                                          DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                          DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
                                          TOLE_APPA       =SIMP(statut='f',typ='R'  ,defaut=-1.0),
                                          TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
# -- Incompatibilité avec CL
                                          SANS_NOEUD      =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
                                          SANS_GROUP_NO   =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
                                          SANS_MAILLE     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                          SANS_GROUP_MA   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
# -- Mode sans calcul
                                          RESOLUTION      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                                          b_verif=BLOC(condition = "RESOLUTION == 'NON' ",
                                            TOLE_INTERP   = SIMP(statut='f',typ='R',defaut = 0.),
                                            ),
# -- Résolution
                                          ALGO_CONT       =SIMP(statut='o',typ='TXM',defaut="CONTRAINTE",
                                                                into=("CONTRAINTE","LAGRANGIEN","PENALISATION","GCP"),),

                                          b_active=BLOC(condition = "ALGO_CONT == 'CONTRAINTE' ",
                                                        fr="Paramètres de la méthode des contraintes actives (contact uniquement)",
                                                        GLISSIERE=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                                                        b_glissiere=BLOC(condition = "GLISSIERE == 'OUI' ",
                                                                         ALARME_JEU  =SIMP(statut='f',typ='R',defaut=0.),
                                                                        ),
                                                        ),
#
                                          b_penal_contact=BLOC(condition = "ALGO_CONT == 'PENALISATION' ",
                                                               fr="Paramètres de la méthode pénalisée (contact)",
                                                               E_N=SIMP(statut='o',typ='R'),
                                                               ),
#
                                          b_frottement=BLOC(condition = "FROTTEMENT == 'COULOMB' ",
                                                            fr="Paramètres du frottement de Coulomb",
                                                            COULOMB       =SIMP(statut='o',typ='R',),
                                                            COEF_MATR_FROT=SIMP(statut='f',typ='R',defaut=0.E+0),
                                                            ALGO_FROT     =SIMP(statut='o',typ='TXM',defaut="PENALISATION",
                                                                                into=("PENALISATION","LAGRANGIEN"),),
#
                                                            b_penal_frot=BLOC(condition = "ALGO_FROT == 'PENALISATION' ",
                                                                              fr="Paramètres de la méthode pénalisée (frottement)",
                                                                              E_T=SIMP(statut='o',typ='R'),
                                                                              ),
                                                           ),
                                          ), #fin mot-clé facteur ZONE
                                ), #fin bloc b_affe_discret

# AFFECTATION - CAS CONTINUE

         b_affe_continue = BLOC(condition = "FORMULATION == 'CONTINUE'",
                                ZONE=FACT(statut='o',
                                          max='**',
# -- Appariement
                                          APPARIEMENT     =SIMP(statut='f',typ='TXM',defaut="MAIT_ESCL",
                                                                into=("MAIT_ESCL",)),


#
                                          regles=(UN_PARMI('GROUP_MA_ESCL','MAILLE_ESCL'),
                                                  UN_PARMI('GROUP_MA_MAIT','MAILLE_MAIT'),),
                                          GROUP_MA_MAIT   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max=1),
                                          MAILLE_MAIT     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                          GROUP_MA_ESCL   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max=1),
                                          MAILLE_ESCL     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
#
                                          NORMALE         =SIMP(statut='f',typ='TXM',defaut="MAIT",
                                                                into=("MAIT","MAIT_ESCL","ESCL"),),
#
                                          VECT_MAIT       =SIMP(statut='f',typ='TXM',defaut="AUTO",
                                                                into=("AUTO","FIXE","VECT_Y")),

                                          b_nmait_fixe=BLOC(condition = "VECT_MAIT == 'FIXE'",
                                            MAIT_FIXE     =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),

                                          b_nmait_vecty=BLOC(condition = "VECT_MAIT == 'VECT_Y'",
                                            MAIT_VECT_Y   =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),
#
                                          VECT_ESCL       =SIMP(statut='f',typ='TXM',defaut="AUTO",
                                                                into=("AUTO","FIXE","VECT_Y")),

                                          b_nescl_fixe=BLOC(condition = "VECT_ESCL == 'FIXE'",
                                            ESCL_FIXE     =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),

                                          b_nescl_vecty=BLOC(condition = "VECT_ESCL == 'VECT_Y'",
                                            ESCL_VECT_Y   =SIMP(statut='o',typ='R',min=3,max=3),
                                            ),
#
                                          TYPE_APPA       =SIMP(statut='f',typ='TXM',defaut="PROCHE",
                                                           into  =("PROCHE","FIXE")),

                                          b_appa_fixe=BLOC(condition = "TYPE_APPA == 'FIXE'",
                                            DIRE_APPA     =SIMP(statut='f',typ='R',min=3,max=3),
                                            ),
#
                                          DIST_POUTRE     =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
                                          DIST_COQUE      =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
                                          b_cara=BLOC(condition = "DIST_POUTRE == 'OUI' or DIST_COQUE == 'OUI'",
                                            CARA_ELEM     =SIMP(statut='o',typ=(cara_elem) ),
                                            ),

                                          DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                          DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
                                          TOLE_APPA       =SIMP(statut='f',typ='R'  ,defaut=-1.0),
                                          TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
# -- Incompatibilité avec CL
                                          SANS_NOEUD      =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
                                          SANS_GROUP_NO   =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
                                          SANS_MAILLE     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                                          SANS_GROUP_MA   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
# -- Mode sans calcul
                                          RESOLUTION       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                                          b_verif=BLOC(condition = "RESOLUTION == 'NON' ",
                                                       TOLE_INTERP   = SIMP(statut='f',typ='R',defaut = 0.),
                                                       ),
# -- Fonctionnalités spécifiques 'CONTINUE'

                                          INTEGRATION     =SIMP(statut='f',typ='TXM',defaut="AUTO",
                                          into=("AUTO","GAUSS","SIMPSON","NCOTES",),),
                                          b_gauss   =BLOC(condition = "INTEGRATION == 'GAUSS' ",
                                                          fr="Degré du polynôme de Legendre donnant les points de Gauss",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=3,val_min=1,val_max=6),
                                            ),
                                          b_simpson =BLOC(condition = "INTEGRATION == 'SIMPSON' ",
                                                          fr="Nombre de subdivisions du domaine",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=1,val_min=1,val_max=4),
                                            ),
                                          b_ncotes  =BLOC(condition = "INTEGRATION == 'NCOTES' ",
                                                          fr="Degré du polynôme interpolateur",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=3,val_min=3,val_max=8),
                                            ),
#
                                          CONTACT_INIT    =SIMP(statut='f',typ='TXM',defaut="INTERPENETRE",
                                                                into=("OUI","INTERPENETRE","NON"),),
#
                                          GLISSIERE       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),),
#
                                          ALGO_CONT       =SIMP(statut='f',typ='TXM',defaut="STANDARD",
                                                                into=("STANDARD","PENALISATION"),),

                                          b_cont_std=BLOC(condition = "ALGO_CONT == 'STANDARD' ",
                                                          fr="Paramètres de la formulation Lagrangienne",
                                                          COEF_CONT = SIMP(statut='f',typ='R',defaut=100.E+0),
                                                          ),
                                          b_cont_pena=BLOC(condition = "ALGO_CONT == 'PENALISATION' ",
                                                            fr="Paramètres de la méthode pénalisée",
                                                            COEF_PENA_CONT  =SIMP(statut='o',typ='R'),
                                                            ),
#
                                          b_frottement=BLOC(condition = "FROTTEMENT == 'COULOMB' ",
                                                            fr="Paramètres du frottement de Coulomb",
                                                            COULOMB    = SIMP(statut='o',typ='R',),
                                                            SEUIL_INIT = SIMP(statut='f',typ='R',defaut=0.E+0),
#
                                          regles=(EXCLUS('SANS_NOEUD_FR','SANS_GROUP_NO_FR'),),
                                                  SANS_NOEUD_FR    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                                                  SANS_GROUP_NO_FR =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                                                            b_sans_group_no_frot=BLOC(condition = " SANS_GROUP_NO_FR != None or \
                                                                                                    SANS_NOEUD_FR != None ",
                                                            fr="Direction de frottement à exclure (uniquement dans le cas 3D)",
                                                            DIRE_EXCL_FROT=SIMP(statut='f',typ='R',min=3,max=3),
                                                            ),

                                            ALGO_FROT       =SIMP(statut='f',typ='TXM',defaut="STANDARD",
                                                                  into=("STANDARD","PENALISATION"),),
                                            b_frot_std      =BLOC(condition = "ALGO_FROT == 'STANDARD' ",
                                                                  fr="Paramètres de la formulation Lagrangienne",
                                                                  COEF_FROT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                                                                  ),

                                            b_frot_pena     =BLOC(condition = "ALGO_FROT == 'PENALISATION' ",
                                                                  fr="Paramètres de la méthode pénalisée",
                                                                  COEF_PENA_FROT  =SIMP(statut='o',typ='R'),
                                                                  ),

                                            ), #fin bloc b_frottement
                                          ), #fin mot-clé facteur ZONE
                                ), #fin bloc b_affe_continue


# AFFECTATION - CAS XFEM

           b_affe_xfem =BLOC(condition = "FORMULATION == 'XFEM'",
                             ZONE=FACT(statut='o',
                                       max='**',
# -- Fissure
                                       FISS_MAIT      = SIMP(statut='o',typ=fiss_xfem,max=1),
                                       TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),

# -- Fonctionnalités spécifiques 'XFEM'
                                       INTEGRATION    = SIMP(statut='f',
                                                             typ='TXM',
                                                             defaut="GAUSS",

                                          into=("NOEUD","GAUSS","SIMPSON","NCOTES",),),
                                          b_gauss   =BLOC(condition = "INTEGRATION == 'GAUSS' ",
                                                          fr="Dégré du polynôme de Legendre donnant les points de Gauss",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=6,val_min=1,val_max=6),
                                            ),
                                          b_simpson =BLOC(condition = "INTEGRATION == 'SIMPSON' ",
                                                          fr="Nombre de subdivisions du domaine",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=1,val_min=1,val_max=4),
                                            ),
                                          b_ncotes  =BLOC(condition = "INTEGRATION == 'NCOTES' ",
                                                          fr="Dégré du polynôme interpolateur",
                                                          ORDRE_INT = SIMP(statut='f',typ='I',defaut=3,val_min=3,val_max=8),
                                            ),

                                       ALGO_LAGR      = SIMP(statut='f',typ='TXM',defaut="VERSION1",
                                                             into=("NON","VERSION1","VERSION2"),),

                                       ALGO_CONT      = SIMP(statut='f',typ='TXM',defaut="STANDARD",
                                                                  into=("STANDARD","PENALISATION","CZM"),),

                                       b_cont_nczm =BLOC(condition = "ALGO_CONT!='CZM'",
                                                CONTACT_INIT   = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),),
                                                GLISSIERE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),),
                                                ),

                                       b_cont_std=BLOC(condition = "ALGO_CONT == 'STANDARD'",
                                                fr="Parametres de la formulation Lagrangienne",
                                                COEF_CONT    =SIMP(statut='f',typ='R',defaut=100.E+0),
                                                ),

                                       b_cont_pen=BLOC(condition = "ALGO_CONT == 'PENALISATION' ",
                                                 fr="Paramètre de la méthode pénalisée",
                                                 COEF_PENA_CONT =SIMP(statut='o',typ='R'),
                                                 ),

                                       b_cont_czm=BLOC(condition = "ALGO_CONT == 'CZM'",
                                                fr="Parametres de la formulation cohesive",
                                                RELATION       = SIMP(statut='o',typ='TXM',
                                                                 into=("CZM_EXP_REG","CZM_LIN_REG","CZM_TAC_MIX","CZM_OUV_MIX"),)
                                                ),

                                       b_frottement=BLOC(condition = "FROTTEMENT == 'COULOMB' and  ALGO_CONT != 'CZM' ",
                                                 fr="Paramètres du frottement",
                                                 COULOMB      =SIMP(statut='o',typ='R',),
                                                 SEUIL_INIT   =SIMP(statut='f',typ='R',defaut=0.E+0),
                                                 ALGO_FROT    =SIMP(statut='f',typ='TXM',defaut="STANDARD",
                                                                            into=("STANDARD","PENALISATION"),),

                                                 b_frot_std=BLOC(condition = "ALGO_FROT == 'STANDARD' ",
                                                                  fr="Parametres de la formulation Lagrangienne",
                                                                  COEF_FROT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                                                                  ),
                                                 b_frot_pen=BLOC(condition = "ALGO_FROT == 'PENALISATION' ",
                                                                  fr="Paramètre de la méthode pénalisée",
                                                                  COEF_PENA_FROT  =SIMP(statut='o',typ='R'),
                                                                  ),
                                                        ), #fin bloc b_frottement
                                       ), #fin mot-clé facteur ZONE
                             ), #fin bloc b_affe_xfem

                  ) #fin OPER

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
def DEFIC_prod(self,ACTION,UNITE,**args):
  if ACTION == "ASSOCIER" or ACTION == "RESERVER":
    if UNITE != None :
      return
    else :
      return entier
  elif ACTION == "LIBERER"  :
    return
  else :
    raise AsException("ACTION non prevue : %s" % ACTION)

DEFI_FICHIER=MACRO(nom="DEFI_FICHIER",
                   op=OPS("Cata.ops.build_DEFI_FICHIER"),
                   sd_prod=DEFIC_prod,
                   reentrant='n',
                   UIinfo={"groupes":("Gestion du travail",)},
                   fr="Ouvre ou ferme un fichier associé à un numéro d'unité logique",

            ACTION        =SIMP(statut='f',typ='TXM',into=("ASSOCIER","LIBERER","RESERVER"),defaut="ASSOCIER"),

            b_associer    =BLOC(condition = "ACTION == 'ASSOCIER'",
                                fr="Paramètres pour l'ouverture du fichier",
                                regles=(AU_MOINS_UN('FICHIER','UNITE'),),
               UNITE      =SIMP(statut='f',typ='I' ,val_min=1),
               FICHIER    =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
               TYPE       =SIMP(statut='f',typ='TXM',into=("ASCII","BINARY","LIBRE"),defaut="ASCII"),

               b_type_ascii  =BLOC(condition = "TYPE == 'ASCII'",fr="Paramètres pour le type ASCII",
                  ACCES      =SIMP(statut='f',typ='TXM',into=("NEW","APPEND","OLD"),defaut="NEW"),
               ),
               b_type_autre  =BLOC(condition = "TYPE != 'ASCII'",fr="Paramètres pour les types BINARY et LIBRE",
                  ACCES      =SIMP(statut='f',typ='TXM',into=("NEW","OLD"),defaut="NEW"),
               ),
            ),

            b_reserver    =BLOC(condition = "ACTION == 'RESERVER'",
                                fr="Paramètres pour la réservation de l'unité du fichier",
                                regles=(AU_MOINS_UN('FICHIER','UNITE'),),
               UNITE      =SIMP(statut='f',typ='I' ,val_min=1),
               FICHIER    =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
               TYPE       =SIMP(statut='f',typ='TXM',into=("ASCII",),defaut="ASCII"),
               ACCES      =SIMP(statut='f',typ='TXM',into=("APPEND",),defaut="APPEND"),
            ),

            b_liberer    =BLOC(condition = "ACTION == 'LIBERER'",
                               fr="Paramètres pour la fermeture du fichier",
                               regles=(UN_PARMI('FICHIER','UNITE'),),
                  UNITE         =SIMP(statut='f',typ='I' ,val_min=1),
                  FICHIER   =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
           ),

           INFO          =SIMP(statut='f',typ='I',into=(1,2) ),
           )

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

DEFI_FISS_XFEM=OPER(nom="DEFI_FISS_XFEM",op=  41,sd_prod=fiss_xfem,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
               fr="Définition des caratéristiques d'une fissure ou d'une interface avec X-FEM",
            regles = EXCLUS('MODELE_GRILLE','FISS_GRILLE'),

# ------------------------------------------------------------------------------------------------------------------------
#                       modele sous-jacent
# ------------------------------------------------------------------------------------------------------------------------

    MODELE                =SIMP(statut='o',typ=modele_sdaster),

# ------------------------------------------------------------------------------------------------------------------------
#                       grille auxiliaire
# ------------------------------------------------------------------------------------------------------------------------

    MODELE_GRILLE         =SIMP(statut='f',typ=modele_sdaster,max=1,position='global'),
    FISS_GRILLE           =SIMP(statut='f',typ=fiss_xfem,max=1),

# ------------------------------------------------------------------------------------------------------------------------
#                       fissure/interface
# ------------------------------------------------------------------------------------------------------------------------

      TYPE_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("FISSURE","INTERFACE",) ,defaut="FISSURE",position='global'),

# ------------------------------------------------------------------------------------------------------------------------
#                       caracteristiques de la fissure/interface
# ------------------------------------------------------------------------------------------------------------------------

    DEFI_FISS             =FACT(statut='o',max=1,

      regles              =UN_PARMI('GROUP_MA_FISS','FONC_LN','FORM_FISS','CHAM_NO_LSN'),

# impossible de faire des regles dans des blocs condition, dommage
#       b_fissure           =BLOC(condition = "TYPE_DISCONTINUITE == 'FISSURE' ",fr="Regles pour les fissures",
#                 regles    =(ENSEMBLE('FONC_LN','FONC_LT'),
#                             ENSEMBLE('CHAM_NO_LSN','CHAM_NO_LST'),
#                             ENSEMBLE('GROUP_MA_FISS','GROUP_MA_FOND')),
#                                ),
# 
#       b_interface           =BLOC(condition = "TYPE_DISCONTINUITE == 'INTERFACE' ",fr="Regles pour les interfaces",
#                 regles    =(PRESENT_ABSENT('FONC_LN','FONC_LT'),
#                             PRESENT_ABSENT('CHAM_NO_LSN','CHAM_NO_LST'),
#                             PRESENT_ABSENT('GROUP_MA_FISS','GROUP_MA_FOND')),
#                                ),

      FONC_LT             =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
      FONC_LN             =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
      CHAM_NO_LSN         =SIMP(statut='f',typ=cham_no_sdaster,min=1,max=1),
      CHAM_NO_LST         =SIMP(statut='f',typ=cham_no_sdaster,min=1,max=1),
      GROUP_MA_FISS       =SIMP(statut='f',typ=grma,min=1,max=1),
      GROUP_MA_FOND       =SIMP(statut='f',typ=grma,min=1,max=1),
      FORM_FISS   =SIMP(statut='f',typ='TXM',into=("ELLIPSE","RECTANGLE","CYLINDRE","DEMI_PLAN",
                                                   "SEGMENT","DEMI_DROITE","DROITE","ENTAILLE") ),
      b_ellipse           =BLOC(condition = "FORM_FISS == 'ELLIPSE' ",fr="Paramètres de la fissure/interface elliptique",
           DEMI_GRAND_AXE =SIMP(statut='o',typ='R',val_min=0.),
           DEMI_PETIT_AXE =SIMP(statut='o',typ='R',val_min=0.),
           CENTRE         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_X         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_Y         =SIMP(statut='o',typ='R',min=3,max=3),
           COTE_FISS      =SIMP(statut='f',typ='TXM',defaut="IN",into=("IN","OUT",) ),    ),
      b_rectangle         =BLOC(condition = "FORM_FISS == 'RECTANGLE' ",fr="Paramètres de la fissure/interface rectangulaire",
           DEMI_GRAND_AXE =SIMP(statut='o',typ='R',val_min=0.),
           DEMI_PETIT_AXE =SIMP(statut='o',typ='R',val_min=0.),
           RAYOP_CONGE    =SIMP(statut='f',typ='R',val_min=0.,defaut=0.),
           CENTRE         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_X         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_Y         =SIMP(statut='o',typ='R',min=3,max=3),
           COTE_FISS      =SIMP(statut='f',typ='TXM',defaut="IN",into=("IN","OUT",) ),    ),
      b_entaille          =BLOC(condition = "FORM_FISS == 'ENTAILLE' ",fr="Paramètres de l'interface entaille",
           DEMI_LONGUEUR  =SIMP(statut='o',typ='R',val_min=0.),
           RAYOP_CONGE    =SIMP(statut='o',typ='R',val_min=0.),
           CENTRE         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_X         =SIMP(statut='o',typ='R',min=3,max=3),  
           VECT_Y         =SIMP(statut='o',typ='R',min=3,max=3),  ),
      b_cylindre          =BLOC(condition = "FORM_FISS == 'CYLINDRE' ",fr="Paramètres de la fissure cylindrique",
           DEMI_GRAND_AXE =SIMP(statut='o',typ='R',val_min=0.),
           DEMI_PETIT_AXE =SIMP(statut='o',typ='R',val_min=0.),
           CENTRE         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_X         =SIMP(statut='o',typ='R',min=3,max=3),
           VECT_Y         =SIMP(statut='o',typ='R',min=3,max=3),),
      b_demiplan          =BLOC(condition = "FORM_FISS == 'DEMI_PLAN' ",fr="Paramètres de la fissure plane à front droit",
           PFON           =SIMP(statut='o',typ='R',min=3,max=3),
           NORMALE        =SIMP(statut='o',typ='R',min=3,max=3),
           DTAN           =SIMP(statut='o',typ='R',min=3,max=3),),
      b_segment           =BLOC(condition = "FORM_FISS == 'SEGMENT' ",fr="Paramètres de la fissure 2D segment",
           PFON_ORIG      =SIMP(statut='o',typ='R',min=3,max=3),
           PFON_EXTR      =SIMP(statut='o',typ='R',min=3,max=3),),
      b_demidroite         =BLOC(condition = "FORM_FISS == 'DEMI_DROITE' ",fr="Paramètres de la fissure 2D demi-droite",
           PFON           =SIMP(statut='o',typ='R',min=3,max=3),
           DTAN           =SIMP(statut='o',typ='R',min=3,max=3),),
      b_droite            =BLOC(condition = "FORM_FISS == 'DROITE' ",fr="Paramètres de l'interface 2D (fissure traversante)",
           POINT          =SIMP(statut='o',typ='R',min=3,max=3),
           DTAN           =SIMP(statut='o',typ='R',min=3,max=3),),
                            ),

# ------------------------------------------------------------------------------------------------------------------------
#                       partie du maillage potentiellement enrichie
# ------------------------------------------------------------------------------------------------------------------------

    GROUP_MA_ENRI         =SIMP(statut='f',typ=grma,max=01),

# ------------------------------------------------------------------------------------------------------------------------
#                       types d'enrichissement 
# ------------------------------------------------------------------------------------------------------------------------

    b_enri_inte           =BLOC(condition = "TYPE_DISCONTINUITE == 'INTERFACE' ",

      CHAM_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("DEPL","SIGM"),defaut="DEPL" ),

                          ),


    b_enri_fiss           =BLOC(condition = "TYPE_DISCONTINUITE == 'FISSURE' ",

      CHAM_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("DEPL",),defaut="DEPL" ),
      TYPE_ENRI_FOND      =SIMP(statut='f',typ='TXM',into=("TOPOLOGIQUE","GEOMETRIQUE"),defaut="TOPOLOGIQUE" ),

        b_enri_geom       =BLOC(condition = "TYPE_ENRI_FOND == 'GEOMETRIQUE' ",fr="Paramètres de l enrichissement geometrique",
           RAYON_ENRI     =SIMP(statut='f',typ='R',val_min=0.E+0),

          b_enri_couches  =BLOC(condition = "(RAYON_ENRI == None) ",fr="Paramètres de l enrichissement à n couches",
           NB_COUCHES     =SIMP(statut='f',typ='I',defaut=4,val_min=1),

                               ),
                             ),                        
                          ),

# ------------------------------------------------------------------------------------------------------------------------
#                       branchement
# ------------------------------------------------------------------------------------------------------------------------

    b_jonction            =BLOC(condition = "(MODELE_GRILLE == None) and (FISS_GRILLE == None)",
        JONCTION              =FACT(statut='f',max=1,
          FISSURE             =SIMP(statut='o',typ=fiss_xfem,min=1,max='**',),
          POINT               =SIMP(statut='o',typ='R',max=3,),
                                   ),
                               ),
# ------------------------------------------------------------------------------------------------------------------------
#                       info
# ------------------------------------------------------------------------------------------------------------------------

    INFO                  =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,3,) ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
DEFI_FLUI_STRU=OPER(nom="DEFI_FLUI_STRU",op= 143,sd_prod=type_flui_stru,
                    reentrant='n',fr="Définit les caractéristiques nécessaires à l'étude dynamique d'une structure sous écoulement",
            UIinfo={"groupes":("Modélisation",)},
         regles=(  UN_PARMI('FAISCEAU_TRANS','GRAPPE','FAISCEAU_AXIAL','COQUE_COAX',),),
         FAISCEAU_TRANS  =FACT(statut='f',max='**',
           regles=(  ENSEMBLE('CSTE_CONNORS','NB_CONNORS','RHO_TUBE'),),
           COUPLAGE        =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_RHO_F_INT  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_RHO_F_EXT  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           NOM_CMP         =SIMP(statut='f',typ='TXM',into=("DX","DY","DZ") ),
           COEF_MASS_AJOU  =SIMP(statut='f',typ='R' ),
           TYPE_PAS        =SIMP(statut='f',typ='TXM',into=("CARRE_LIGN","TRIA_LIGN") ),
           TYPE_RESEAU     =SIMP(statut='f',typ='I' ),
           UNITE_CD        =SIMP(statut='f',typ='I',defaut=70),
           UNITE_CK        =SIMP(statut='f',typ='I',defaut=71),
           PAS             =SIMP(statut='f',typ='R' ),
           CSTE_CONNORS    =SIMP(statut='f',typ='R',min=2,max=2,val_min=0.E+00),
           NB_CONNORS      =SIMP(statut='f',typ='I',val_min=2,),
           RHO_TUBE        =SIMP(statut='f',typ='R' ),
         ),
         GRAPPE          =FACT(statut='f',
           regles=(ENSEMBLE('GRAPPE_2','NOEUD','CARA_ELEM','MODELE','RHO_FLUI',),
                   PRESENT_PRESENT('COEF_MASS_AJOU','GRAPPE_2', ),),
#  peut on créer un bloc a partir de la valeur de couplage
           COUPLAGE        =SIMP(statut='o',typ='TXM',into=("OUI","NON") ),
           GRAPPE_2        =SIMP(statut='f',typ='TXM',
                                 into=("ASC_CEN","ASC_EXC","DES_CEN","DES_EXC") ),
           NOEUD           =SIMP(statut='f',typ=no),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           MODELE          =SIMP(statut='f',typ=modele_sdaster ),
           COEF_MASS_AJOU  =SIMP(statut='f',typ='R' ),
           RHO_FLUI        =SIMP(statut='f',typ='R' ),
           UNITE_CA        =SIMP(statut='f',typ='I',defaut=70),
           UNITE_KA        =SIMP(statut='f',typ='I',defaut=71),
         ),
         FAISCEAU_AXIAL  =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA','TRI_GROUP_MA'),
                   UN_PARMI('CARA_ELEM','RAYON_TUBE'),
                   ENSEMBLE('RAYON_TUBE','COOR_TUBE'),
                   PRESENT_ABSENT('RAYON_TUBE','TRI_GROUP_MA'),
                   ENSEMBLE('CARA_PAROI','VALE_PAROI'),
                   ENSEMBLE('LONG_TYPG','LARG_TYPG','EPAI_TYPG','RUGO_TYPG','COEF_TRAI_TYPG','COEF_DPOR_TYPG',
                            'COOR_GRILLE','TYPE_GRILLE', ),),
#  on doit pouvoir mettre des blocs conditionnels mais pas assez d infos pour le faire
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TRI_GROUP_MA    =SIMP(statut='f',typ='TXM' ),
           VECT_X          =SIMP(statut='f',typ='R',max=3),
           PROF_RHO_FLUI   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_VISC_CINE  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           RAYON_TUBE      =SIMP(statut='f',typ='R' ),
           COOR_TUBE       =SIMP(statut='f',typ='R',max='**'),
           PESANTEUR       =SIMP(statut='f',typ='R',min=4,max=4),
           RUGO_TUBE       =SIMP(statut='f',typ='R' ),
           CARA_PAROI      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=5,
                                 into=("YC","ZC","R","HY","HZ") ),
           VALE_PAROI      =SIMP(statut='f',typ='R',max=5),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           LONG_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           LARG_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           EPAI_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           RUGO_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           COEF_TRAI_TYPG  =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           COEF_DPOR_TYPG  =SIMP(statut='f',typ='R',max='**'),
           COOR_GRILLE     =SIMP(statut='f',typ='R',max='**'),
           TYPE_GRILLE     =SIMP(statut='f',typ='I',max='**'),
         ),
         COQUE_COAX      =FACT(statut='f',
           MASS_AJOU       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma),
           GROUP_MA_EXT    =SIMP(statut='o',typ=grma),
           VECT_X          =SIMP(statut='o',typ='R',max='**'),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MATER_INT       =SIMP(statut='o',typ=mater_sdaster ),
           MATER_EXT       =SIMP(statut='o',typ=mater_sdaster ),
           RHO_FLUI        =SIMP(statut='o',typ='R' ),
           VISC_CINE       =SIMP(statut='o',typ='R' ),
           RUGOSITE        =SIMP(statut='o',typ='R' ),
           PDC_MOY_1       =SIMP(statut='o',typ='R' ),
           PDC_DYN_1       =SIMP(statut='o',typ='R' ),
           PDC_MOY_2       =SIMP(statut='o',typ='R' ),
           PDC_DYN_2       =SIMP(statut='o',typ='R' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.relun at edf.fr


DEFI_FONC_ELEC=MACRO(nom="DEFI_FONC_ELEC",
                     op=OPS('Macro.defi_fonc_elec_ops.defi_fonc_elec_ops'),
                     sd_prod=fonction_sdaster,
                     reentrant='n',
                     UIinfo={"groupes":("Outils-métier",)},
                     fr="Définir une fonction du temps intervenant dans le calcul des " \
                        "forces de LAPLACE",
         regles=(UN_PARMI('COUR_PRIN','COUR'),
                 EXCLUS('COUR','COUR_SECO'), ),
         FREQ            =SIMP(statut='f',typ='R',defaut= 50.),
         SIGNAL          =SIMP(statut='f',typ='TXM',defaut="COMPLET",into=("COMPLET","CONTINU") ),
         COUR            =FACT(statut='f',max='**',
           fr="Définition du courant de court-circuit",
           regles=(UN_PARMI('PHI_CC_1','INTC_CC_1'),
                   UN_PARMI('PHI_CC_2','INTC_CC_2'),),
           INTE_CC_1       =SIMP(statut='o',typ='R'),
           TAU_CC_1        =SIMP(statut='o',typ='R'),
           PHI_CC_1        =SIMP(statut='f',typ='R'),
           INTC_CC_1       =SIMP(statut='f',typ='R'),
           INTE_CC_2       =SIMP(statut='o',typ='R'),
           TAU_CC_2        =SIMP(statut='o',typ='R'),
           PHI_CC_2        =SIMP(statut='f',typ='R'),
           INTC_CC_2       =SIMP(statut='f',typ='R'),
           INST_CC_INIT    =SIMP(statut='o',typ='R'),
           INST_CC_FIN     =SIMP(statut='o',typ='R'),
         ),
         COUR_PRIN       =FACT(statut='f',
         fr="Définition du courant de court-circuit avec réenclenchement",
           regles=(UN_PARMI('PHI_CC_1','INTC_CC_1'),),
           INTE_CC_1       =SIMP(statut='o',typ='R'),
           TAU_CC_1        =SIMP(statut='o',typ='R'),
           PHI_CC_1        =SIMP(statut='f',typ='R'),
           INTC_CC_1       =SIMP(statut='f',typ='R'),
           INTE_RENC_1     =SIMP(statut='f',typ='R'),
           TAU_RENC_1      =SIMP(statut='f',typ='R'),
           PHI_RENC_1      =SIMP(statut='f',typ='R'),
           INST_CC_INIT    =SIMP(statut='o',typ='R'),
           INST_CC_FIN     =SIMP(statut='o',typ='R'),
           INST_RENC_INIT  =SIMP(statut='f',typ='R',defaut= 0.0E+0),
           INST_RENC_FIN   =SIMP(statut='f',typ='R',defaut= 0.0E+0),
         ),
         COUR_SECO       =FACT(statut='f',max='**',
         fr="Définition du courant de court-circuit avec un intervalle de temps différent de celui de COUR_PRIN",
           regles=(UN_PARMI('PHI_CC_2','INTC_CC_2'),),
           INTE_CC_2       =SIMP(statut='o',typ='R'),
           TAU_CC_2        =SIMP(statut='o',typ='R'),
           PHI_CC_2        =SIMP(statut='f',typ='R'),
           INTC_CC_2       =SIMP(statut='f',typ='R'),
           INTE_RENC_2     =SIMP(statut='f',typ='R'),
           TAU_RENC_2      =SIMP(statut='f',typ='R'),
           PHI_RENC_2      =SIMP(statut='f',typ='R'),
           DIST            =SIMP(statut='f',typ='R',defaut=1.0E+0),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
DEFI_FONC_FLUI=OPER(nom="DEFI_FONC_FLUI",op= 142,sd_prod=fonction_sdaster,
                    reentrant='n',
            fr="Définit un profil de vitesse d'écoulement fluide le long d'une poutre",
            UIinfo={"groupes":("Modélisation","Fonctions",)},
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster) ),
         NOEUD_INIT      =SIMP(statut='o',typ=no),
         NOEUD_FIN       =SIMP(statut='o',typ=no),
         VITE            =FACT(statut='o',
           VALE            =SIMP(statut='f',typ='R',defaut= 1. ),
           PROFIL          =SIMP(statut='o',typ='TXM',into=("UNIFORME","LEONARD") ),
           NB_BAV          =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 2 , 3 ) ),
         ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",
                               into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",
                               into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM' ,defaut="EXCLU",
                               into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def defi_fonction_prod(VALE,VALE_PARA,VALE_C,NOEUD_PARA,ABSCISSE,**args):
  if VALE       != None  : return fonction_sdaster
  if VALE_C     != None  : return fonction_c
  if VALE_PARA  != None  : return fonction_sdaster
  if ABSCISSE   != None  : return fonction_sdaster
  if NOEUD_PARA != None  : return fonction_sdaster
  raise AsException("type de concept resultat non prevu")

DEFI_FONCTION=OPER(nom="DEFI_FONCTION",op=3,sd_prod=defi_fonction_prod
                    ,fr="Définit une fonction réelle ou complexe d'une variable réelle",
                     reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('VALE','VALE_C','VALE_PARA','NOEUD_PARA','ABSCISSE'),),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         VALE            =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="Fonction réelle définie par une liste de couples "
                                   "(abscisse,ordonnée)"),
         ABSCISSE        =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="Liste d abscisses d une fonction réelle"),
         VALE_C          =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="Fonction complexe définie par une liste de triplets "
                                   "(absc, partie réelle, partie imaginaire)"),
         VALE_PARA       =SIMP(statut='f',typ=listr8_sdaster,
                               fr ="Fonction réelle définie par deux concepts de type listr8" ),
         b_vale_para     =BLOC(condition = "VALE_PARA != None",
           VALE_FONC       =SIMP(statut='o',typ=listr8_sdaster ),
         ),
         b_abscisse      =BLOC(condition = "ABSCISSE != None",
           ORDONNEE        =SIMP(statut='o',typ='R',min=2,max='**',
                               fr ="Liste d ordonnées d une fonction réelle"),
         ),
         NOEUD_PARA      =SIMP(statut='f',typ=no,max='**',
                               fr ="Fonction réelle définie par une liste de noeuds et un maillage"),
         b_noeud_para    =BLOC(condition = "NOEUD_PARA != None",
           MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
           VALE_Y          =SIMP(statut='o',typ='R',max='**'),
         ),

         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="CROISSANT",into=("CROISSANT","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

DEFI_FOND_FISS=OPER(nom="DEFI_FOND_FISS",
                    op=55,
                    sd_prod=fond_fiss,
                    reentrant='n',
                    UIinfo={"groupes":("Modélisation",)},fr="Définition de lèvres et d'un fond de fissure",

    MAILLAGE  = SIMP(statut='o',typ=maillage_sdaster ),
    INFO      =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),

    # definition du fond de fissure
    FOND_FISS = FACT(statut='o',max=2,
    
                     TYPE_FOND = SIMP(statut='f',typ='TXM',into=("OUVERT","FERME","INF","SUP"),defaut="OUVERT"),

                     NOEUD    = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                     GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1   ),
                     GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1   ),
                     MAILLE   = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                     regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),

                     # possibilite d'ordonnencement automatique du fond si groupe de mailles
                     b_grma = BLOC(condition = "(GROUP_MA != None or MAILLE != None) and TYPE_FOND != 'FERME'",
                                   NOEUD_ORIG    =SIMP(statut='f',typ=no,  max=1),
                                   GROUP_NO_ORIG =SIMP(statut='f',typ=grno,max=1),
                                   regles=(EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),),

                                   # si ordo 
                                   b_ordo = BLOC(condition = "NOEUD_ORIG != None or GROUP_NO_ORIG != None",
                                                 NOEUD_EXTR    = SIMP(statut='f',typ=no,  max=1),
                                                 GROUP_NO_EXTR = SIMP(statut='f',typ=grno,max=1),
                                                 regles=(EXCLUS('NOEUD_EXTR','GROUP_NO_EXTR'),),
                                                ),
                                  ),
                     # possibilite d'ordonnencement automatique du fond si groupe de mailles
                     b_grma_ferme= BLOC(condition = "(GROUP_MA != None or MAILLE != None) and TYPE_FOND == 'FERME'",
                                        NOEUD_ORIG    =SIMP(statut='f',typ=no,  max=1),
                                        GROUP_NO_ORIG =SIMP(statut='f',typ=grno,max=1),
                                        regles=(EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),),

                                        # si ordo 
                                        b_ordo_ferme = BLOC(condition = "NOEUD_ORIG != None or GROUP_NO_ORIG != None",
                                                            MAILLE_ORIG   = SIMP(statut='f',typ=ma,  max=1),
                                                            GROUP_MA_ORIG = SIMP(statut='f',typ=grma,  max=1),
                                                            regles=(UN_PARMI('MAILLE_ORIG','GROUP_MA_ORIG'),),
                                                           ),
                                       ),
                    # definition des directions des tangentes aux bords (uniquement pour les fonds non fermes)
                    b_dtan = BLOC(condition = "TYPE_FOND != 'FERME'",
                                  DTAN_ORIG       =SIMP(statut='f',typ='R',max='**'),
                                  DTAN_EXTR       =SIMP(statut='f',typ='R',max='**'),
                                  VECT_GRNO_ORIG  =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
                                  VECT_GRNO_EXTR  =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
                                  regles=(EXCLUS('DTAN_ORIG','VECT_GRNO_ORIG'),
                                             EXCLUS('DTAN_EXTR','VECT_GRNO_EXTR'),),
                                 ),
                    ),

    CONFIG_INIT  = SIMP(statut='f',typ='TXM',into=("COLLEE","DECOLLEE"), defaut="COLLEE",position='global'),

    SYME         = SIMP(statut='f',typ='TXM',into=("OUI","NON"),         defaut="NON",   position='global'),

#   remarque : dans le cas symetrique, il faut soit LEVRE_SUP, soit DTAN_ORIG
#   mais impossible de faire une regle.

    LEVRE_SUP =FACT(statut='f',max=1,
                    regles=(UN_PARMI('GROUP_MA','MAILLE'),),
                    GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                    MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                    ),
    
    b_levre_inf  = BLOC(condition = "LEVRE_SUP != None and SYME == 'NON'",

                        LEVRE_INF =FACT(statut='o',max=1,
                                        regles=(UN_PARMI('GROUP_MA','MAILLE'),),
                                        GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                                        MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                                        ),
                        ),  

    # dans le cas decolle
    b_decolle    = BLOC(condition = "CONFIG_INIT == 'DECOLLEE'",
                     NORMALE   =SIMP(statut='o',typ='R',max=3),),

    PREC_NORM    = SIMP(statut='f',typ='R',defaut=0.1),

)  

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-luc.flejou at edf.fr
#
DEFI_GEOM_FIBRE=OPER(nom="DEFI_GEOM_FIBRE",op=  119, sd_prod=gfibre_sdaster,
                    fr="Definition des groupes de fibres pour les elements multifibres",
                    reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('SECTION','FIBRE'),),

         INFO       =SIMP(statut='f',typ='I', defaut= 1 ,into=(1,2) ),
#============================================================================
         SECTION     =FACT(statut='f',max='**',
              regles=(AU_MOINS_UN('TOUT_SECT','GROUP_MA_SECT','MAILLE_SECT'),
                      PRESENT_ABSENT('TOUT_SECT','GROUP_MA_SECT','MAILLE_SECT'),),

              GROUP_FIBRE       =SIMP(statut='o',typ='TXM',min=1,max=1),
              TOUT_SECT         =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA_SECT     =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_SECT       =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

              MAILLAGE_SECT     =SIMP(statut='o',typ=maillage_sdaster),
              COOR_AXE_POUTRE   =SIMP(statut='o',typ='R',min=2,max=2),
         ),


#============================================================================
         FIBRE     =FACT(statut='f',max='**',
              GROUP_FIBRE       =SIMP(statut='o',typ='TXM',min=1,max=1),
              CARA              =SIMP(statut='f',typ='TXM',defaut='SURFACE',into=('SURFACE','DIAMETRE',)),
              VALE              =SIMP(statut='o',typ='R',max='**'),
              COOR_AXE_POUTRE   =SIMP(statut='o',typ='R',min=2,max=2),
          ),


) ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: sebastien.fayolle at edf.fr
DEFI_GLRC=OPER(nom="DEFI_GLRC",op=57,sd_prod=mater_sdaster,reentrant='f',
               UIinfo={"groupes":("Modélisation",)},
               fr="Déterminer les caractéristiques homogenéisées du béton armé à partir des propriétés du béton et des  "
                        +" armatures",
               reuse = SIMP(statut='f',typ=mater_sdaster),
               RELATION = SIMP(statut='o',typ='TXM',defaut="GLRC_DAMAGE",
                          into=("GLRC_DM","GLRC_DAMAGE"),),

               b_glrc_dm=BLOC(condition = "RELATION == 'GLRC_DM'",
                              fr="Paramètres de la loi GLRC_DM",
                              BETON = FACT(statut='o',max=1,
                                MATER = SIMP(statut='o',typ=(mater_sdaster),),
                                EPAIS = SIMP(statut='o',typ='R',val_min=0.E+0 ),),
                              NAPPE = FACT(statut='o',max=1,
                                MATER = SIMP(statut='o',typ=(mater_sdaster),),
                                OMY   = SIMP(statut='o',typ='R',val_min=0.E+0,),
                                OMX   = SIMP(statut='o',typ='R',val_min=0.E+0,),
                                RY    = SIMP(statut='o',typ='R',val_min=-1.0E+0,val_max=1.0E+0,),
                                RX    = SIMP(statut='o',typ='R',val_min=-1.0E+0,val_max=1.0E+0),),
                              RHO = SIMP(statut='f',typ='R',val_min=0.E+0,),
                              AMOR_ALPHA = SIMP(statut='f',typ='R',val_min=0.E+0,),
                              AMOR_BETA = SIMP(statut='f',typ='R',val_min=0.E+0,),
                              AMOR_HYST = SIMP(statut='f',typ='R',val_min=0.E+0,),
                              COMPR = SIMP(statut='o',typ='TXM',defaut="GAMMA",
                                           into=("GAMMA","SEUIL")),
                   b_gamma=BLOC(condition = "COMPR == 'GAMMA'",
                                fr="Paramètre d'endommagement en compression ",
                                GAMMA_C = SIMP(statut='o',typ='R',defaut=1.0E+0,val_min=0.0E+0, val_max=1.0E+0),),
                   b_seuil=BLOC(condition = "COMPR == 'SEUIL'",
                                fr="Seuil d'endommagement en compression ",
                                NYC = SIMP(statut='o',typ='R'),),
                   PENTE = SIMP(statut='o',typ='TXM',defaut="RIGI_ACIER",
                                into=("PLAS_ACIER","UTIL","RIGI_ACIER")),
                   b_util = BLOC(condition = "PENTE == 'UTIL'",
                                 fr="Valeur de la déformation maximale de l'élément",
                                  EPSI_MEMB = SIMP(statut='o',typ='R',defaut=0.E+0),
                                  KAPPA_FLEX = SIMP(statut='o',typ='R',defaut=0.E+0),),
                   CISAIL = SIMP(statut='o',typ='TXM',defaut="NON",
                                 into=("OUI","NON"),),
                   METHODE_ENDO = SIMP(statut='o',typ='TXM',defaut="ENDO_INTER",
                                  into=("ENDO_NAISS","ENDO_LIM","ENDO_INTER"),),
                   INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2),),
                           ),
           b_glrc_damage=BLOC(condition = "RELATION == 'GLRC_DAMAGE'",
                            fr="Paramètres de la loi GLRC_DAMAGE",
                   CISAIL_NL          =FACT(statut='f',max=1,
                     BTD1            =SIMP(statut='o',typ='R'),
                     BTD2            =SIMP(statut='o',typ='R'),
                     TSD             =SIMP(statut='o',typ='R'),
                                         ),
                   BETON            =FACT(statut='o',max=1,
                   regles=(ENSEMBLE('MP1X', 'MP1Y', 'MP2X', 'MP2Y'),
                           ENSEMBLE('MP1X_FO', 'MP1Y_FO', 'MP2X_FO', 'MP2Y_FO'),
                           PRESENT_ABSENT('MP1X', 'MP1X_FO', 'MP1Y_FO', 'MP2X_FO', 'MP2Y_FO'),
                           ENSEMBLE('OMT', 'EAT'),
                           ENSEMBLE('BT1','BT2'),),
                     MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
                     EPAIS           =SIMP(statut='o',typ='R',val_min=0.E+0 ),
                     GAMMA           =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=1.E+0),
                     QP1             =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=1.E+0),
                     QP2             =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=1.E+0),

                     C1N1            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C1N2            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C1N3            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2N1            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2N2            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2N3            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C1M1            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C1M2            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C1M3            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2M1            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2M2            =SIMP(statut='o',typ='R',val_min=0.E+0),
                     C2M3            =SIMP(statut='o',typ='R',val_min=0.E+0),

                     OMT             =SIMP(statut='f',typ='R',val_min=0.E+0),
                     EAT             =SIMP(statut='f',typ='R',val_min=0.E+0),
                     BT1             =SIMP(statut='f',typ='R',val_min=0.E+0),
                     BT2             =SIMP(statut='f',typ='R',val_min=0.E+0),

                     MP1X            =SIMP(statut='f',typ='R'),
                     MP2X            =SIMP(statut='f',typ='R'),
                     MP1Y            =SIMP(statut='f',typ='R'),
                     MP2Y            =SIMP(statut='f',typ='R'),

                     MP1X_FO         =SIMP(statut='f',typ=fonction_sdaster),
                     MP2X_FO         =SIMP(statut='f',typ=fonction_sdaster),
                     MP1Y_FO         =SIMP(statut='f',typ=fonction_sdaster),
                     MP2Y_FO         =SIMP(statut='f',typ=fonction_sdaster),
         ),
                   NAPPE     =FACT(statut='o',max=10,
                     MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
                     OMX             =SIMP(statut='o',typ='R',val_min=0.E+0),
                     OMY             =SIMP(statut='o',typ='R',val_min=0.E+0),
                     RX              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
                     RY              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
         ),
                   CABLE_PREC   =FACT(statut='f',max=1,
                     MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
                     OMX             =SIMP(statut='o',typ='R',val_min=0.E+0),
                     OMY             =SIMP(statut='o',typ='R',val_min=0.E+0),
                     RX              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
                     RY              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
                     PREX            =SIMP(statut='o',typ='R'),
                     PREY            =SIMP(statut='o',typ='R'),
         ),
                   LINER           =FACT(statut='f',max=10,
                     MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
                     OML             =SIMP(statut='o',typ='R',val_min=0.E+0),
                     RLR             =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
         ),
                   INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2),),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr
DEFI_GRILLE=OPER(nom="DEFI_GRILLE",op=82,sd_prod=grille_sdaster,reentrant='n',
                UIinfo={"groupes":("Modélisation",)},
                fr="Définition d'une grille",
    
    MAILLAGE       = SIMP(statut='o',typ=maillage_sdaster),

    INFO           = SIMP(statut='f',typ='I',defaut= 0,into=(0,1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def defi_group_prod(MAILLAGE,GRILLE,**args):
  if ( MAILLAGE != None ) :
     if AsType(MAILLAGE) == maillage_sdaster : return maillage_sdaster
     if AsType(MAILLAGE) == squelette : return squelette
  if ( GRILLE != None ) :
     return grille_sdaster
  raise AsException("type de concept resultat non prevu")

DEFI_GROUP=OPER(nom="DEFI_GROUP",op= 104,sd_prod=defi_group_prod,
                fr="Définition de nouveaux groupes de noeuds et/ou de mailles dans un concept maillage",
                reentrant='o',
            UIinfo={"groupes":("Maillage",)},
         regles=(AU_MOINS_UN('CREA_GROUP_MA','CREA_GROUP_NO','DETR_GROUP_NO','DETR_GROUP_MA'),
                 UN_PARMI('MAILLAGE','GRILLE'),),
         MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster,squelette) ),
         GRILLE          =SIMP(statut='f',typ=(grille_sdaster) ),
         DETR_GROUP_MA   =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),),
         DETR_GROUP_NO   =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**'),),


         CREA_GROUP_MA   =FACT(statut='f',max='**',
              regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','INTERSEC','UNION','DIFFE','OPTION'),),
            NOM             =SIMP(statut='o',typ=grma),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            GROUP_MA        =SIMP(statut='f',typ=grma),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            INTERSEC        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            UNION           =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            DIFFE           =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            TYPE_MAILLE     =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","1D","2D","3D",
                                  "POI1","SEG2","SEG3","SEG4","TRIA3","TRIA6","TRIA7",
                                  "QUAD4","QUAD8","QUAD9","TETRA4","TETRA10",
                                  "PENTA6","PENTA15","PENTA18","HEXA8","HEXA20","HEXA27",
                                  "PYRAM5","PYRAM13",),max=1 ),

            OPTION         =SIMP(statut='f',typ='TXM',into=("FACE_NORMALE","SPHERE","CYLINDRE",
                                                              "BANDE","APPUI_LACHE","APPUI","FISS_XFEM") ),
                b_group_ma      =BLOC(condition = "GROUP_MA != None",
                  regles=(EXCLUS('POSITION','NUME_INIT'),),
                  NUME_INIT       =SIMP(statut='f',typ='I'),
                  POSITION        =SIMP(statut='f',typ='TXM',into=("INIT","FIN","MILIEU") ),
                  b_nume_init   =BLOC(condition = "NUME_INIT != None",
                    NUME_FIN        =SIMP(statut='f',typ='I' ),
                  ),
                ),
                b_face_normale  =BLOC(condition = "OPTION == 'FACE_NORMALE'",
                  regles=(UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
                  ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
                  VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
                  ANGL_PREC       =SIMP(statut='f',typ='R',defaut= 0.5 ),
                  VERI_SIGNE      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
                ),
                b_sphere        =BLOC(condition = "OPTION == 'SPHERE'",
                  regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),),
                  POINT           =SIMP(statut='f',typ='R',max=3),
                  NOEUD_CENTRE    =SIMP(statut='f',typ=no),
                  GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
                  RAYON           =SIMP(statut='o',typ='R' ),
                  CRIT_NOEUD      = SIMP(statut='f',typ='TXM',defaut="AU_MOINS_UN",
                                  into=("TOUS","AU_MOINS_UN","MAJORITE"),),
                ),
                b_cylindre      =BLOC(condition = "OPTION == 'CYLINDRE'",
                  regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                          UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
                  POINT           =SIMP(statut='f',typ='R',max=3),
                  NOEUD_CENTRE    =SIMP(statut='f',typ=no),
                  GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
                  RAYON           =SIMP(statut='o',typ='R' ),
                  ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
                  VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
                  CRIT_NOEUD      = SIMP(statut='f',typ='TXM',defaut="AU_MOINS_UN",
                                  into=("TOUS","AU_MOINS_UN","MAJORITE"),),
                ),
                b_bande         =BLOC(condition = "OPTION == 'BANDE'",
                  regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                          UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
                  POINT           =SIMP(statut='f',typ='R' ,max=3),
                  NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
                  GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
                  DIST            =SIMP(statut='o',typ='R' ),
                  ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
                  VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
                  CRIT_NOEUD      = SIMP(statut='f',typ='TXM',defaut="AU_MOINS_UN",
                                  into=("TOUS","AU_MOINS_UN","MAJORITE"),),
                ),
                b_app_lache         =BLOC(condition = "OPTION == 'APPUI_LACHE'",
                  regles=(UN_PARMI('NOEUD','GROUP_NO'),),
                  NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                  GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                ),
                b_appui            =BLOC(condition = "OPTION == 'APPUI'",
                  regles=(UN_PARMI('NOEUD','GROUP_NO'),),
                  NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                  GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                  TYPE_APPUI      =SIMP(statut='o',typ='TXM',max=1, into=('AU_MOINS_UN','TOUT','SOMMET','MAJORITE')),
                ),
                b_fiss_xfem       =BLOC(condition = "OPTION == 'FISS_XFEM'",
                  TYPE_GROUP      =SIMP(statut='o',typ='TXM',max=1,defaut='XFEM',
                                          into=('HEAVISIDE','CRACKTIP','MIXTE','FISSUREE','XFEM',),),
                  FISSURE         =SIMP(statut='o',typ=fiss_xfem,min=1,max='**'),
                ),
         ),


         CREA_GROUP_NO   =FACT(statut='f',max='**',
           OPTION          =SIMP(statut='f',typ='TXM',into=("ENV_SPHERE","ENV_CYLINDRE","PLAN",
                                               "SEGM_DROI_ORDO","NOEUD_ORDO","TUNNEL",
                                               "INCLUSION","FISS_XFEM","INTERVALLE_VALE") ),

           b_option =BLOC(condition = "OPTION == None" ,
                          regles=(UN_PARMI('TOUT_GROUP_MA','GROUP_MA','GROUP_NO','NOEUD',
                                                           'INTERSEC','UNION','DIFFE'),),
              TOUT_GROUP_MA   =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              INTERSEC        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              UNION           =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              DIFFE           =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),

              b_nom_group_ma  =BLOC(condition = "GROUP_MA != None",
                NOM           = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                CRIT_NOEUD    = SIMP(statut='f',typ='TXM',defaut="TOUS",
                                  into=("TOUS","SOMMET","MILIEU","CENTRE"),),
              ),
              b_group_no      =BLOC(condition = "GROUP_NO != None",
                                    regles=(EXCLUS('POSITION','NUME_INIT'),),
                NUME_INIT       =SIMP(statut='f',typ='I'),
                POSITION        =SIMP(statut='f',typ='TXM',into=("INIT","FIN","MILIEU") ),
                b_nume_init     =BLOC(condition = "NUME_INIT != None",
                  NUME_FIN        =SIMP(statut='f',typ='I' ),
                ),
              ),
              b_nom =BLOC(condition = "GROUP_MA == None and TOUT_GROUP_MA == None" ,
                NOM             =SIMP(statut='o',typ=grma),
              ),
           ),

           b_env_sphere    =BLOC(condition = "OPTION == 'ENV_SPHERE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),),
             NOM             =SIMP(statut='o',typ=grno),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             RAYON           =SIMP(statut='o',typ='R' ),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_env_cylindre  =BLOC(condition = "OPTION == 'ENV_CYLINDRE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             NOM             =SIMP(statut='o',typ=grno),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             RAYON           =SIMP(statut='o',typ='R' ),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
             VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_env_plan      =BLOC(condition = "OPTION == 'PLAN'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             NOM             =SIMP(statut='o',typ=grno),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             ANGL_NAUT       =SIMP(statut='f',typ='R' ,max=3),
             VECT_NORMALE    =SIMP(statut='f',typ='R' ,max=3),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_segm_droi_ordo=BLOC(condition = "OPTION == 'SEGM_DROI_ORDO'",
             regles=(AU_MOINS_UN('NOEUD','GROUP_NO'),
                     UN_PARMI('NOEUD_ORIG','GROUP_NO_ORIG'),
                     UN_PARMI('NOEUD_EXTR','GROUP_NO_EXTR'),),
             NOM             =SIMP(statut='o',typ=grno),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             NOEUD_EXTR      =SIMP(statut='f',typ=no),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno),
             PRECISION       =SIMP(statut='o',typ='R' ),
             CRITERE         =SIMP(statut='o',typ='TXM',into=("ABSOLU","RELATIF") ),
           ),
           b_noeud_ordo    =BLOC(condition = "OPTION == 'NOEUD_ORDO'",
             regles=(EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                     EXCLUS('NOEUD_EXTR','GROUP_NO_EXTR'),),
             NOM             =SIMP(statut='o',typ=grno),
             GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
             # si le groupe de mailles forme une ligne ouverte, on peut choisir le sens de parcours en choissant l'origine:
             # si le groupe de mailles forme une ligne fermée, il FAUT choisir l'origine et l'extrémité (= origine):
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             NOEUD_EXTR      =SIMP(statut='f',typ=no),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno),
             # si le groupe de mailles forme une ligne fermée, on peut choisir le sens de parcours :
             VECT_ORIE       =SIMP(statut='f',typ='R',max=3),  # utilisé seulement si NOEUD_ORIG=NOEUD_EXTR

           ),
           b_tunnel    =BLOC(condition = "OPTION == 'TUNNEL'",
             regles=(AU_MOINS_UN ('TOUT','GROUP_MA','MAILLE'),
                     EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                     AU_MOINS_UN ('GROUP_MA_AXE','MAILLE_AXE'),),
             NOM             =SIMP(statut='o',typ=grma),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA_AXE    =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_AXE      =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             RAYON           =SIMP(statut='o',typ='R'),
             LONGUEUR        =SIMP(statut='f',typ='R'),
           ),
           b_inclusion         =BLOC(condition = "OPTION == 'INCLUSION'",
             fr="""crée le groupe des noeuds des mailles de GROUP_MA inclus géométriquement
                   dans les mailles de GROUP_MA_INCL""",
             NOM             =SIMP(statut='o',typ=grma),
             CAS_FIGURE      =SIMP(statut='o',typ='TXM',into=("2D","3D","2.5D",)),
             DISTANCE_MAX    =SIMP(statut='f',typ='R',),
             GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
             GROUP_MA_INCL   =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
             MAILLAGE_INCL   =SIMP(statut='f',typ=maillage_sdaster),
           ),
           b_fiss_xfem            =BLOC(condition = "OPTION == 'FISS_XFEM'",
                  NOM             =SIMP(statut='o',typ=grma),
                  TYPE_GROUP      =SIMP(statut='o',typ='TXM',max=1,into=('HEAVISIDE','CRACKTIP','MIXTE','XFEM','ZONE_MAJ','TORE')),
                  FISSURE         =SIMP(statut='o',typ=fiss_xfem,min=1,max='**'),
                  b_rayon         =BLOC(condition = "TYPE_GROUP == 'TORE'",
                        RAYON_TORE     =SIMP(statut='o',typ='R',max=1,val_min=0.0),
                  ),
           ),
           b_intervalle_vale      =BLOC(condition = "OPTION == 'INTERVALLE_VALE'",
                  NOM             =SIMP(statut='o',typ=grma),
                  CHAM_GD         =SIMP(statut='o',typ=cham_no_sdaster),
                  NOM_CMP         =SIMP(statut='o',typ='TXM',max=1),
                  VALE            =SIMP(statut='o',typ='R',min=2,max=2),
           ),
          ),
         ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',into=( 1 , 2 ) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr

DEFI_INTE_SPEC=OPER(nom="DEFI_INTE_SPEC",op= 115,
                    sd_prod=interspectre,
                    reentrant='n',
                    fr="Définit une matrice interspectrale",
                    UIinfo={"groupes":("Fonctions",)},

         DIMENSION       =SIMP(statut='f',typ='I',defaut= 1 ),

         regles=(UN_PARMI('PAR_FONCTION','KANAI_TAJIMI','CONSTANT'),),

         PAR_FONCTION    =FACT(statut='f',max='**',
           regles=(UN_PARMI('NUME_ORDRE_I','NOEUD_I'),),
           NOEUD_I         =SIMP(statut='f',typ=no,max=1,),
           NUME_ORDRE_I    =SIMP(statut='f',typ='I',max=1),
           b_nume_ordre_i = BLOC (condition = "NUME_ORDRE_I != None",
             NUME_ORDRE_J    =SIMP(statut='o',typ='I',max=1),
           ),
           b_noeud_i = BLOC (condition = "NOEUD_I != None",
             NOEUD_J         =SIMP(statut='o',typ=no,max=1,),
             NOM_CMP_I       =SIMP(statut='o',typ='TXM',max=1,),
             NOM_CMP_J       =SIMP(statut='o',typ='TXM',max=1,),
           ),
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c ),max=1),
         ),

         KANAI_TAJIMI    =FACT(statut='f',max='**',
           regles=(EXCLUS('VALE_R','VALE_C'),
                   UN_PARMI('NUME_ORDRE_I','NOEUD_I'),),
           NUME_ORDRE_I    =SIMP(statut='f',typ='I',max=1),
           NOEUD_I         =SIMP(statut='f',typ=no,max=1,),
           b_nume_ordre_i = BLOC (condition = "NUME_ORDRE_I != None",
             NUME_ORDRE_J    =SIMP(statut='o',typ='I',max=1),
           ),
           b_noeud_i = BLOC (condition = "NOEUD_I != None",
             NOEUD_J         =SIMP(statut='o',typ=no,max=1,),
             NOM_CMP_I       =SIMP(statut='o',typ='TXM',max=1,),
             NOM_CMP_J       =SIMP(statut='o',typ='TXM',max=1,),
           ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut= 100. ),
           PAS             =SIMP(statut='f',typ='R',defaut= 1. ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',defaut= 0.6 ),
           FREQ_MOY        =SIMP(statut='f',typ='R',defaut= 5. ),
           VALE_R          =SIMP(statut='f',typ='R' ),
           VALE_C          =SIMP(statut='f',typ='C' ),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         CONSTANT        =FACT(statut='f',max='**',
           regles=(EXCLUS('VALE_R','VALE_C'),
                   UN_PARMI('NUME_ORDRE_I','NOEUD_I'),),
           NUME_ORDRE_I    =SIMP(statut='f',typ='I',max=1),
           NOEUD_I         =SIMP(statut='f',typ=no,max=1,),
           b_nume_ordre_i = BLOC (condition = "NUME_ORDRE_I != None",
             NUME_ORDRE_J    =SIMP(statut='o',typ='I',max=1),
           ),
           b_noeud_i = BLOC (condition = "NOEUD_I != None",
             NOEUD_J         =SIMP(statut='o',typ=no,max=1,),
             NOM_CMP_I       =SIMP(statut='o',typ='TXM',max=1,),
             NOM_CMP_J       =SIMP(statut='o',typ='TXM',max=1,),
           ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut= 100. ),
           PAS             =SIMP(statut='f',typ='R',defaut= 1. ),
           VALE_R          =SIMP(statut='f',typ='R' ),
           VALE_C          =SIMP(statut='f',typ='C' ),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr

DEFI_INTERF_DYNA=OPER(nom="DEFI_INTERF_DYNA",op=  98,sd_prod=interf_dyna_clas,
                      reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs","Dynamique",)},
            fr="Définir les interfaces d'une structure et leur affecter un type",
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         INTERFACE       =FACT(statut='o',max='**',
           regles=(ENSEMBLE('NOM','TYPE'),
#  erreur doc U sur la condition qui suit
                   UN_PARMI('NOEUD','GROUP_NO'),),
           NOM             =SIMP(statut='f',typ='TXM' ),
           TYPE            =SIMP(statut='f',typ='TXM',into=("MNEAL","CRAIGB","CB_HARMO","AUCUN") ),
           NOEUD           =SIMP(statut='f',typ=no,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
#           DDL_ACTIF       =SIMP(statut='f',typ='TXM',max='**'),
           MASQUE          =SIMP(statut='f',typ='TXM',max='**'),
         ),
         FREQ            =SIMP(statut='f',typ='R',defaut= 1.),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
DEFI_LIST_ENTI=OPER(nom="DEFI_LIST_ENTI",op=22,sd_prod=listis_sdaster,
                    fr="Définir une liste d'entiers strictement croissante",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},

         OPERATION    =SIMP(statut='o',typ='TXM',defaut='DEFI',into=('DEFI','NUME_ORDRE',)),


         # définition d'une liste d'entiers
         #----------------------------------
         b_defi       =BLOC(condition = "OPERATION == 'DEFI'",
             regles=(UN_PARMI('VALE','DEBUT'),
                     EXCLUS('VALE','INTERVALLE'),),
             VALE            =SIMP(statut='f',typ='I',max='**'),
             DEBUT           =SIMP(statut='f',typ='I'),
             INTERVALLE      =FACT(statut='f',max='**',
                 regles=(UN_PARMI('NOMBRE','PAS'),),
                 JUSQU_A         =SIMP(statut='o',typ='I'),
                 NOMBRE          =SIMP(statut='f',typ='I',val_min=1,),
                 PAS             =SIMP(statut='f',typ='I',val_min=1,),
             ),
         ),


         # extraction d'une liste de nume_ordre dans une sd_resultat :
         #------------------------------------------------------------
         b_extr       =BLOC(condition = "OPERATION == 'NUME_ORDRE'",
             RESULTAT        =SIMP(statut='o',typ=resultat_sdaster),
             PARAMETRE       =SIMP(statut='o',typ='TXM',),
             INTERV_R        =SIMP(statut='o',typ='R',min=2,max=2),
         ),


         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr
DEFI_LIST_FREQ=MACRO(nom="DEFI_LIST_FREQ",
                    op=OPS('Macro.defi_list_freq_ops.defi_list_freq_ops'),
                    sd_prod=listr8_sdaster,
                    fr="Définir une liste de fréquences strictement croissante",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('VALE','DEBUT',),
                 EXCLUS('VALE','INTERVALLE'),
                 ENSEMBLE('DEBUT','INTERVALLE')),
         VALE            =SIMP(statut='f',typ='R',max='**'),
         DEBUT           =SIMP(statut='f',typ='R'),
         INTERVALLE      =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOMBRE','PAS'),),
           JUSQU_A         =SIMP(statut='o',typ='R'),
           NOMBRE          =SIMP(statut='f',typ='I'),
           PAS             =SIMP(statut='f',typ='R'),
         ),
         RAFFINEMENT      =FACT(statut='f',
           LIST_RAFFINE    =SIMP(statut='o',typ='R',max='**'),
           NB_POINTS       =SIMP(statut='f',typ='I',defaut=5),
           PAS_MINI        =SIMP(statut='f',typ='R',defaut=0.001),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU","LARGEUR_3DB")),
              b_crit_rela_abs=BLOC(condition="(CRITERE=='RELATIF' or CRITERE=='ABSOLU')",
                 DISPERSION      =SIMP(statut='f',typ='R',defaut=0.01),),
              b_crit_larg=BLOC(condition="(CRITERE=='LARGEUR_3DB')",
                 AMOR_MODAL      =FACT(statut='o',
                    regles = UN_PARMI('AMOR_REDUIT','LIST_AMOR'),
                    AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
                    LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),),),
             ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr



# Bloc pour decoupe automatique
bloc_auto   =BLOC(fr                = "Subdivision de type automatique",
                  condition         = "SUBD_METHODE == 'AUTO'",
                  SUBD_PAS_MINI     = SIMP(fr                = "Pas de temps en dessous duquel on ne subdivise plus",
                                           statut            = 'f',
                                           typ               = 'R',
                                           val_min           = 0.0,
                                           max               = 1,
                                           defaut            = 0.,
                                           ),
                  )

# Bloc pour decoupe manuel
bloc_manu   =BLOC(fr                = "Subdivision de type manuel",
                  condition         = "SUBD_METHODE == 'MANUEL'",
                  regles            = (AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
                  SUBD_PAS          = SIMP(fr                = "Nombre de subdivision d'un pas de temps",
                                           statut            = 'f',
                                           typ               = 'I',
                                           val_min           = 2,
                                           max               = 1,
                                           defaut            = 4,
                                           ),

                  SUBD_NIVEAU       = SIMP(fr                = "Nombre maximum de niveau de subdivision d'un pas de temps",
                                           statut            = 'f',
                                           typ               = 'I',
                                           val_min           = 2,
                                           max               = 1,
                                           defaut            = 3,
                                           ),
                  SUBD_PAS_MINI     = SIMP(fr                = "Pas de temps en dessous duquel on ne subdivise plus",
                                           statut            = 'f',
                                           typ               = 'R',
                                           val_min           = 0.0,
                                           max               = 1,
                                           defaut            = 0.,
                                           ),
                 )

# Bloc pour decoupe automatique - Cas de la collision
bloc_auto2  =BLOC(fr                = "Subdivision de type automatique",
                  condition         = "SUBD_METHODE == 'AUTO'",
                  SUBD_INST         = SIMP(fr                = "Parametre de decoupe fine du pas de temps",
                                           statut            = 'o',
                                           typ               = 'R',
                                           val_min           = 0.0,
                                           max               = 1,
                                           ),
                  SUBD_DUREE        = SIMP(fr                = "Duree de decoupe apres collision",
                                           statut            = 'o',
                                           typ               = 'R',
                                           val_min           = 0.0,
                                           max               = 1,
                                           ),
                  )

# Bloc pour decoupe du pas de temps
bloc_deco   =BLOC(fr                = "Action de decoupe du pas temps",
                  condition         = "ACTION == 'DECOUPE' or ACTION == 'REAC_PRECOND' or ACTION == 'AUTRE_PILOTAGE'",
                  SUBD_METHODE      = SIMP(fr                = "Méthode de subdivision des pas de temps en cas de divergence",
                                           statut            = 'f',
                                           typ               = 'TXM',
                                           max               = 1,
                                           into              = ("MANUEL","AUTO"),
                                           defaut            = "MANUEL",
                                           ),
                  b_deco_manu       = bloc_manu,
                  b_deco_auto       = bloc_auto,
                 )


# Bloc pour decoupe du pas de temps - special pour collision
bloc_deco2  =BLOC(fr                = "Action de decoupe du pas temps",
                  condition         = "ACTION == 'DECOUPE'",
                  SUBD_METHODE      = SIMP(fr                = "Méthode de subdivision des pas de temps en cas de collision",
                                           statut            = 'f',
                                           typ               = 'TXM',
                                           max               = 1,
                                           into              = ("MANUEL","AUTO"),
                                           defaut            = "AUTO",
                                           ),



                  b_deco_manu       = bloc_manu,
                  b_deco_auto       = bloc_auto2,
                 )

# Bloc pour extrapolation du nombre d'iterations de Newton
bloc_supp   =BLOC(fr                = "Action d'extrapolation du nombre d'iterations de Newton",
                  condition         = "ACTION == 'ITER_SUPPL'",
                  PCENT_ITER_PLUS   = SIMP(fr                = "Pourcentage d'itérations autorisées en plus",
                                           statut            = 'f',
                                           typ               = 'I',
                                           val_min           = 20,
                                           max               = 1,
                                           defaut            = 50,
                                           ),
                  SUBD_METHODE      = SIMP(fr                = "Méthode de subdivision des pas de temps en cas de divergence",
                                           statut            = 'f',
                                           typ               = 'TXM',
                                           max               = 1,
                                           into              = ("MANUEL","AUTO"),
                                           defaut            = "MANUEL",
                                           ),
                  b_deco_manu       = bloc_manu,
                  b_deco_auto       = bloc_auto,
                 )

# Bloc pour adaptation du coefficient de penalisation
bloc_pene   =BLOC(fr                = "Action d' adaptation du coefficient de penalisation",
                  condition         = "ACTION == 'ADAPT_COEF_PENA'",
                  COEF_MAXI         = SIMP(fr                = "Coefficient multiplicateur maximum du coefficient de penalisation",
                                           statut            = 'f',
                                           typ               = 'R',
                                           val_min           = 1.,
                                           max               = 1,
                                           defaut            = 1E12,
                                           ),
                 )

DEFI_LIST_INST = OPER(nom="DEFI_LIST_INST",op=  28,sd_prod=list_inst,reentrant='n',
                      UIinfo={"groupes":("Fonctions",)},
                      fr="Définition de la gestion de la liste d'instants",

# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour la definition a priori de la liste d'instant
# ----------------------------------------------------------------------------------------------------------------------------------

DEFI_LIST   =FACT(fr                = "Definition a priori de la liste d'instants",
                  statut            = 'o',
                  max               = 1,
                  METHODE           = SIMP(fr                = "Methode de definition de la liste d'instants",
                                           statut            = 'o',
                                           typ               = 'TXM',
                                           max               = 1,
                                           position          = 'global',
                                           into              = ("MANUEL","AUTO",),
                                           defaut            = "MANUEL",
                                           ),
                  b_manuel          = BLOC(fr                = "Liste d'instants donnée par l'utilisateur",
                                           condition         = "METHODE == 'MANUEL' ",
                                           regles=(UN_PARMI('LIST_INST','VALE','RESULTAT'),
                                                   PRESENT_PRESENT('RESULTAT','SUBD_PAS'),),
                                           VALE              = SIMP(statut          = 'f',
                                                                    typ             = 'R',
                                                                    max             = '**'),
                                           LIST_INST         = SIMP(statut          = 'f',
                                                                    typ             = listr8_sdaster,
                                                                    ),
                                           RESULTAT          = SIMP(statut          = 'f',
                                                                    typ             = resultat_sdaster,
                                                                    ),
                                           SUBD_PAS          = SIMP(statut          = 'f',
                                                                    typ             = 'I',
                                                                    max             = 1,
                                                                    val_min         = 1,
                                                                    ),

                                           ),
                  b_auto            = BLOC(fr                = "Gestion automatique de la liste d'instants",
                                           condition         = "(METHODE == 'AUTO') ",
                                           regles=(UN_PARMI('LIST_INST','VALE',),),
                                           VALE              = SIMP(statut          = 'f',
                                                                    typ             = 'R',
                                                                    max             = '**'),
                                           LIST_INST         = SIMP(statut          = 'f',
                                                                    typ             = listr8_sdaster,
                                                                    ),
                                           PAS_MINI          = SIMP(statut          = 'f',
                                                                    typ             = 'R',
                                                                    max             = 1,
                                                                    val_min         = 1.e-12,
                                                                    ),
                                           PAS_MAXI          = SIMP(statut          = 'f',
                                                                    typ             = 'R',
                                                                    max             = 1,
                                                                    ),
                                           NB_PAS_MAXI       = SIMP(statut          = 'f',
                                                                    typ             = 'I',
                                                                    max             = 1,
                                                                    val_max         = 1000000,
                                                                    defaut          = 1000000,
                                                                    ),
                                           ),
                 ),
# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour le comportement en cas d'echec (on doit recommencer le meme instant)
# ----------------------------------------------------------------------------------------------------------------------------------

ECHEC       =FACT(fr                = "Comportement en cas d'echec",
                  statut            = 'd',
                  max               = '**',
                  EVENEMENT         = SIMP(fr                = "Type de l'evenement",
                                           statut            = 'f',
                                           typ               = 'TXM',
                                           max               = 1,
                                           into              = ("ERREUR","DELTA_GRANDEUR","COLLISION",
                                                                "INTERPENETRATION","DIVE_RESI","INSTABILITE"),
                                           defaut            = "ERREUR",
                                           ),
                  b_erreur          = BLOC(fr                = "Event: erreur ou iter_maxi",
                                           condition         = "EVENEMENT == 'ERREUR' ",
                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("ARRET","DECOUPE","REAC_PRECOND",
                                                                                       "ITER_SUPPL","AUTRE_PILOTAGE"),
                                                                    defaut          = "DECOUPE",
                                                                    ),
                                           b_deco            = bloc_deco,
                                           b_supp            = bloc_supp,
                                           ),
                  b_edelta          = BLOC(fr                = "Event: l'increment d'une composante d'un champ depasse le seuil",
                                           condition         = "EVENEMENT == 'DELTA_GRANDEUR' ",
                                           VALE_REF          = SIMP(fr              = "Valeur du seuil",
                                                                    statut          = 'o',
                                                                    typ             = 'R',
                                                                    max             = 1,
                                                                    ),
                                           NOM_CHAM          = SIMP(fr              = "Nom du champ",
                                                                    statut          = 'o',
                                                                    typ             = 'TXM',
                                                                    max             = 1,
                                                                    into            = ("DEPL","VARI_ELGA","SIEF_ELGA",),
                                                                    ),
                                           NOM_CMP           = SIMP(fr              = "Nom de la composante",
                                                                    statut          = 'o',
                                                                    typ             = 'TXM',
                                                                    max             = 1,
                                                                    ),
                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("ARRET","DECOUPE",),
                                                                    defaut          = "DECOUPE",
                                                                    ),
                                           b_deco            = bloc_deco,
                                           ),
                  b_colli           = BLOC(fr                = "Event: collision",
                                           condition         = "EVENEMENT == 'COLLISION' ",
                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("ARRET","DECOUPE",),
                                                                    defaut          = "DECOUPE",
                                                                    ),
                                           b_deco2           = bloc_deco2,
                                           ),
                  b_penetration     = BLOC(fr                = "Event: interpenetration des surfaces en contact",
                                           condition         = "EVENEMENT == 'INTERPENETRATION' ",
                                           PENE_MAXI         = SIMP(fr              = "Valeur maxi de l'interpenetration",
                                                                    statut          = 'o',
                                                                    typ             = 'R',
                                                                    max             = 1,
                                                                    ),


                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("ARRET","ADAPT_COEF_PENA",),
                                                                    defaut          = "ADAPT_COEF_PENA",
                                                                    ),
                                           b_pene            = bloc_pene,
                                           ),
                  b_dive_resi       = BLOC(fr                = "Event: divergence du residu",
                                           condition         = "EVENEMENT == 'DIVE_RESI' ",
                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("DECOUPE",),
                                                                    defaut          = "DECOUPE",
                                                                    ),
                                           b_deco            = bloc_deco,
                                           ),
                  b_instabilite     = BLOC(fr                = "Event: instabilite",
                                           condition         = "EVENEMENT == 'INSTABILITE' ",
                                           ACTION            = SIMP(fr              = "Actions possibles",
                                                                    statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("ARRET","CONTINUE",),
                                                                    defaut          = "CONTINUE",
                                                                    ),
                                           ),

                 ),

# ----------------------------------------------------------------------------------------------------------------------------------
# Mot-cle pour le comportement en cas de succes (on a bien converge)
# ----------------------------------------------------------------------------------------------------------------------------------

b_adap  =   BLOC(condition="METHODE == 'AUTO'",

ADAPTATION  =FACT(fr                = "Parametres de l'evenement declencheur de l'adaptation du pas de temps",
                  statut            = 'd',
                  max               = '**',
                  EVENEMENT         = SIMP(fr                = "Nom de l'evenement declencheur de l'adaptation",
                                           statut            = 'f',
                                           max               = 1,
                                           typ               = 'TXM',
                                           into              = ("SEUIL","TOUT_INST","AUCUN"),
                                           defaut            = "SEUIL",
                                           ),
                  b_adap_seuil      = BLOC(fr                = "Seuil d'adaptation",
                                           condition         = "EVENEMENT == 'SEUIL' ",
                                           regles            = (PRESENT_PRESENT('NB_INCR_SEUIL','NOM_PARA',),
                                                                PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),
                                                                PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),),
                                           NB_INCR_SEUIL     = SIMP(statut          = 'f',
                                                                    typ             = 'I',
                                                                    defaut          =  2,
                                                                   ),
                                           NOM_PARA          = SIMP(statut          = 'f',
                                                                    typ             = 'TXM',
                                                                    into            = ("NB_ITER_NEWTON",),
                                                                    defaut          = "NB_ITER_NEWTON",
                                                                    ),
                                           CRIT_COMP         = SIMP(statut          = 'f',
                                                                    typ             = 'TXM',
                                                                    into            = ("LT","GT","LE","GE"),
                                                                    defaut          = "LE",
                                                                    ),
                                           b_vale_I          = BLOC(fr              = "Valeur entiere",
                                                                    condition       = "NOM_PARA == 'NB_ITER_NEWTON' ",
                                                                    VALE_I          = SIMP(statut='f',typ='I',),
                                                                    ),
                                           ),


#
#  Parametres du mode de calcul de dt+
#      dans le cas FIXE            :(deltaT+) = (deltaT-)x(1+PCENT_AUGM/100)
#      dans le cas DELTA_GRANDEUR : (deltaT+) = (deltaT-)x(VALREF/deltaVAL) : l'acceleration est inversement proportionnelle
#                                                                             a la variation de la grandeur
#      dans le cas ITER_NEWTON    : (deltaT+) = (deltaT-) x sqrt(VALREF/N)  : l'acceleration est inversement proportionnelle
#                                                                             au nombre d'iterations de Newton precedent

                  MODE_CALCUL_TPLUS = SIMP(fr                = "Parametres du mode de calcul de dt+",
                                           statut            = 'f',
                                           max               = 1,
                                           typ               = 'TXM',
                                           into              = ("FIXE","DELTA_GRANDEUR","ITER_NEWTON","IMPLEX"),
                                           defaut            = 'FIXE',
                                           ),

                  b_mfixe           = BLOC(fr                = "Mode de calcul de dt+: fixe",
                                           condition         = "MODE_CALCUL_TPLUS == 'FIXE' ",
                                           PCENT_AUGM        = SIMP(statut          = 'f',
                                                                    max             = 1,
                                                                    typ             = 'R',
                                                                    defaut          = 100.,
                                                                    val_min         = -100.,
                                                                    ),
                                           ),
                  b_mdelta          = BLOC(fr                = "Mode de calcul de dt+: increment d'une grandeur",
                                           condition         = "MODE_CALCUL_TPLUS == 'DELTA_GRANDEUR' ",
                                           VALE_REF          = SIMP(statut          = 'o',
                                                                    max             = 1,
                                                                    typ             = 'R',
                                                                    ),
                                           NOM_CHAM          = SIMP(statut          = 'o',
                                                                    max             = 1,
                                                                    typ             = 'TXM',
                                                                    into            = ("DEPL","VARI_ELGA","SIEF_ELGA",),
                                                                    ),
                                           NOM_CMP           = SIMP(statut          = 'o',
                                                                    max             = 1,
                                                                    typ             = 'TXM',),
                                           ),
                  b_mitnew          = BLOC(fr                = "Mode de calcul de dt+: nb iterations de Newton",
                                           condition         = "MODE_CALCUL_TPLUS == 'ITER_NEWTON' ",
                                           NB_ITER_NEWTON_REF= SIMP(statut          = 'o',
                                                                    max             = 1,
                                                                    typ             = 'I',
                                                                    ),
                                           ),
# les schemas pre-definis :
#  abaqus :
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 2
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = 5
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 50.
#  Zebulon 1 :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='DELTA_GRANDEUR'
#      VALE_REF          = valref
#      NOM_CHAM          ='VARI_ELGA'
#      NOM_CMP           ='V1'
#  Zebulon 2 :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='ITER_NEWTON'
#      NB_ITER_NEWTON_REF= nc
#  Tough2 :
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 1
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = n
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 100.
#  Oliver :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='FORMULE'
#      NOM_SCHEMA        ='OLIVER'

             ),
      ),
# ----------------------------------------------------------------------------------------------------------------------------------

    INFO                  =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
DEFI_LIST_REEL=OPER(nom="DEFI_LIST_REEL",op=24,sd_prod=listr8_sdaster,
                    fr="Définir une liste de réels strictement croissante",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('VALE','DEBUT',),
                 EXCLUS('VALE','INTERVALLE'),
                 ENSEMBLE('DEBUT','INTERVALLE')),
         VALE            =SIMP(statut='f',typ='R',max='**'),
         DEBUT           =SIMP(statut='f',typ='R'),
         INTERVALLE      =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOMBRE','PAS'),),
           JUSQU_A         =SIMP(statut='o',typ='R'),
           NOMBRE          =SIMP(statut='f',typ='I'),
           PAS             =SIMP(statut='f',typ='R'),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
DEFI_MAILLAGE=OPER(nom="DEFI_MAILLAGE",op=  88,sd_prod=maillage_sdaster,
                   fr="Définition d'un nouveau maillage à partir de macro-éléments",
                   reentrant='n',
            UIinfo={"groupes":("Maillage",)},
         DEFI_SUPER_MAILLE =FACT(statut='o',max='**',
           MACR_ELEM       =SIMP(statut='o',typ=(macr_elem_stat,macr_elem_dyna),max='**' ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,max='**'),
           TRAN            =SIMP(statut='f',typ='R',max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           b_angl_naut     =BLOC(condition = "ANGL_NAUT != None",
             CENTRE          =SIMP(statut='f',typ='R',max=3),
           ),
         ),
         RECO_GLOBAL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,max='**'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         ),
         RECO_SUPER_MAILLE =FACT(statut='f',max='**',
           SUPER_MAILLE    =SIMP(statut='o',typ=ma,max='**'),
           GROUP_NO        =SIMP(statut='o',typ=grno,max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="GEOMETRIQUE",into=("GEOMETRIQUE","NOEUD_A_NOEUD","INVERSE") ),
           geometrique     =BLOC(condition = "OPTION == 'GEOMETRIQUE'",
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
         ),
         DEFI_NOEUD      =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD_INIT'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Renommage de tous les noeuds" ),
           NOEUD_INIT      =SIMP(statut='f',typ=no,
                                 fr="Renommage d un seul noeud"),
           b_tout          =BLOC(condition = "TOUT != None",
             PREFIXE         =SIMP(statut='f',typ='TXM' ),
             INDEX           =SIMP(statut='o',typ='I',max='**'),
           ),
           b_noeud_init    =BLOC(condition = "NOEUD_INIT != None",
             SUPER_MAILLE    =SIMP(statut='o',typ=ma),
             NOEUD_FIN       =SIMP(statut='o',typ=no),
           ),
         ),
         DEFI_GROUP_NO   =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),
                AU_MOINS_UN('INDEX','GROUP_NO_FIN'),
                   ENSEMBLE('GROUP_NO_INIT','GROUP_NO_FIN'),),
#  la regle ancien catalogue AU_MOINS_UN__: ( INDEX , GROUP_NO_FIN ) incoherente avec doc U
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Création de plusieurs groupes de noeuds" ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,
                                 fr="Création de plusieurs groupes de noeuds"),
           GROUP_NO_INIT   =SIMP(statut='f',typ=grno,
                                 fr="Création d un seul groupe de noeuds"),
           PREFIXE         =SIMP(statut='f',typ='TXM' ),
           INDEX           =SIMP(statut='f',typ='I',max='**'),
           GROUP_NO_FIN    =SIMP(statut='f',typ=grno),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-luc.flejou at edf.fr

DEFI_MATER_GC=MACRO(nom="DEFI_MATER_GC",
   op=OPS('Macro.defi_mater_gc_ops.defi_mater_gc_ops'),
   sd_prod=mater_sdaster,
   reentrant='n',
   UIinfo={"groupes":("Modélisation",) },
   fr="Définir des lois matériaux spécifique au Génie Civil",
   #
   regles = (UN_PARMI('MAZARS','ACIER','ENDO_FISS_EXP'), ),
   #
   REGLE =SIMP(statut='f',typ='TXM',     into=('EC2',),     defaut='EC2'),
   # ============================================================================
   MAZARS      =FACT(statut= 'f',max= 1,
      fr="Paramètres matériaux de MAZARS unilatéral en 1D à partir des caractéristiques du béton",
      UNITE_LONGUEUR =SIMP(statut='o',typ='TXM',   into=("M","MM"),
                           fr="Unité de longueur du problème [M|MM]"),
      FCJ            =SIMP(statut='o',typ='R',     val_min=0.0E+0,
                           fr="Contrainte au pic en compression [Unité]"),
      EIJ            =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Module d'Young [Unité]"),
      EPSI_C         =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Déformation au pic en compression"),
      FTJ            =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Contrainte au pic en traction [Unité]"),
      NU             =SIMP(statut='f',typ='R',     val_min=0.0E+0, val_max=0.5E+0,
                           fr="Coefficient de poisson"),
      EPSD0          =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Déformation, seuil d'endommagement"),
      K              =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Asymptote en cisaillement pur"),
      AC             =SIMP(statut='f',typ='R',     val_min=0.E+0,
                           fr="Paramètre de décroissance post-pic en compression"),
      BC             =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Paramètre de décroissance post-pic en compression"),
      AT             =SIMP(statut='f',typ='R',     val_min=0.0E+0, val_max=1.0E+0,
                           fr="Paramètre de décroissance post-pic en traction"),
      BT             =SIMP(statut='f',typ='R',     val_min=0.0E+0,
                           fr="Paramètre de décroissance post-pic en traction"),
      # Pour post-traitement ELS et ELU
      SIGM_LIM       =SIMP(statut='f',typ='R',  fr="Contrainte limite, post-traitement"),
      EPSI_LIM       =SIMP(statut='f',typ='R',  fr="Déformation limite, post-traitement"),
   ),
   # ============================================================================
   ACIER       =FACT(statut= 'f',max= 1,
      fr="Définir les paramètres matériaux de l'acier pour le Génie Civil",
      E              =SIMP(statut='o',typ='R',  val_min=0.0E+0,                     fr="Module d'Young"),
      SY             =SIMP(statut='o',typ='R',                                      fr="Limite élastique"),
      NU             =SIMP(statut='f',typ='R',  val_min=0.0E+0, val_max=0.5E+0,     fr="Coefficient de poisson"),
      D_SIGM_EPSI    =SIMP(statut='f',typ='R',                                      fr="Module plastique"),
      # Pour post-traitement ELS et ELU
      SIGM_LIM       =SIMP(statut='f',typ='R',  fr="Contrainte limite, post-traitement"),
      EPSI_LIM       =SIMP(statut='f',typ='R',  fr="Déformation limite, post-traitement"),
   ),
   # ============================================================================
   ENDO_FISS_EXP       =FACT(statut= 'f',max= 1,
      fr="Définir les paramètres matériaux du béton pour la loi ENDO_FISS_EXP",
      regles = (
        UN_PARMI('FT','FT_FENDAGE'),
        UN_PARMI('P','DSIG_DU'),
        EXCLUS('Q','Q_REL'),
        ),
      E              =SIMP(statut='o',typ='R',  val_min=0.0E+0,                     fr="Module d'Young"),
      NU             =SIMP(statut='o',typ='R',  val_min=0.0E+0, val_max=0.5E+0,     fr="Coefficient de poisson"),
      FT             =SIMP(statut='f',typ='R',  val_min=0.0E+0                ,     fr="Limite en traction simple"),
      FT_FENDAGE     =SIMP(statut='f',typ='R',  val_min=0.0E+0                ,     fr="Limite en traction obtenue via un essai brésilien"),
      FC             =SIMP(statut='o',typ='R',  val_min=0.0E+0                ,     fr="Limite en compression simple"),
      GF             =SIMP(statut='o',typ='R',  val_min=0.0E+0                ,     fr="Energie de fissuration"),
      P              =SIMP(statut='f',typ='R',  val_min=1.0E+0                ,     fr="Parametre dominant de la loi cohésive asymptotique"),
      DSIG_DU        =SIMP(statut='f',typ='R',  val_min=1.102658              ,     fr="Pente initiale (au signe pres) de la loi cohesive asymptotique"),
      Q              =SIMP(statut='f',typ='R',  val_min=0.0E+0                ,     fr="Parametre secondaire de la loi cohesive asymptotique"),
      Q_REL          =SIMP(statut='f',typ='R',  val_min=0.0E+0, val_max=1.0   ,     fr="Parametre Q exprime de maniere relative par rapport a Qmax(P)"),
      LARG_BANDE     =SIMP(statut='o',typ='R',  val_min=0.0E+0                ,     fr="Largeur de bande d'endommagement (2*D)"),
      COEF_RIGI_MINI =SIMP(statut='f',typ='R',  val_min=0.0, defaut = 0.0     ,     fr="Rigidite minimale dans la matrice tangente"),
   ),
   # ============================================================================
   INFO        =SIMP(statut='f',typ='I',     into=(1,2,),     defaut=1),
   RHO         =SIMP(statut='f',typ='R',     fr="Masse volumique"),
   ALPHA       =SIMP(statut='f',typ='R',     fr="Coefficient de dilatation"),
   AMOR_ALPHA  =SIMP(statut='f',typ='R'),
   AMOR_BETA   =SIMP(statut='f',typ='R'),
   AMOR_HYST   =SIMP(statut='f',typ='R'),
)


# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
DEFI_MATERIAU=OPER(nom="DEFI_MATERIAU",op=5,sd_prod=mater_sdaster,
                   fr="Définition des paramètres décrivant le comportement d un matériau",
                   reentrant='f',
            UIinfo={"groupes":("Modélisation",)},
       regles=(EXCLUS('ELAS','ELAS_FO','ELAS_FLUI','ELAS_ISTR','ELAS_ISTR_FO','ELAS_ORTH',
                      'ELAS_ORTH_FO','ELAS_COQUE','ELAS_COQUE_FO',
                      'ELAS_HYPER','ELAS_2NDG','ELAS_GLRC'),
               EXCLUS('THER','THER_FO','THER_ORTH','THER_NL'),
               EXCLUS('ECRO_LINE','ECRO_LINE_FO','ECRO_PUIS','ECRO_COOK','ECRO_COOK_FO',),
               EXCLUS('ENDO_HETEROGENE'),
               EXCLUS('TAHERI','TAHERI_FO'),
               EXCLUS('ENDO_SCALAIRE','ENDO_SCALAIRE_FO'),
               EXCLUS('ENDO_FISS_EXP','ENDO_FISS_EXP_FO'),
               EXCLUS('ROUSSELIER','ROUSSELIER_FO'),
               EXCLUS('VISC_SINH','VISC_SINH_FO'),
               PRESENT_PRESENT('ROUSSELIER','TRACTION'),
               PRESENT_PRESENT('ROUSSELIER_FO','TRACTION'),
               EXCLUS('CIN1_CHAB','CIN1_CHAB_FO'),
               EXCLUS('CIN2_CHAB','CIN2_CHAB_FO'),
               EXCLUS('VISCOCHAB','VISCOCHAB_FO'),
               EXCLUS('LEMAITRE','LEMAITRE_FO','VISC_IRRA_LOG',
               'LEMA_SEUIL','LEMA_SEUIL_FO','LEMAITRE_IRRA','LMARC_IRRA',),
               EXCLUS('META_LEMA_ANI','META_LEMA_ANI_FO'),
               EXCLUS('VENDOCHAB','VENDOCHAB_FO'),
               EXCLUS('VISC_ENDO','VISC_ENDO_FO'),
               PRESENT_PRESENT('BPEL_ACIER','ELAS'),
               PRESENT_PRESENT('ETCC_ACIER','ELAS'),
               EXCLUS('ETCC_ACIER','BPEL_ACIER'),
               EXCLUS('ETCC_BETON','BPEL_BETON'),

               EXCLUS('RCCM','RCCM_FO'),
               EXCLUS('WEIBULL','WEIBULL_FO'),
               PRESENT_PRESENT('DHRC','DHRC_SEUILS'),
               PRESENT_PRESENT('LAIGLE','ELAS'),
               PRESENT_PRESENT('LETK','ELAS'),
               PRESENT_PRESENT('DRUCK_PRAGER','ELAS'),
               PRESENT_PRESENT('VISC_DRUC_PRAG','ELAS'),
               PRESENT_PRESENT('ELAS_GONF','ELAS'),
               PRESENT_PRESENT('HOEK_BROWN','ELAS'),
               EXCLUS('MAZARS','MAZARS_FO'),
               PRESENT_PRESENT('JOINT_BA','ELAS'),
               PRESENT_PRESENT('CABLE','ELAS'),
               PRESENT_PRESENT('MOHR_COULOMB','ELAS'),
               PRESENT_PRESENT('ELAS_GLRC','GLRC_DM'),
               ),
           MATER      =SIMP(statut='f',typ=mater_sdaster),
#
# comportement élastique
#
           ELAS            =FACT(statut='f',
             E               =SIMP(statut='o',typ='R',val_min=0.E+0),
             NU              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=0.5E+0),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
             AMOR_ALPHA      =SIMP(statut='f',typ='R'),
             AMOR_BETA       =SIMP(statut='f',typ='R'),
             AMOR_HYST       =SIMP(statut='f',typ='R'),
           ),
           ELAS_FO         =FACT(statut='f',
             regles=(PRESENT_PRESENT('ALPHA','TEMP_DEF_ALPHA'),),
             E               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.),
             ALPHA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_ALPHA      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_BETA       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_HYST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K_DESSIC        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             B_ENDOGE        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             FONC_DESORP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_FLUI       =FACT(statut='f',
             E               =SIMP(statut='o',typ='R'),
             NU              =SIMP(statut='o',typ='R'),
             RHO             =SIMP(statut='o',typ='R'),
             PROF_RHO_F_INT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PROF_RHO_F_EXT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_MASS_AJOU  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_ISTR       =FACT(statut='f',
             E_L             =SIMP(statut='o',typ='R'),
             E_N             =SIMP(statut='o',typ='R'),
             NU_LT           =SIMP(statut='o',typ='R'),
             NU_LN           =SIMP(statut='o',typ='R'),
             G_LN            =SIMP(statut='o',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA_L         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_N         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ELAS_ISTR_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('ALPHA_L','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_N','TEMP_DEF_ALPHA'),
                    ),
             E_L             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_N             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LT           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.),
             ALPHA_L         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_N         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_ORTH       =FACT(statut='f',
             E_L             =SIMP(statut='o',typ='R'),
             E_T             =SIMP(statut='o',typ='R'),
             E_N             =SIMP(statut='f',typ='R'),
             NU_LT           =SIMP(statut='o',typ='R'),
             NU_LN           =SIMP(statut='f',typ='R'),
             NU_TN           =SIMP(statut='f',typ='R'),
             G_LT            =SIMP(statut='o',typ='R'),
             G_LN            =SIMP(statut='f',typ='R'),
             G_TN            =SIMP(statut='f',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA_L         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_T         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_N         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             XT              =SIMP(statut='f',typ='R',defaut= 1. ),
             XC              =SIMP(statut='f',typ='R',defaut= 1. ),
             YT              =SIMP(statut='f',typ='R',defaut= 1. ),
             YC              =SIMP(statut='f',typ='R',defaut= 1. ),
             S_LT            =SIMP(statut='f',typ='R',defaut= 1. ),
             AMOR_ALPHA      =SIMP(statut='f',typ='R'),
             AMOR_BETA       =SIMP(statut='f',typ='R'),
             AMOR_HYST       =SIMP(statut='f',typ='R'),
           ),
           ELAS_ORTH_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('ALPHA_L','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_N','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_T','TEMP_DEF_ALPHA'),
                    ),
             E_L             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_T             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_N             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LT           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_TN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LT            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_TN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1. ),
             ALPHA_L         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_T         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_N         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_ALPHA      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_BETA       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_HYST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_HYPER      =FACT(statut='f',
                                 regles=(UN_PARMI('K','NU'),),
             C10             =SIMP(statut='o',typ='R',
                                   fr="Si C10 est le seul coefficient fourni, alors le matériau est Néo-Hookéen."),
             C01             =SIMP(statut='f',typ='R',defaut=0.0,
                                   fr="Si l'on fournit C01 en plus de C10, on obtient un matériau de type Mooney-Rivlin."),
             C20             =SIMP(statut='f',typ='R',defaut=0.0,
                                   fr="Si l'on fournit C20 en plus de C10 et C01, on obtient un matériau de type Signorini."),
             K               =SIMP(statut='f',typ='R',fr="Module de compressibilité."),
             NU              =SIMP(statut='f',typ='R',val_min=-1.E+0,val_max=0.5E+0,fr="Coefficient de Poisson."),
             RHO             =SIMP(statut='f',typ='R',defaut=0.0,fr="Masse volumique."),
           ),
           ELAS_COQUE      =FACT(statut='f',
             regles=(EXCLUS('MEMB_L','M_LLLL',),
                     PRESENT_PRESENT('MEMB_L','MEMB_LT', 'MEMB_T','MEMB_G_LT','FLEX_L','FLEX_LT',
                                     'FLEX_T','FLEX_G_LT','CISA_L','CISA_T',),
                     PRESENT_PRESENT('M_LLLL','M_LLTT','M_LLLT','M_TTTT','M_TTLT','M_LTLT','F_LLLL',
                                     'F_LLTT','F_LLLT','F_TTTT','F_TTLT','F_LTLT','MF_LLLL',
                                     'MF_LLTT','MF_LLLT','MF_TTTT','MF_TTLT','MF_LTLT','MC_LLLZ',
                                     'MC_LLTZ','MC_TTLZ','MC_TTTZ','MC_LTLZ','MC_LTTZ','FC_LLLZ',
                                     'FC_LLTZ','FC_TTLZ','FC_TTTZ','FC_LTLZ','FC_LTTZ','C_LZLZ',
                                     'C_LZTZ','C_TZTZ'),),
             MEMB_L          =SIMP(statut='f',typ='R'),
             MEMB_LT         =SIMP(statut='f',typ='R'),
             MEMB_T          =SIMP(statut='f',typ='R'),
             MEMB_G_LT       =SIMP(statut='f',typ='R'),
             FLEX_L          =SIMP(statut='f',typ='R'),
             FLEX_LT         =SIMP(statut='f',typ='R'),
             FLEX_T          =SIMP(statut='f',typ='R'),
             FLEX_G_LT       =SIMP(statut='f',typ='R'),
             CISA_L          =SIMP(statut='f',typ='R'),
             CISA_T          =SIMP(statut='f',typ='R'),
             M_LLLL          =SIMP(statut='f',typ='R'),
             M_LLTT          =SIMP(statut='f',typ='R'),
             M_LLLT          =SIMP(statut='f',typ='R'),
             M_TTTT          =SIMP(statut='f',typ='R'),
             M_TTLT          =SIMP(statut='f',typ='R'),
             M_LTLT          =SIMP(statut='f',typ='R'),
             F_LLLL          =SIMP(statut='f',typ='R'),
             F_LLTT          =SIMP(statut='f',typ='R'),
             F_LLLT          =SIMP(statut='f',typ='R'),
             F_TTTT          =SIMP(statut='f',typ='R'),
             F_TTLT          =SIMP(statut='f',typ='R'),
             F_LTLT          =SIMP(statut='f',typ='R'),
             MF_LLLL         =SIMP(statut='f',typ='R'),
             MF_LLTT         =SIMP(statut='f',typ='R'),
             MF_LLLT         =SIMP(statut='f',typ='R'),
             MF_TTTT         =SIMP(statut='f',typ='R'),
             MF_TTLT         =SIMP(statut='f',typ='R'),
             MF_LTLT         =SIMP(statut='f',typ='R'),
             MC_LLLZ         =SIMP(statut='f',typ='R'),
             MC_LLTZ         =SIMP(statut='f',typ='R'),
             MC_TTLZ         =SIMP(statut='f',typ='R'),
             MC_TTTZ         =SIMP(statut='f',typ='R'),
             MC_LTLZ         =SIMP(statut='f',typ='R'),
             MC_LTTZ         =SIMP(statut='f',typ='R'),
             FC_LLLZ         =SIMP(statut='f',typ='R'),
             FC_LLTZ         =SIMP(statut='f',typ='R'),
             FC_TTLZ         =SIMP(statut='f',typ='R'),
             FC_TTTZ         =SIMP(statut='f',typ='R'),
             FC_LTLZ         =SIMP(statut='f',typ='R'),
             FC_LTTZ         =SIMP(statut='f',typ='R'),
             C_LZLZ          =SIMP(statut='f',typ='R'),
             C_LZTZ          =SIMP(statut='f',typ='R'),
             C_TZTZ          =SIMP(statut='f',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
           ),
           ELAS_COQUE_FO   =FACT(statut='f',
             regles=(EXCLUS('MEMB_L','M_LLLL',),
                     PRESENT_PRESENT('MEMB_L','MEMB_LT','MEMB_T','MEMB_G_LT','FLEX_L','FLEX_LT',
                                     'FLEX_T','FLEX_G_LT','CISA_L','CISA_T',),
                     PRESENT_PRESENT('M_LLLL','M_LLTT','M_LLLT','M_TTTT','M_TTLT','M_LTLT','F_LLLL',
                                     'F_LLTT','F_LLLT','F_TTTT','F_TTLT','F_LTLT','MF_LLLL','MF_LLTT',
                                     'MF_LLLT','MF_TTTT','MF_TTLT','MF_LTLT','MC_LLLZ','MC_LLTZ',
                                     'MC_TTLZ','MC_TTTZ','MC_LTLZ','MC_LTTZ','FC_LLLZ','FC_LLTZ',
                                     'FC_TTLZ','FC_TTTZ','FC_LTLZ','FC_LTTZ','C_LZLZ','C_LZTZ','C_TZTZ'),),
             MEMB_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_LT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_G_LT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_LT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_G_LT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CISA_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CISA_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLLL          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_TTTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_TTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLLL          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_TTTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_TTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLLL         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLTT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_TTTT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_TTLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LTLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LLLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LLTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_TTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_TTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LLLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LLTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_TTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_TTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_LZLZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_LZTZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_TZTZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_MEMBRANE     =FACT(statut='f',
             M_LLLL          =SIMP(statut='o',typ='R'),
             M_LLTT          =SIMP(statut='o',typ='R'),
             M_LLLT          =SIMP(statut='o',typ='R'),
             M_TTTT          =SIMP(statut='o',typ='R'),
             M_TTLT          =SIMP(statut='o',typ='R'),
             M_LTLT          =SIMP(statut='o',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
           ),
           ELAS_2NDG        =FACT(statut='f',
             A1              =SIMP(statut='o',typ='R'),
             A2              =SIMP(statut='f',typ='R'),
             A3              =SIMP(statut='f',typ='R'),
             A4              =SIMP(statut='f',typ='R'),
             A5              =SIMP(statut='f',typ='R'),
           ),
           ELAS_GLRC        =FACT(statut='f',
             regles=(PRESENT_PRESENT('BT1','BT2'),),
             E_M             =SIMP(statut='o',typ='R',val_min=0.E+0),
             NU_M            =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=0.5+0),
             E_F             =SIMP(statut='f',typ='R',val_min=0.E+0),
             NU_F            =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=0.5+0),
             BT1             =SIMP(statut='f',typ='R',val_min=0.E+0),
             BT2             =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=0.5+0),
             RHO             =SIMP(statut='f',typ='R',val_min=0.E+0),
             ALPHA           =SIMP(statut='f',typ='R'),
             AMOR_ALPHA      =SIMP(statut='f',typ='R'),
             AMOR_BETA       =SIMP(statut='f',typ='R'),
             AMOR_HYST       =SIMP(statut='f',typ='R'),
           ),
           ELAS_GLRC_FO     =FACT(statut='f',
             regles=(PRESENT_PRESENT('ALPHA','TEMP_DEF_ALPHA'),
                     PRESENT_PRESENT('BT1','BT2'),),
             E_M             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_M            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_F             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_F            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BT1             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BT2             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_ALPHA      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_BETA       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_HYST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           CABLE           =FACT(statut='f',
             EC_SUR_E        =SIMP(statut='f',typ='R',defaut= 1.E-4 ),
           ),
#
# comportements mécanique non linéaire
# vérification du domaine de validité
           VERI_BORNE      =FACT(statut='f',
             regles=(ENSEMBLE('TEMP_MAXI','TEMP_MINI'),
                     ),
             EPSI_MAXI       =SIMP(statut='f',typ='R'),
             TEMP_MAXI       =SIMP(statut='f',typ='R'),
             TEMP_MINI       =SIMP(statut='f',typ='R'),
             VEPS_MAXI       =SIMP(statut='f',typ='R'),
           ),
           TRACTION        =FACT(statut='f',
             SIGM            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),

           ),
           ECRO_LINE       =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R',),
             SY              =SIMP(statut='o',typ='R',),
             SIGM_LIM        =SIMP(statut='f',typ='R'),
             EPSI_LIM        =SIMP(statut='f',typ='R'),
           ),
           ENDO_HETEROGENE   =FACT(statut='f',
             WEIBULL         =SIMP(statut='o',typ='R',),
             SY              =SIMP(statut='o',typ='R',),
             KI              =SIMP(statut='o',typ='R',),
             EPAI            =SIMP(statut='o',typ='R',),
             GR              =SIMP(statut='f',typ='R',defaut= 1.0),
           ),
           ECRO_LINE_FO    =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ECRO_PUIS       =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R',),
             A_PUIS          =SIMP(statut='o',typ='R',val_min=0.0),
             N_PUIS          =SIMP(statut='o',typ='R',val_min=1.E-6),
           ),
           ECRO_PUIS_FO    =FACT(statut='f',
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_PUIS          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N_PUIS          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ECRO_COOK       =FACT(statut='f',
             regles=(PRESENT_PRESENT('C','EPSP0'),
                     PRESENT_PRESENT('TROOM','TMELT','M_PUIS'),),
             A               =SIMP(statut='o',typ='R',val_min=0.0),
             B               =SIMP(statut='o',typ='R',val_min=0.0),
             C               =SIMP(statut='f',typ='R',val_min=0.0),
             N_PUIS          =SIMP(statut='o',typ='R',val_min=0.0),
             M_PUIS          =SIMP(statut='f',typ='R',val_min=0.0),
             EPSP0           =SIMP(statut='f',typ='R',val_min=1.E-6),
             TROOM           =SIMP(statut='f',typ='R',val_min=0.0),
             TMELT           =SIMP(statut='f',typ='R',val_min=0.0),
           ),
           ECRO_COOK_FO       =FACT(statut='f',
             regles=(PRESENT_PRESENT('C','EPSP0'),
                     PRESENT_PRESENT('TROOM','TMELT','M_PUIS'),),
             A               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C               =SIMP(statut='f',typ='R',val_min=0.0),
             N_PUIS          =SIMP(statut='o',typ='R',val_min=0.0),
             M_PUIS          =SIMP(statut='f',typ='R',val_min=0.0),
             EPSP0           =SIMP(statut='f',typ='R',val_min=1.E-6),
             TROOM           =SIMP(statut='f',typ='R',val_min=0.0),
             TMELT           =SIMP(statut='f',typ='R',val_min=0.0),
           ),
           BETON_ECRO_LINE =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R'),
             SYT             =SIMP(statut='o',typ='R'),
             SYC             =SIMP(statut='f',typ='R'),
           ),
           BETOP_REGLE_PR =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R'),
             SYT             =SIMP(statut='o',typ='R'),
             SYC             =SIMP(statut='f',typ='R'),
             EPSC            =SIMP(statut='f',typ='R'),
             N               =SIMP(statut='f',typ='R'),
           ),
           ENDO_ORTH_BETON  =FACT(statut='f',
             ALPHA            =SIMP(statut='f',typ='R',defaut=0.9),
             K0               =SIMP(statut='o',typ='R'),
             K1               =SIMP(statut='o',typ='R'),
             K2               =SIMP(statut='f',typ='R',defaut=7.E-4),
             ECROB            =SIMP(statut='o',typ='R'),
             ECROD            =SIMP(statut='o',typ='R'),
           ),
           PRAGER          =FACT(statut='f',
             C               =SIMP(statut='o',typ='R'),
           ),
           PRAGER_FO       =FACT(statut='f',
             C               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           TAHERI          =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             ALPHA           =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             C1              =SIMP(statut='o',typ='R'),
             C_INF           =SIMP(statut='o',typ='R'),
             S               =SIMP(statut='o',typ='R'),
           ),
           TAHERI_FO       =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_INF           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ROUSSELIER      =FACT(statut='f',
             D               =SIMP(statut='o',typ='R'),
             SIGM_1          =SIMP(statut='o',typ='R'),
             PORO_INIT       =SIMP(statut='o',typ='R'),
             PORO_CRIT       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_ACCE       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_LIMI       =SIMP(statut='f',typ='R',defaut= 0.999 ),
             D_SIGM_EPSI_NORM=SIMP(statut='f',typ='R',defaut= 1. ),
             AN              =SIMP(statut='f',typ='R',defaut= 0. ),
             DP_MAXI         =SIMP(statut='f',typ='R',defaut= 0.1),
             BETA            =SIMP(statut='f',typ='R',defaut=0.85),
           ),
           ROUSSELIER_FO   =FACT(statut='f',
             D               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_1          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PORO_INIT       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PORO_CRIT       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_ACCE       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_LIMI       =SIMP(statut='f',typ='R',defaut= 0.999 ),
             D_SIGM_EPSI_NORM=SIMP(statut='f',typ='R',defaut= 1. ),
             AN              =SIMP(statut='f',typ='R',defaut= 0. ),
             DP_MAXI         =SIMP(statut='f',typ='R',defaut= 0.1),
             BETA            =SIMP(statut='f',typ='R',defaut=0.85),
           ),
           VISC_SINH      =FACT(statut='f',
             SIGM_0          =SIMP(statut='o',typ='R'),
             EPSI_0          =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
           ),
           VISC_SINH_FO      =FACT(statut='f',
             SIGM_0          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             EPSI_0          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           CIN1_CHAB  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             R_I             =SIMP(statut='f',typ='R'),
             B               =SIMP(statut='f',typ='R',defaut= 0.0E+0),
             C_I             =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             W               =SIMP(statut='f',typ='R',defaut= 0.0E+0),
             G_0             =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           ),
           CIN1_CHAB_FO  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             W               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           CIN2_CHAB  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             R_I             =SIMP(statut='f',typ='R'),
             B               =SIMP(statut='f',typ='R',defaut= 0.E+0),
             C1_I            =SIMP(statut='o',typ='R'),
             C2_I            =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='f',typ='R',defaut= 1.),
             W               =SIMP(statut='f',typ='R',defaut= 0.E+0),
             G1_0            =SIMP(statut='o',typ='R'),
             G2_0            =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
           ),
           CIN2_CHAB_FO  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1_I            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C2_I            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             W               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G1_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G2_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           CIN2_NRAD  =FACT(statut='f',
             DELTA1          =SIMP(statut='f',typ='R',defaut= 1.E+0,val_min=0.E+0, val_max=1.E+0),
             DELTA2          =SIMP(statut='f',typ='R',defaut= 1.E+0,val_min=0.E+0, val_max=1.E+0),
           ),
           MEMO_ECRO       =FACT(statut='f',
             MU              =SIMP(statut='o',typ='R'),
             Q_M             =SIMP(statut='o',typ='R'),
             Q_0             =SIMP(statut='o',typ='R'),
             ETA             =SIMP(statut='f',typ='R',defaut= 0.5E+0 ),
           ),
           MEMO_ECRO_FO        =FACT(statut='f',
             MU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_M             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ETA             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           VISCOCHAB       =FACT(statut='f',
             K_0             =SIMP(statut='o',typ='R'),
             A_K             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             A_R             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             K               =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             ALP             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             B               =SIMP(statut='f',typ='R'),
             M_R             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             G_R             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             MU              =SIMP(statut='o',typ='R',defaut= 0.E+0 ),
             Q_M             =SIMP(statut='o',typ='R'),
             Q_0             =SIMP(statut='o',typ='R'),
             QR_0            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ETA             =SIMP(statut='f',typ='R',defaut= 0.5E+0 ),
             C1              =SIMP(statut='o',typ='R'),
             M_1             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             D1              =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             G_X1            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             G1_0            =SIMP(statut='o',typ='R'),
             C2              =SIMP(statut='o',typ='R'),
             M_2             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             D2              =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
             G_X2            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             G2_0            =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
           ),
           VISCOCHAB_FO    =FACT(statut='f',
             K_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_K             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALP             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_M             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             QR_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ETA             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_1             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_X1            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G1_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C2              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_2             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D2              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_X2            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G2_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           LEMAITRE        =FACT(statut='f',
             N               =SIMP(statut='o',typ='R'),
             UN_SUR_K        =SIMP(statut='o',typ='R'),
             UN_SUR_M        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           LEMAITRE_IRRA    =FACT(statut='f',
             N               =SIMP(statut='o',typ='R'),
             UN_SUR_K        =SIMP(statut='o',typ='R'),
             UN_SUR_M        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             QSR_K           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             BETA            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PHI_ZERO        =SIMP(statut='f',typ='R',defaut= 1.E+20),
             L               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_FO         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           LMARC_IRRA       =FACT(statut='f',
             DE_0            =SIMP(statut='o',typ='R'),
             R_0             =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             Y_I             =SIMP(statut='o',typ='R'),
             Y_0             =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             A_0             =SIMP(statut='o',typ='R'),
             RM              =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             P               =SIMP(statut='o',typ='R'),
             P1              =SIMP(statut='o',typ='R'),
             P2              =SIMP(statut='o',typ='R'),
             M11             =SIMP(statut='o',typ='R'),
             M22             =SIMP(statut='o',typ='R'),
             M33             =SIMP(statut='o',typ='R'),
             M66             =SIMP(statut='o',typ='R'),
             N11             =SIMP(statut='o',typ='R'),
             N22             =SIMP(statut='o',typ='R'),
             N33             =SIMP(statut='o',typ='R'),
             N66             =SIMP(statut='o',typ='R'),
             Q11             =SIMP(statut='o',typ='R'),
             Q22             =SIMP(statut='o',typ='R'),
             Q33             =SIMP(statut='o',typ='R'),
             Q66             =SIMP(statut='o',typ='R'),
             R11             =SIMP(statut='o',typ='R'),
             R22             =SIMP(statut='o',typ='R'),
             R33             =SIMP(statut='o',typ='R'),
             R66             =SIMP(statut='o',typ='R'),
             GRAN_FO         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
          VISC_IRRA_LOG    =FACT(statut='f',
             A               =SIMP(statut='f',typ='R',defaut= 1.28E-1),
             B               =SIMP(statut='f',typ='R',defaut= 0.01159),
             CSTE_TPS        =SIMP(statut='f',typ='R',defaut= 0.3540),
             ENER_ACT        =SIMP(statut='f',typ='R',defaut= 5000.),
             FLUX_PHI        =SIMP(statut='o',typ='R',),
           ),
          GRAN_IRRA_LOG    =FACT(statut='f',
             A               =SIMP(statut='f',typ='R',defaut= 1.28E-1),
             B               =SIMP(statut='f',typ='R',defaut= 0.01159),
             CSTE_TPS        =SIMP(statut='f',typ='R',defaut= 0.3540),
             ENER_ACT        =SIMP(statut='f',typ='R',defaut= 5000.),
             FLUX_PHI        =SIMP(statut='o',typ='R',),
             GRAN_FO         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
          LEMA_SEUIL   =FACT(statut='f',
             A               =SIMP(statut='o',typ='R',),
             S               =SIMP(statut='o',typ='R',),
           ),
          LEMA_SEUIL_FO=FACT(statut='f',
             A               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
         IRRAD3M=FACT(statut='f',
               R02      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
               EPSI_U   =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
               RM       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
               AI0      =SIMP(statut='o',typ='R',val_min=0.0),
               ZETA_F   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
               ETAI_S   =SIMP(statut='o',typ='R',val_min=0.0),
               RG0      =SIMP(statut='o',typ='R',val_min=0.0),
               ALPHA    =SIMP(statut='o',typ='R',val_min=0.0),
               PHI0     =SIMP(statut='o',typ='R',val_min=0.0),
               KAPPA    =SIMP(statut='f',typ='R',val_min=0.0,defaut=0.8,val_max=1.0),
               ZETA_G   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
               TOLER_ET =SIMP(statut='f',typ='R',val_min=0.0,defaut=0.15 ),
         ),
           LEMAITRE_FO     =FACT(statut='f',
             N               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             UN_SUR_K        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             UN_SUR_M        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
             META_LEMA_ANI     =FACT(statut='f',
             F1_A            =SIMP(statut='o',typ='R'),
             F2_A            =SIMP(statut='o',typ='R'),
             C_A             =SIMP(statut='o',typ='R'),
             F1_M            =SIMP(statut='o',typ='R'),
             F2_M            =SIMP(statut='o',typ='R'),
             C_M             =SIMP(statut='o',typ='R'),
             F1_N            =SIMP(statut='o',typ='R'),
             F2_N            =SIMP(statut='o',typ='R'),
             C_N             =SIMP(statut='o',typ='R'),
             F1_Q            =SIMP(statut='o',typ='R'),
             F2_Q            =SIMP(statut='o',typ='R'),
             C_Q             =SIMP(statut='o',typ='R'),
             F_MRR_RR        =SIMP(statut='o',typ='R'),
             C_MRR_RR        =SIMP(statut='o',typ='R'),
             F_MTT_TT        =SIMP(statut='o',typ='R'),
             C_MTT_TT        =SIMP(statut='o',typ='R'),
             F_MZZ_ZZ        =SIMP(statut='o',typ='R'),
             C_MZZ_ZZ        =SIMP(statut='o',typ='R'),
             F_MRT_RT        =SIMP(statut='o',typ='R'),
             C_MRT_RT        =SIMP(statut='o',typ='R'),
             F_MRZ_RZ        =SIMP(statut='o',typ='R'),
             C_MRZ_RZ        =SIMP(statut='o',typ='R'),
             F_MTZ_TZ        =SIMP(statut='o',typ='R'),
             C_MTZ_TZ        =SIMP(statut='o',typ='R'),
           ),
             META_LEMA_ANI_FO  =FACT(statut='f',
             F1_A            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_A            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_A             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_M            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_M            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_M             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_N            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_N            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_N             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_Q            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_Q            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_Q             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MRR_RR        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MRR_RR        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MTT_TT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MTT_TT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MZZ_ZZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MZZ_ZZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MRT_RT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MRT_RT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MRZ_RZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MRZ_RZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_MTZ_TZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_MTZ_TZ        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ARME            =FACT(statut='f',
             KYE             =SIMP(statut='o',typ='R'),
             DLE             =SIMP(statut='o',typ='R'),
             KYP             =SIMP(statut='o',typ='R'),
             DLP             =SIMP(statut='o',typ='R'),
             KYG             =SIMP(statut='o',typ='R'),
           ),
           ASSE_CORN       =FACT(statut='f',
             NU_1            =SIMP(statut='o',typ='R'),
             MU_1            =SIMP(statut='o',typ='R'),
             DXU_1           =SIMP(statut='o',typ='R'),
             DRYU_1          =SIMP(statut='o',typ='R'),
             C_1             =SIMP(statut='o',typ='R'),
             NU_2            =SIMP(statut='o',typ='R'),
             MU_2            =SIMP(statut='o',typ='R'),
             DXU_2           =SIMP(statut='o',typ='R'),
             DRYU_2          =SIMP(statut='o',typ='R'),
             C_2             =SIMP(statut='o',typ='R'),
             KY              =SIMP(statut='o',typ='R'),
             KZ              =SIMP(statut='o',typ='R'),
             KRX             =SIMP(statut='o',typ='R'),
             KRZ             =SIMP(statut='o',typ='R'),
             R_P0            =SIMP(statut='f',typ='R',defaut= 1.E+4 ),
           ),
           DIS_CONTACT     =FACT(statut='f',
             RIGI_NOR        =SIMP(statut='f',typ='R' ),
             RIGI_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             AMOR_NOR        =SIMP(statut='f',typ='R' ),
             AMOR_TAN        =SIMP(statut='f',typ='R' ),
             COULOMB         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             DIST_1          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             DIST_2          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             JEU             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ENDO_SCALAIRE   =FACT(statut='f',
             K               =SIMP(statut='o',typ='R',val_min=0.0),
             P               =SIMP(statut='o',typ='R',val_min=1.0),
             Q               =SIMP(statut='f',typ='R',defaut=0.0),
             M               =SIMP(statut='o',typ='R',),
             C_COMP          =SIMP(statut='f',typ='R',defaut=0.0),
             C_VOLU          =SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R',defaut=1.E-5),
           ),
           ENDO_SCALAIRE_FO =FACT(statut='f',
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             P               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q               =SIMP(statut='f',typ='R',defaut=0.0),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_COMP          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_VOLU          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R',defaut=1.E-5),
           ),
           ENDO_FISS_EXP    =FACT(statut='f',
             K               =SIMP(statut='o',typ='R',val_min=0.0),
             P               =SIMP(statut='o',typ='R',val_min=1.0),
             Q               =SIMP(statut='f',typ='R',defaut=0.0),
             M               =SIMP(statut='o',typ='R',),
             TAU             =SIMP(statut='o',typ='R'),
             SIG0            =SIMP(statut='o',typ='R'),
             BETA            =SIMP(statut='f',typ='R',defaut=0.1),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R',defaut=1.E-5),
           ),
           ENDO_FISS_EXP_FO =FACT(statut='f',
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             P               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q               =SIMP(statut='f',typ='R',defaut=0.0),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             TAU             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIG0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='f',typ='R',defaut=0.1),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R',defaut=1.E-5),
           ),
           DIS_GRICRA    =FACT(statut='f',
             KN_AX       =SIMP(statut='o',typ='R' ),
             KT_AX       =SIMP(statut='o',typ='R' ),
             COUL_AX     =SIMP(statut='o',typ='R' ),
             F_SER       =SIMP(statut='f',typ='R' ),
             F_SER_FO    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ET_AX       =SIMP(statut='f',typ='R',defaut=1.e-7 ),
             ET_ROT      =SIMP(statut='f',typ='R',defaut=1.e-7 ),
             ANG1        =SIMP(statut='f',typ='R' ),
             ANG2        =SIMP(statut='f',typ='R' ),
             PEN1        =SIMP(statut='f',typ='R' ),
             PEN2        =SIMP(statut='f',typ='R' ),
             PEN3        =SIMP(statut='f',typ='R' ),
             ANG1_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANG2_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN1_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN2_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN3_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             regles=(EXCLUS('ANG1','ANG1_FO',),
                     UN_PARMI('ANG1','ANG1_FO',),
                     EXCLUS('F_SER','F_SER_FO',),
                     UN_PARMI('F_SER','F_SER_FO',),
                     PRESENT_PRESENT('ANG1','ANG2','PEN1','PEN2','PEN3',),
                     PRESENT_PRESENT('ANG1_FO','ANG2_FO','PEN1_FO','PEN2_FO','PEN3_FO',),
                                     ),
           ),
           BETON_DOUBLE_DP =FACT(statut='f',
             F_C             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_T             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_BIAX       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ENER_COMP_RUPT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ENER_TRAC_RUPT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_ELAS_COMP  =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=100.E+0),
             LONG_CARA       =SIMP(statut='f',typ='R',val_min=0.E+0),
             ECRO_COMP_P_PIC =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",into=("LINEAIRE","PARABOLE") ),
             ECRO_TRAC_P_PIC =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",into=("LINEAIRE","EXPONENT") ),
           ),
         MAZARS=FACT(statut='f',min=0 ,
             EPSD0           =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             AC              =SIMP(statut='o',typ='R'),
             BC              =SIMP(statut='o',typ='R'),
             AT              =SIMP(statut='o',typ='R'),
             BT              =SIMP(statut='o',typ='R'),
             CHI             =SIMP(statut='f',typ='R',val_min=0.0E+0,val_max=1.0E+0),
             SIGM_LIM        =SIMP(statut='f',typ='R'),
             EPSI_LIM        =SIMP(statut='f',typ='R'),
           ),
         MAZARS_FO=FACT(statut='f',min=0 ,
             EPSD0           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AT              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BT              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CHI             =SIMP(statut='f',typ='R'),
           ),
         JOINT_BA=FACT(statut='f',min=0 ,max=1,
             HPEN            =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=0.E+0),
             GTT             =SIMP(statut='o',typ='R',val_min=0.E+0),
             GAMD0           =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E-1),
             AD1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BD1             =SIMP(statut='o',typ='R',defaut= 5.E-1,val_min=1.E-1),
             GAMD2           =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E+0),
             AD2             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BD2             =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=1.E-1),
             VIFROT          =SIMP(statut='o',typ='R',val_min=0.E+0),
             FA              =SIMP(statut='o',typ='R',val_min=0.E+0),
             FC              =SIMP(statut='o',typ='R',val_min=0.E+0),
             EPSTR0          =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E+0),
             ADN             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BDN             =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=1.E-1),
           ),
          VENDOCHAB       =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R',defaut= 0.E+0),
             ALPHA_D         =SIMP(statut='o',typ='R',defaut= 0.E+0),
             BETA_D          =SIMP(statut='o',typ='R',defaut= 0.E+0),
             R_D             =SIMP(statut='o',typ='R'),
             A_D             =SIMP(statut='o',typ='R'),
             K_D             =SIMP(statut='o',typ='R'),
           ),
           VENDOCHAB_FO    =FACT(statut='f',
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_D         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA_D          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
          HAYHURST     =FACT(statut='f',
             EPS0         =SIMP(statut='o',typ='R'),
             K            =SIMP(statut='o',typ='R'),
             H1           =SIMP(statut='o',typ='R'),
             H2           =SIMP(statut='o',typ='R'),
             DELTA1       =SIMP(statut='o',typ='R'),
             DELTA2       =SIMP(statut='o',typ='R'),
             H1ST         =SIMP(statut='o',typ='R'),
             H2ST         =SIMP(statut='o',typ='R'),
             KC           =SIMP(statut='f',typ='R',defaut=0.),
             BIGA         =SIMP(statut='o',typ='R'),
             SIG0         =SIMP(statut='o',typ='R'),
             ALPHAD       =SIMP(statut='f',typ='R',defaut=0.),
             S_EQUI_D     =SIMP(statut='f',typ='R',defaut=0.,into=(0.,1.) ),
           ),
           VISC_ENDO      =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R',defaut= 0.E+0),
             R_D             =SIMP(statut='o',typ='R'),
             A_D             =SIMP(statut='o',typ='R'),
           ),
           VISC_ENDO_FO   =FACT(statut='f',
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           PINTO_MENEGOTTO =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R'),
             EPSI_ULTM       =SIMP(statut='o',typ='R'),
             SIGM_ULTM       =SIMP(statut='o',typ='R'),
             ELAN            =SIMP(statut='f',typ='R',defaut= 4. ),
             EPSP_HARD       =SIMP(statut='o',typ='R'),
             R_PM            =SIMP(statut='f',typ='R',defaut= 20. ),
             EP_SUR_E        =SIMP(statut='f',typ='R'),
             A1_PM           =SIMP(statut='f',typ='R',defaut= 18.5 ),
             A2_PM           =SIMP(statut='f',typ='R',defaut= 0.15 ),
             A6_PM           =SIMP(statut='f',typ='R',defaut= 620. ),
             C_PM            =SIMP(statut='f',typ='R',defaut= 0.5 ),
             A_PM            =SIMP(statut='f',typ='R',defaut= 6.0E-3 ),
           ),
           BPEL_BETON      =FACT(statut='f',
             PERT_FLUA       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PERT_RETR       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           BPEL_ACIER      =FACT(statut='f',
            regles=(PRESENT_PRESENT('RELAX_1000','F_PRG',),
                     PRESENT_PRESENT('MU0_RELAX','F_PRG',),),
             RELAX_1000      =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             MU0_RELAX       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             F_PRG           =SIMP(statut='f',typ='R'),
             FROT_COURB      =SIMP(statut='f',typ='R',defaut=0.E+0),
             FROT_LINE       =SIMP(statut='f',typ='R',defaut=0.E+0),
           ),
          ETCC_BETON      =FACT(statut='f',
            EP_BETON           =SIMP(statut='f',typ='R',val_min=0.E+0,defaut=0. ),
           ),
          ETCC_ACIER      =FACT(statut='f',
            regles=(PRESENT_PRESENT('RELAX_1000','F_PRG',),),
             F_PRG           =SIMP(statut='f',typ='R',val_min=0.E+0),
             COEF_FROT       =SIMP(statut='f',typ='R',defaut=0.E+0,val_min=0.E+0),
             PERT_LIGNE     =SIMP(statut='f',typ='R',defaut=0.E+0,val_min=0.E+0),
             RELAX_1000      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),


           ),
           MOHR_COULOMB  =FACT(statut='f',
               PHI         =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=60.E+0,),
               ANGDIL      =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=60.E+0,),
               COHESION    =SIMP(statut='o',typ='R',val_min=0.E+0,),
             ),

           CAM_CLAY      =FACT(statut='f',
             MU              =SIMP(statut='o',typ='R'),
             PORO            =SIMP(statut='o',typ='R'),
             LAMBDA          =SIMP(statut='o',typ='R'),
             KAPA            =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             PRES_CRIT       =SIMP(statut='o',typ='R'),
             KCAM            =SIMP(statut='f',typ='R',val_min=0.E+0),
             PTRAC           =SIMP(statut='f',typ='R',val_max=0.E+0),
               regles=(PRESENT_PRESENT('PTRAC','KCAM',),),
           ),
           BARCELONE      =FACT(statut='f',
             MU              =SIMP(statut='o',typ='R'),
             PORO            =SIMP(statut='o',typ='R'),
             LAMBDA          =SIMP(statut='o',typ='R'),
             KAPA            =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             PRES_CRIT       =SIMP(statut='o',typ='R'),
             PA            =SIMP(statut='o',typ='R'),
             R             =SIMP(statut='o',typ='R'),
             BETA          =SIMP(statut='o',typ='R'),
             KC            =SIMP(statut='o',typ='R'),
             PC0_INIT      =SIMP(statut='o',typ='R'),
             KAPAS         =SIMP(statut='o',typ='R'),
             LAMBDAS       =SIMP(statut='o',typ='R'),
             ALPHAB        =SIMP(statut='f',typ='R'),
           ),
           CJS             =FACT(statut='f',
             BETA_CJS        =SIMP(statut='o',typ='R'),
             RM              =SIMP(statut='o',typ='R'),
             N_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             KP              =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             RC              =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             A_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             B_CJS           =SIMP(statut='f',typ='R',defaut= 1.0E+25 ),
             C_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GAMMA_CJS       =SIMP(statut='o',typ='R'),
             MU_CJS          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PCO             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PA              =SIMP(statut='o',typ='R'),
             Q_INIT          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             R_INIT          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           HUJEUX   =FACT(statut='f',
             N      =SIMP(statut='o',typ='R' ),
             BETA   =SIMP(statut='o',typ='R' ),
             B      =SIMP(statut='o',typ='R' ),
             D      =SIMP(statut='o',typ='R' ),
             PHI    =SIMP(statut='o',typ='R' ),
             ANGDIL =SIMP(statut='o',typ='R' ),
             PCO    =SIMP(statut='o',typ='R' ),
             PREF   =SIMP(statut='o',typ='R' ),
             ACYC   =SIMP(statut='o',typ='R' ),
             AMON   =SIMP(statut='o',typ='R' ),
             CCYC   =SIMP(statut='o',typ='R' ),
             CMON   =SIMP(statut='o',typ='R' ),
             RD_ELA =SIMP(statut='o',typ='R' ),
             RI_ELA =SIMP(statut='o',typ='R' ),
             RHYS   =SIMP(statut='o',typ='R' ),
             RMOB   =SIMP(statut='o',typ='R' ),
             XM     =SIMP(statut='o',typ='R' ),
             RD_CYC =SIMP(statut='o',typ='R' ),
             RI_CYC =SIMP(statut='o',typ='R' ),
             DILA   =SIMP(statut='o',typ='R' ),
             PTRAC  =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ECRO_ASYM_LINE  =FACT(statut='f',
             DC_SIGM_EPSI    =SIMP(statut='o',typ='R'),
             SY_C            =SIMP(statut='o',typ='R'),
             DT_SIGM_EPSI    =SIMP(statut='o',typ='R'),
             SY_T            =SIMP(statut='o',typ='R'),
           ),
           GRANGER_FP      =FACT(statut='f',
             J1              =SIMP(statut='f',typ='R'),
             J2              =SIMP(statut='f',typ='R'),
             J3              =SIMP(statut='f',typ='R'),
             J4              =SIMP(statut='f',typ='R'),
             J5              =SIMP(statut='f',typ='R'),
             J6              =SIMP(statut='f',typ='R'),
             J7              =SIMP(statut='f',typ='R'),
             J8              =SIMP(statut='f',typ='R'),
             TAUX_1          =SIMP(statut='f',typ='R'),
             TAUX_2          =SIMP(statut='f',typ='R'),
             TAUX_3          =SIMP(statut='f',typ='R'),
             TAUX_4          =SIMP(statut='f',typ='R'),
             TAUX_5          =SIMP(statut='f',typ='R'),
             TAUX_6          =SIMP(statut='f',typ='R'),
             TAUX_7          =SIMP(statut='f',typ='R'),
             TAUX_8          =SIMP(statut='f',typ='R'),
             QSR_K           =SIMP(statut='f',typ='R'),
           ),
           GRANGER_FP_INDT =FACT(statut='f',
             J1              =SIMP(statut='f',typ='R'),
             J2              =SIMP(statut='f',typ='R'),
             J3              =SIMP(statut='f',typ='R'),
             J4              =SIMP(statut='f',typ='R'),
             J5              =SIMP(statut='f',typ='R'),
             J6              =SIMP(statut='f',typ='R'),
             J7              =SIMP(statut='f',typ='R'),
             J8              =SIMP(statut='f',typ='R'),
             TAUX_1          =SIMP(statut='f',typ='R'),
             TAUX_2          =SIMP(statut='f',typ='R'),
             TAUX_3          =SIMP(statut='f',typ='R'),
             TAUX_4          =SIMP(statut='f',typ='R'),
             TAUX_5          =SIMP(statut='f',typ='R'),
             TAUX_6          =SIMP(statut='f',typ='R'),
             TAUX_7          =SIMP(statut='f',typ='R'),
             TAUX_8          =SIMP(statut='f',typ='R'),
           ),
           V_GRANGER_FP    =FACT(statut='f',
             QSR_VEIL        =SIMP(statut='f',typ='R'),
             FONC_V          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           BETON_BURGER_FP   =FACT(statut='f',min=0 ,
             K_RS            =SIMP(statut='o',typ='R'),
             ETA_RS          =SIMP(statut='o',typ='R'),
             KAPPA           =SIMP(statut='o',typ='R'),
             ETA_IS          =SIMP(statut='o',typ='R'),
             K_RD            =SIMP(statut='o',typ='R'),
             ETA_RD          =SIMP(statut='o',typ='R'),
             ETA_ID          =SIMP(statut='o',typ='R'),
             ETA_FD          =SIMP(statut='f',typ='R'),
           ),
           BETON_UMLV_FP   =FACT(statut='f',min=0 ,
             K_RS            =SIMP(statut='o',typ='R'),
             ETA_RS          =SIMP(statut='o',typ='R'),
             K_IS            =SIMP(statut='o',typ='R'),
             ETA_IS          =SIMP(statut='o',typ='R'),
             K_RD            =SIMP(statut='o',typ='R'),
             ETA_RD          =SIMP(statut='o',typ='R'),
             ETA_ID          =SIMP(statut='o',typ='R'),
             ETA_FD          =SIMP(statut='f',typ='R'),
           ),
           BETON_RAG    =FACT(statut='f',
             ACTIV_FL        =SIMP(statut='f',typ='R',defaut=1.0 ),
             K_RS            =SIMP(statut='o',typ='R'),
             K_IS            =SIMP(statut='o',typ='R'),
             ETA_RS          =SIMP(statut='o',typ='R'),
             ETA_IS          =SIMP(statut='o',typ='R'),
             K_RD            =SIMP(statut='o',typ='R'),
             K_ID            =SIMP(statut='o',typ='R'),
             ETA_RD          =SIMP(statut='o',typ='R'),
             ETA_ID          =SIMP(statut='o',typ='R'),
             EPS_0           =SIMP(statut='o',typ='R'),
             TAU_0           =SIMP(statut='o',typ='R'),
             EPS_FL_L        =SIMP(statut='f',typ='R',defaut=3.0e-2 ),
             ACTIV_LO        =SIMP(statut='f',typ='R',defaut=1.0 ),
             F_C             =SIMP(statut='o',typ='R'),
             F_T             =SIMP(statut='o',typ='R'),
             ANG_CRIT        =SIMP(statut='f',typ='R',defaut=8.594367 ),
             EPS_COMP        =SIMP(statut='o',typ='R'),
             EPS_TRAC        =SIMP(statut='o',typ='R'),
             LC_COMP         =SIMP(statut='o',typ='R',defaut=1.0  ),
             LC_TRAC         =SIMP(statut='o',typ='R',defaut=1.0  ),
             HYD_PRES        =SIMP(statut='f',typ='R',defaut=0.   ),
             A_VAN_GE        =SIMP(statut='f',typ='R',defaut=0.0  ),
             B_VAN_GE        =SIMP(statut='f',typ='R',defaut=1.9  ),
             BIOT_EAU        =SIMP(statut='o',typ='R',defaut=0.3  ),
             MODU_EAU        =SIMP(statut='o',typ='R',defaut=0.0  ),
             W_EAU_0         =SIMP(statut='o',typ='R'),
             BIOT_GEL        =SIMP(statut='o',typ='R'),
             MODU_GEL        =SIMP(statut='o',typ='R'),
             VOL_GEL         =SIMP(statut='o',typ='R'),
             AVANC_LI        =SIMP(statut='o',typ='R'),
             SEUIL_SR        =SIMP(statut='o',typ='R'),
             PARA_CIN        =SIMP(statut='o',typ='R'),
             ENR_AC_G        =SIMP(statut='o',typ='R'),
           ),
           GLRC_DM         =FACT(statut='f',max=1,
             GAMMA_T         =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
             GAMMA_C         =SIMP(statut='f',typ='R',val_min=-1.E+0,val_max=1.E+0),
             GAMMA_F         =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=1.E+0),
             NYT             =SIMP(statut='o',typ='R',val_min=0.E+0),
             NYC             =SIMP(statut='f',typ='R'),
             MYF             =SIMP(statut='o',typ='R',val_min=0.E+0),
             ALPHA_C         =SIMP(statut='d',typ='R',val_min=1.E+0,defaut=1.E+0),
           ),
           DHRC_SEUILS         =FACT(statut='f',
             SYD           =SIMP(statut='o',typ='R',),
             SCRIT         =SIMP(statut='o',typ='R',),
             K0MICR        =SIMP(statut='o',typ='R',),
             A011          =SIMP(statut='o',typ='R',),
             A012          =SIMP(statut='o',typ='R',),
             A013          =SIMP(statut='o',typ='R',),
             A014          =SIMP(statut='o',typ='R',),
             A015          =SIMP(statut='o',typ='R',),
             A016          =SIMP(statut='o',typ='R',),
             A022          =SIMP(statut='o',typ='R',),
             A023          =SIMP(statut='o',typ='R',),
             A024          =SIMP(statut='o',typ='R',),
             A025          =SIMP(statut='o',typ='R',),
             A026          =SIMP(statut='o',typ='R',),
             A033          =SIMP(statut='o',typ='R',),
             A034          =SIMP(statut='o',typ='R',),
             A035          =SIMP(statut='o',typ='R',),
             A036          =SIMP(statut='o',typ='R',),
             A044          =SIMP(statut='o',typ='R',),
             A045          =SIMP(statut='o',typ='R',),
             A046          =SIMP(statut='o',typ='R',),
             A055          =SIMP(statut='o',typ='R',),
             A056          =SIMP(statut='o',typ='R',),
             A066          =SIMP(statut='o',typ='R',),
           ),
           DHRC            =FACT(statut='f',
             AAC111        =SIMP(statut='o',typ='R',),
             AAC121        =SIMP(statut='o',typ='R',),
             AAC131        =SIMP(statut='o',typ='R',),
             AAC141        =SIMP(statut='o',typ='R',),
             AAC151        =SIMP(statut='o',typ='R',),
             AAC161        =SIMP(statut='o',typ='R',),
             AAC221        =SIMP(statut='o',typ='R',),
             AAC231        =SIMP(statut='o',typ='R',),
             AAC241        =SIMP(statut='o',typ='R',),
             AAC251        =SIMP(statut='o',typ='R',),
             AAC261        =SIMP(statut='o',typ='R',),
             AAC331        =SIMP(statut='o',typ='R',),
             AAC341        =SIMP(statut='o',typ='R',),
             AAC351        =SIMP(statut='o',typ='R',),
             AAC361        =SIMP(statut='o',typ='R',),
             AAC441        =SIMP(statut='o',typ='R',),
             AAC451        =SIMP(statut='o',typ='R',),
             AAC461        =SIMP(statut='o',typ='R',),
             AAC551        =SIMP(statut='o',typ='R',),
             AAC561        =SIMP(statut='o',typ='R',),
             AAC661        =SIMP(statut='o',typ='R',),
             AAC112        =SIMP(statut='o',typ='R',),
             AAC122        =SIMP(statut='o',typ='R',),
             AAC132        =SIMP(statut='o',typ='R',),
             AAC142        =SIMP(statut='o',typ='R',),
             AAC152        =SIMP(statut='o',typ='R',),
             AAC162        =SIMP(statut='o',typ='R',),
             AAC222        =SIMP(statut='o',typ='R',),
             AAC232        =SIMP(statut='o',typ='R',),
             AAC242        =SIMP(statut='o',typ='R',),
             AAC252        =SIMP(statut='o',typ='R',),
             AAC262        =SIMP(statut='o',typ='R',),
             AAC332        =SIMP(statut='o',typ='R',),
             AAC342        =SIMP(statut='o',typ='R',),
             AAC352        =SIMP(statut='o',typ='R',),
             AAC362        =SIMP(statut='o',typ='R',),
             AAC442        =SIMP(statut='o',typ='R',),
             AAC452        =SIMP(statut='o',typ='R',),
             AAC462        =SIMP(statut='o',typ='R',),
             AAC552        =SIMP(statut='o',typ='R',),
             AAC562        =SIMP(statut='o',typ='R',),
             AAC662        =SIMP(statut='o',typ='R',),
             AAT111        =SIMP(statut='o',typ='R',),
             AAT121        =SIMP(statut='o',typ='R',),
             AAT131        =SIMP(statut='o',typ='R',),
             AAT141        =SIMP(statut='o',typ='R',),
             AAT151        =SIMP(statut='o',typ='R',),
             AAT161        =SIMP(statut='o',typ='R',),
             AAT221        =SIMP(statut='o',typ='R',),
             AAT231        =SIMP(statut='o',typ='R',),
             AAT241        =SIMP(statut='o',typ='R',),
             AAT251        =SIMP(statut='o',typ='R',),
             AAT261        =SIMP(statut='o',typ='R',),
             AAT331        =SIMP(statut='o',typ='R',),
             AAT341        =SIMP(statut='o',typ='R',),
             AAT351        =SIMP(statut='o',typ='R',),
             AAT361        =SIMP(statut='o',typ='R',),
             AAT441        =SIMP(statut='o',typ='R',),
             AAT451        =SIMP(statut='o',typ='R',),
             AAT461        =SIMP(statut='o',typ='R',),
             AAT551        =SIMP(statut='o',typ='R',),
             AAT561        =SIMP(statut='o',typ='R',),
             AAT661        =SIMP(statut='o',typ='R',),
             AAT112        =SIMP(statut='o',typ='R',),
             AAT122        =SIMP(statut='o',typ='R',),
             AAT132        =SIMP(statut='o',typ='R',),
             AAT142        =SIMP(statut='o',typ='R',),
             AAT152        =SIMP(statut='o',typ='R',),
             AAT162        =SIMP(statut='o',typ='R',),
             AAT222        =SIMP(statut='o',typ='R',),
             AAT232        =SIMP(statut='o',typ='R',),
             AAT242        =SIMP(statut='o',typ='R',),
             AAT252        =SIMP(statut='o',typ='R',),
             AAT262        =SIMP(statut='o',typ='R',),
             AAT332        =SIMP(statut='o',typ='R',),
             AAT342        =SIMP(statut='o',typ='R',),
             AAT352        =SIMP(statut='o',typ='R',),
             AAT362        =SIMP(statut='o',typ='R',),
             AAT442        =SIMP(statut='o',typ='R',),
             AAT452        =SIMP(statut='o',typ='R',),
             AAT462        =SIMP(statut='o',typ='R',),
             AAT552        =SIMP(statut='o',typ='R',),
             AAT562        =SIMP(statut='o',typ='R',),
             AAT662        =SIMP(statut='o',typ='R',),
             GAC111        =SIMP(statut='o',typ='R',),
             GAC121        =SIMP(statut='o',typ='R',),
             GAC131        =SIMP(statut='o',typ='R',),
             GAC141        =SIMP(statut='o',typ='R',),
             GAC151        =SIMP(statut='o',typ='R',),
             GAC161        =SIMP(statut='o',typ='R',),
             GAC221        =SIMP(statut='o',typ='R',),
             GAC231        =SIMP(statut='o',typ='R',),
             GAC241        =SIMP(statut='o',typ='R',),
             GAC251        =SIMP(statut='o',typ='R',),
             GAC261        =SIMP(statut='o',typ='R',),
             GAC331        =SIMP(statut='o',typ='R',),
             GAC341        =SIMP(statut='o',typ='R',),
             GAC351        =SIMP(statut='o',typ='R',),
             GAC361        =SIMP(statut='o',typ='R',),
             GAC441        =SIMP(statut='o',typ='R',),
             GAC451        =SIMP(statut='o',typ='R',),
             GAC461        =SIMP(statut='o',typ='R',),
             GAC551        =SIMP(statut='o',typ='R',),
             GAC561        =SIMP(statut='o',typ='R',),
             GAC661        =SIMP(statut='o',typ='R',),
             GAC112        =SIMP(statut='o',typ='R',),
             GAC122        =SIMP(statut='o',typ='R',),
             GAC132        =SIMP(statut='o',typ='R',),
             GAC142        =SIMP(statut='o',typ='R',),
             GAC152        =SIMP(statut='o',typ='R',),
             GAC162        =SIMP(statut='o',typ='R',),
             GAC222        =SIMP(statut='o',typ='R',),
             GAC232        =SIMP(statut='o',typ='R',),
             GAC242        =SIMP(statut='o',typ='R',),
             GAC252        =SIMP(statut='o',typ='R',),
             GAC262        =SIMP(statut='o',typ='R',),
             GAC332        =SIMP(statut='o',typ='R',),
             GAC342        =SIMP(statut='o',typ='R',),
             GAC352        =SIMP(statut='o',typ='R',),
             GAC362        =SIMP(statut='o',typ='R',),
             GAC442        =SIMP(statut='o',typ='R',),
             GAC452        =SIMP(statut='o',typ='R',),
             GAC462        =SIMP(statut='o',typ='R',),
             GAC552        =SIMP(statut='o',typ='R',),
             GAC562        =SIMP(statut='o',typ='R',),
             GAC662        =SIMP(statut='o',typ='R',),
             GAT111        =SIMP(statut='o',typ='R',),
             GAT121        =SIMP(statut='o',typ='R',),
             GAT131        =SIMP(statut='o',typ='R',),
             GAT141        =SIMP(statut='o',typ='R',),
             GAT151        =SIMP(statut='o',typ='R',),
             GAT161        =SIMP(statut='o',typ='R',),
             GAT221        =SIMP(statut='o',typ='R',),
             GAT231        =SIMP(statut='o',typ='R',),
             GAT241        =SIMP(statut='o',typ='R',),
             GAT251        =SIMP(statut='o',typ='R',),
             GAT261        =SIMP(statut='o',typ='R',),
             GAT331        =SIMP(statut='o',typ='R',),
             GAT341        =SIMP(statut='o',typ='R',),
             GAT351        =SIMP(statut='o',typ='R',),
             GAT361        =SIMP(statut='o',typ='R',),
             GAT441        =SIMP(statut='o',typ='R',),
             GAT451        =SIMP(statut='o',typ='R',),
             GAT461        =SIMP(statut='o',typ='R',),
             GAT551        =SIMP(statut='o',typ='R',),
             GAT561        =SIMP(statut='o',typ='R',),
             GAT661        =SIMP(statut='o',typ='R',),
             GAT112        =SIMP(statut='o',typ='R',),
             GAT122        =SIMP(statut='o',typ='R',),
             GAT132        =SIMP(statut='o',typ='R',),
             GAT142        =SIMP(statut='o',typ='R',),
             GAT152        =SIMP(statut='o',typ='R',),
             GAT162        =SIMP(statut='o',typ='R',),
             GAT222        =SIMP(statut='o',typ='R',),
             GAT232        =SIMP(statut='o',typ='R',),
             GAT242        =SIMP(statut='o',typ='R',),
             GAT252        =SIMP(statut='o',typ='R',),
             GAT262        =SIMP(statut='o',typ='R',),
             GAT332        =SIMP(statut='o',typ='R',),
             GAT342        =SIMP(statut='o',typ='R',),
             GAT352        =SIMP(statut='o',typ='R',),
             GAT362        =SIMP(statut='o',typ='R',),
             GAT442        =SIMP(statut='o',typ='R',),
             GAT452        =SIMP(statut='o',typ='R',),
             GAT462        =SIMP(statut='o',typ='R',),
             GAT552        =SIMP(statut='o',typ='R',),
             GAT562        =SIMP(statut='o',typ='R',),
             GAT662        =SIMP(statut='o',typ='R',),
             AB111         =SIMP(statut='o',typ='R',),
             AB121         =SIMP(statut='o',typ='R',),
             AB211         =SIMP(statut='o',typ='R',),
             AB221         =SIMP(statut='o',typ='R',),
             AB311         =SIMP(statut='o',typ='R',),
             AB321         =SIMP(statut='o',typ='R',),
             AB411         =SIMP(statut='o',typ='R',),
             AB421         =SIMP(statut='o',typ='R',),
             AB511         =SIMP(statut='o',typ='R',),
             AB521         =SIMP(statut='o',typ='R',),
             AB611         =SIMP(statut='o',typ='R',),
             AB621         =SIMP(statut='o',typ='R',),
             AB112         =SIMP(statut='o',typ='R',),
             AB122         =SIMP(statut='o',typ='R',),
             AB212         =SIMP(statut='o',typ='R',),
             AB222         =SIMP(statut='o',typ='R',),
             AB312         =SIMP(statut='o',typ='R',),
             AB322         =SIMP(statut='o',typ='R',),
             AB412         =SIMP(statut='o',typ='R',),
             AB422         =SIMP(statut='o',typ='R',),
             AB512         =SIMP(statut='o',typ='R',),
             AB522         =SIMP(statut='o',typ='R',),
             AB612         =SIMP(statut='o',typ='R',),
             AB622         =SIMP(statut='o',typ='R',),
             GB111         =SIMP(statut='o',typ='R',),
             GB121         =SIMP(statut='o',typ='R',),
             GB211         =SIMP(statut='o',typ='R',),
             GB221         =SIMP(statut='o',typ='R',),
             GB311         =SIMP(statut='o',typ='R',),
             GB321         =SIMP(statut='o',typ='R',),
             GB411         =SIMP(statut='o',typ='R',),
             GB421         =SIMP(statut='o',typ='R',),
             GB511         =SIMP(statut='o',typ='R',),
             GB521         =SIMP(statut='o',typ='R',),
             GB611         =SIMP(statut='o',typ='R',),
             GB621         =SIMP(statut='o',typ='R',),
             GB112         =SIMP(statut='o',typ='R',),
             GB122         =SIMP(statut='o',typ='R',),
             GB212         =SIMP(statut='o',typ='R',),
             GB222         =SIMP(statut='o',typ='R',),
             GB312         =SIMP(statut='o',typ='R',),
             GB322         =SIMP(statut='o',typ='R',),
             GB412         =SIMP(statut='o',typ='R',),
             GB422         =SIMP(statut='o',typ='R',),
             GB512         =SIMP(statut='o',typ='R',),
             GB522         =SIMP(statut='o',typ='R',),
             GB612         =SIMP(statut='o',typ='R',),
             GB622         =SIMP(statut='o',typ='R',),
             C0111         =SIMP(statut='o',typ='R',),
             C0211         =SIMP(statut='o',typ='R',),
             C0121         =SIMP(statut='o',typ='R',),
             C0221         =SIMP(statut='o',typ='R',),
             C0212         =SIMP(statut='o',typ='R',),
             C0112         =SIMP(statut='o',typ='R',),
             C0122         =SIMP(statut='o',typ='R',),
             C0222         =SIMP(statut='o',typ='R',),
             AC111         =SIMP(statut='o',typ='R',),
             AC211         =SIMP(statut='o',typ='R',),
             AC121         =SIMP(statut='o',typ='R',),
             AC221         =SIMP(statut='o',typ='R',),
             AC112         =SIMP(statut='o',typ='R',),
             AC212         =SIMP(statut='o',typ='R',),
             AC122         =SIMP(statut='o',typ='R',),
             AC222         =SIMP(statut='o',typ='R',),
             GC111         =SIMP(statut='o',typ='R',),
             GC211         =SIMP(statut='o',typ='R',),
             GC121         =SIMP(statut='o',typ='R',),
             GC221         =SIMP(statut='o',typ='R',),
             GC112         =SIMP(statut='o',typ='R',),
             GC212         =SIMP(statut='o',typ='R',),
             GC122         =SIMP(statut='o',typ='R',),
             GC222         =SIMP(statut='o',typ='R',),
           ),
           GATT_MONERIE    =FACT(statut='f',min=0,max=1,
             D_GRAIN         =SIMP(statut='o',typ='R',val_min=0.E+0),
             PORO_INIT       =SIMP(statut='o',typ='R',val_min=0.E+0),
             EPSI_01         =SIMP(statut='o',typ='R',defaut= 2.7252E-10,val_min=0.E+0),
             EPSI_02         =SIMP(statut='o',typ='R',defaut= 9.1440E-41,val_min=0.E+0),
           ),
           CORR_ACIER   =FACT(statut='f',min=0 ,max=1,
             D_CORR           =SIMP(statut='o',typ='R'),
             ECRO_K           =SIMP(statut='o',typ='R'),
             ECRO_M           =SIMP(statut='o',typ='R'),
             SY              =SIMP(statut='o',typ='R'),
             ),
           CABLE_GAINE_FROT=FACT(statut='f',min=0 ,max=1,
             TYPE = SIMP(statut='o',typ='TXM',into=("FROTTANT","GLISSANT","ADHERENT")),
             b_glissant =BLOC(condition="TYPE=='GLISSANT'",
                                    fr="Loi cable gaine glissante",
                     FROT_LINE         =SIMP(statut='c',typ='R',defaut= 0.0,),
                     FROT_COURB       =SIMP(statut='c',typ='R',defaut= 0.0,),
             ),
             b_adherent =BLOC(condition="TYPE=='ADHERENT'",
                                    fr="Loi cable gaine adherent",
                     FROT_LINE         =SIMP(statut='c',typ='R',defaut= -1.0,),
                     FROT_COURB       =SIMP(statut='c',typ='R',defaut= 0.0,),
             ),
             b_frottant =BLOC(condition="TYPE=='FROTTANT'",
                                    fr="Loi cable gaine frottant",
                     FROT_LINE         =SIMP(statut='o',typ='R',defaut= 0.0,),
                     FROT_COURB       =SIMP(statut='o',typ='R',defaut= 0.0,),
             ),
             PENA_LAGR       =SIMP(statut='o',typ='R',val_min=0.E+0),
             ),

# Discrets non-linéaires : début
         DIS_ECRO_CINE  =FACT(statut='f',
            fr="Loi pour les discrets avec écrouissage cinématique.",
            regles=(PRESENT_PRESENT('LIMY_DX','KCIN_DX',),PRESENT_PRESENT('PUIS_DX','LIMU_DX',),
                    PRESENT_PRESENT('LIMY_DY','KCIN_DY',),PRESENT_PRESENT('PUIS_DY','LIMU_DY',),
                    PRESENT_PRESENT('LIMY_DZ','KCIN_DZ',),PRESENT_PRESENT('PUIS_DZ','LIMU_DZ',),
                    PRESENT_PRESENT('LIMY_RX','KCIN_RX',),PRESENT_PRESENT('PUIS_RX','LIMU_RX',),
                    PRESENT_PRESENT('LIMY_RY','KCIN_RY',),PRESENT_PRESENT('PUIS_RY','LIMU_RY',),
                    PRESENT_PRESENT('LIMY_RZ','KCIN_RZ',),PRESENT_PRESENT('PUIS_RZ','LIMU_RZ',),),
            LIMY_DX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite élastique suivant l'axe local x de l'élément."),
            LIMY_DY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite élastique suivant l'axe local y de l'élément."),
            LIMY_DZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite élastique suivant l'axe local z de l'élément."),
            LIMY_RX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite élastique suivant l'axe local x de l'élément."),
            LIMY_RY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite élastique suivant l'axe local y de l'élément."),
            LIMY_RZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite élastique suivant l'axe local z de l'élément."),
            KCIN_DX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local x de l'élément."),
            KCIN_DY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local y de l'élément."),
            KCIN_DZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local z de l'élément."),
            KCIN_RX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local Rx de l'élément."),
            KCIN_RY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local Ry de l'élément."),
            KCIN_RZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur suivant l'axe local Rz de l'élément."),
            LIMU_DX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite suivant l'axe local x de l'élément."),
            LIMU_DY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite suivant l'axe local y de l'élément."),
            LIMU_DZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Effort limite suivant l'axe local z de l'élément."),
            LIMU_RX =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite suivant l'axe local x de l'élément."),
            LIMU_RY =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite suivant l'axe local y de l'élément."),
            LIMU_RZ =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Moment limite suivant l'axe local z de l'élément."),
            PUIS_DX =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local x de l'élément."),
            PUIS_DY =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local y de l'élément."),
            PUIS_DZ =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local z de l'élément."),
            PUIS_RX =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local Rx de l'élément."),
            PUIS_RY =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local Ry de l'élément."),
            PUIS_RZ =SIMP(statut='f',typ='R',val_min = 1.0,
               fr="Coefficient de non-linéarité suivant l'axe local Rz de l'élément."),
         ),
         DIS_VISC =FACT(statut='f',
            fr="Loi pour un discret de type visqueux : Zener Généralisé.",
            regles=(UN_PARMI('K1','UNSUR_K1'),
                    UN_PARMI('K2','UNSUR_K2'),
                    UN_PARMI('K3','UNSUR_K3'), ),
            K1          =SIMP(statut='f',typ='R',val_min = 1.0E-08,
               fr="Raideur en série avec les 2 autres branches."),
            K2          =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Raideur en parallèle de la branche visqueuse."),
            K3          =SIMP(statut='f',typ='R',val_min = 1.0E-08,
               fr="Raideur dans la branche visqueuse."),
            UNSUR_K1    =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Souplesse en série avec les 2 autres branches."),
            UNSUR_K2    =SIMP(statut='f',typ='R',val_min = 1.0E-08,
               fr="Souplesse en parallèle de la branche visqueuse."),
            UNSUR_K3    =SIMP(statut='f',typ='R',val_min = 0.0,
               fr="Souplesse dans la branche visqueuse."),
            C           =SIMP(statut='o',typ='R',val_min = 1.0E-08,
               fr="'Raideur' de la partie visqueuse."),
            PUIS_ALPHA  =SIMP(statut='o',typ='R',val_min = 1.0E-08, val_max=1.0, defaut=0.5,
               fr="Puissance de la loi visqueuse ]0.0, 1.0] ."),
         ),
         DIS_BILI_ELAS  =FACT(statut='f',
            fr="Loi bi-linéaire pour les discrets.",
            regles=(PRESENT_PRESENT('KDEB_DX','KFIN_DX','FPRE_DX',),
                    PRESENT_PRESENT('KDEB_DY','KFIN_DY','FPRE_DY',),
                    PRESENT_PRESENT('KDEB_DZ','KFIN_DZ','FPRE_DZ',),),
            KDEB_DX =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur début suivant l'axe local x de l'élément."),
            KDEB_DY =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur début suivant l'axe local y de l'élément."),
            KDEB_DZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur début  suivant l'axe local z de l'élément."),
            KFIN_DX =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur fin l'axe local x de l'élément."),
            KFIN_DY =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur fin l'axe local y de l'élément."),
            KFIN_DZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
               fr="Raideur fin l'axe local z de l'élément."),
            FPRE_DX =SIMP(statut='f',typ='R',
               fr="Effort de préserrage suivant l'axe local x de l'élément."),
            FPRE_DY =SIMP(statut='f',typ='R',
               fr="Effort de préserrage suivant l'axe local y de l'élément."),
            FPRE_DZ =SIMP(statut='f',typ='R',
               fr="Effort de préserrage suivant l'axe local z de l'élément."),
         ),
# Discrets non-linéaires : fin
#
# comportement thermique
#
           THER_NL         =FACT(statut='f',
             regles=(UN_PARMI('BETA','RHO_CP', ),),
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_CP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           THER_HYDR       =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AFFINITE        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CHALHYDR        =SIMP(statut='o',typ='R'),
           ),
           THER            =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ='R'),
             RHO_CP          =SIMP(statut='f',typ='R'),
           ),
           THER_FO         =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_CP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           THER_ORTH       =FACT(statut='f',
             LAMBDA_L        =SIMP(statut='o',typ='R'),
             LAMBDA_T        =SIMP(statut='o',typ='R'),
             LAMBDA_N        =SIMP(statut='f',typ='R'),
             RHO_CP          =SIMP(statut='f',typ='R'),
           ),
           THER_COQUE      =FACT(statut='f',
             COND_LMM        =SIMP(statut='o',typ='R'),
             COND_TMM        =SIMP(statut='o',typ='R'),
             COND_LMP        =SIMP(statut='o',typ='R'),
             COND_TMP        =SIMP(statut='o',typ='R'),
             COND_LPP        =SIMP(statut='o',typ='R'),
             COND_TPP        =SIMP(statut='o',typ='R'),
             COND_LSI        =SIMP(statut='o',typ='R'),
             COND_TSI        =SIMP(statut='o',typ='R'),
             COND_NMM        =SIMP(statut='o',typ='R'),
             COND_NMP        =SIMP(statut='o',typ='R'),
             COND_NPP        =SIMP(statut='o',typ='R'),
             COND_NSI        =SIMP(statut='o',typ='R'),
             CMAS_MM         =SIMP(statut='f',typ='R'),
             CMAS_MP         =SIMP(statut='f',typ='R'),
             CMAS_PP         =SIMP(statut='f',typ='R'),
             CMAS_SI         =SIMP(statut='f',typ='R'),
           ),
           THER_COQUE_FO   =FACT(statut='f',
             COND_LMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_MM         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_MP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_PP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_SI         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           SECH_GRANGER    =FACT(statut='f',
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             QSR_K           =SIMP(statut='o',typ='R'),
             TEMP_0_C        =SIMP(statut='o',typ='R'),
           ),
           SECH_MENSI      =FACT(statut='f',
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
           ),
           SECH_BAZANT     =FACT(statut='f',
             D1              =SIMP(statut='o',typ='R'),
             ALPHA_BAZANT    =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             FONC_DESORP     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           SECH_NAPPE      =FACT(statut='f',
             FONCTION        =SIMP(statut='o',typ=(nappe_sdaster,formule)),
           ),
#
# comportement métallurgique
#
           META_ACIER      =FACT(statut='f',
             TRC             =SIMP(statut='o',typ=(table_sdaster) ),
             AR3             =SIMP(statut='o',typ='R'),
             ALPHA           =SIMP(statut='o',typ='R'),
             MS0             =SIMP(statut='o',typ='R'),
             AC1             =SIMP(statut='o',typ='R'),
             AC3             =SIMP(statut='o',typ='R'),
             TAUX_1          =SIMP(statut='o',typ='R'),
             TAUX_3          =SIMP(statut='o',typ='R'),
             LAMBDA0         =SIMP(statut='f',typ='R'),
             QSR_K           =SIMP(statut='f',typ='R'),
             D10             =SIMP(statut='f',typ='R'),
             WSR_K           =SIMP(statut='f',typ='R'),
           ),
           META_ZIRC       =FACT(statut='f',
             TDEQ            =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             T1C             =SIMP(statut='o',typ='R'),
             T2C             =SIMP(statut='o',typ='R'),
             AC              =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             QSR_K           =SIMP(statut='o',typ='R'),
             T1R             =SIMP(statut='o',typ='R'),
             T2R             =SIMP(statut='o',typ='R'),
             AR              =SIMP(statut='o',typ='R'),
             BR              =SIMP(statut='o',typ='R'),
           ),
           DURT_META       =FACT(statut='f',
             F1_DURT         =SIMP(statut='o',typ='R'),
             F2_DURT         =SIMP(statut='o',typ='R'),
             F3_DURT         =SIMP(statut='o',typ='R'),
             F4_DURT         =SIMP(statut='o',typ='R'),
             C_DURT          =SIMP(statut='o',typ='R'),
           ),
           ELAS_META       =FACT(statut='f',
             E               =SIMP(statut='o',typ='R'),
             NU              =SIMP(statut='o',typ='R'),
             F_ALPHA         =SIMP(statut='o',typ='R'),
             C_ALPHA         =SIMP(statut='o',typ='R'),
             PHASE_REFE      =SIMP(statut='o',typ='TXM',into=("CHAUD","FROID")),
             EPSF_EPSC_TREF  =SIMP(statut='o',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             F1_SY           =SIMP(statut='f',typ='R'),
             F2_SY           =SIMP(statut='f',typ='R'),
             F3_SY           =SIMP(statut='f',typ='R'),
             F4_SY           =SIMP(statut='f',typ='R'),
             C_SY            =SIMP(statut='f',typ='R'),
             SY_MELANGE      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_S_VP         =SIMP(statut='f',typ='R'),
             F2_S_VP         =SIMP(statut='f',typ='R'),
             F3_S_VP         =SIMP(statut='f',typ='R'),
             F4_S_VP         =SIMP(statut='f',typ='R'),
             C_S_VP          =SIMP(statut='f',typ='R' ),
             S_VP_MELANGE    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_META_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('F_ALPHA','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('C_ALPHA','TEMP_DEF_ALPHA'),
                    ),
             E               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_ALPHA         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_ALPHA         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PHASE_REFE      =SIMP(statut='o',typ='TXM',into=("CHAUD","FROID")),
             EPSF_EPSC_TREF  =SIMP(statut='o',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             F1_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_SY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SY_MELANGE      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_S_VP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S_VP_MELANGE    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           META_ECRO_LINE  =FACT(statut='f',
             F1_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_D_SIGM_EPSI   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           META_TRACTION   =FACT(statut='f',
             SIGM_F1         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F2         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F3         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F4         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           META_VISC_FO    =FACT(statut='f',
             F1_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_ETA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_N             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_C             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_M             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           META_PT         =FACT(statut='f',
             F1_K            =SIMP(statut='f',typ='R'),
             F2_K            =SIMP(statut='f',typ='R'),
             F3_K            =SIMP(statut='f',typ='R'),
             F4_K            =SIMP(statut='f',typ='R'),
             F1_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           META_RE         =FACT(statut='f',
             C_F1_THETA      =SIMP(statut='f',typ='R'),
             C_F2_THETA      =SIMP(statut='f',typ='R'),
             C_F3_THETA      =SIMP(statut='f',typ='R'),
             C_F4_THETA      =SIMP(statut='f',typ='R'),
             F1_C_THETA      =SIMP(statut='f',typ='R'),
             F2_C_THETA      =SIMP(statut='f',typ='R'),
             F3_C_THETA      =SIMP(statut='f',typ='R'),
             F4_C_THETA      =SIMP(statut='f',typ='R'),
           ),
#
# comportement fluide
#
           FLUIDE          =FACT(statut='f',
             regles=(EXCLUS('CELE_C','CELE_R'),),
             RHO             =SIMP(statut='o',typ='R'),
             PESA_Z          =SIMP(statut='f',typ='R',min=1,max=1),
             CELE_C          =SIMP(statut='f',typ='C'),
             CELE_R          =SIMP(statut='f',typ='R'),
           ),
# =================================================================================
# COMPORTEMENT THERMO_HYDRO_MECANIQUE
# LES DONNEES NECESSAIRES A LA DEFINITION DU MATERIAU SONT DEPENDANTES
# DE LA LOI DE COUPLAGE THM DE LA RELATION
# LE COMPORTEMENT DE COUPLAGE COMP_THM N EST VALABLE QUE POUR LES LOIS
# DE COUPLAGE : LIQU_SATU,LIQU_GAZ,GAZ,LIQU_GAZ_ATM,LIQU_VAPE_GAZ,LIQU_VAPE
# ET LIQU_AD_GAZ_VAPE
# LA CORRESPONDANCE AVEC LES VARIABLES CACHEES EST LA SUIVANTE :
# 1 -->  LIQU_SATU
# 2 -->  GAZ
# 3 -->  LIQU_VAPE
# 4 -->  LIQU_VAPE_GAZ
# 5 -->  LIQU_GAZ
# 6 -->  LIQU_GAZ_ATM
# 9 -->  LIQU_AD_GAZ_VAPE
# 10 -->  LIQU_AD_GAZ
# =================================================================================
           COMP_THM        = SIMP(statut='f', typ='TXM',
                                  into = ( "LIQU_SATU"     ,
                                           "LIQU_GAZ"      ,
                                           "GAZ"           ,
                                           "LIQU_GAZ_ATM"  ,
                                           "LIQU_VAPE_GAZ" ,
                                           "LIQU_VAPE"     ,
                                           "LIQU_AD_GAZ_VAPE" ,
                                           "LIQU_AD_GAZ" ,
                                          ) ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_SATU -------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU -----------------------------------------------
# =================================================================================
           b_liqusatu      = BLOC(condition = "COMP_THM == 'LIQU_SATU' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_SATU",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1          = SIMP(statut='o',typ='R'),
                                           PORO          = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP          = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2          = SIMP(statut='f',typ='R'),
                                           PRES_VAPE     = SIMP(statut='f',typ='R'),
                                           DEGR_SATU     = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 1.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),

                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),


                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),


                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),

                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),

                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),

                                            ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO           = SIMP(statut='o',typ='R'),
                                           BIOT_COEF     = SIMP(statut='f',typ='R'),
                                           BIOT_L        = SIMP(statut='f',typ='R'),
                                           BIOT_N        = SIMP(statut='f',typ='R'),
                                           BIOT_T        = SIMP(statut='f',typ='R'),
                                           PESA_X        = SIMP(statut='o',typ='R'),
                                           PESA_Y        = SIMP(statut='o',typ='R'),
                                           PESA_Z        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ         = SIMP(statut='f',typ='R'),
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           SATU_PRES       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO           = SIMP(statut='o',typ='R'),
                                           UN_SUR_K      = SIMP(statut='o',typ='R'),
                                           VISC          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP   = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA         = SIMP(statut='f',typ='R'),
                                           CP            = SIMP(statut='f',typ='R'),
                                         ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_GAZ         =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_GAZ --------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ --------------------------------------
# =================================================================================
           b_liqugaz      = BLOC(condition = "COMP_THM == 'LIQU_GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 5.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),

                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
                                           ENSEMBLE('SATU_PRES','D_SATU_PRES','PERM_LIQU','D_PERM_LIQU_SATU',
                                                            'PERM_GAZ','D_PERM_SATU_GAZ','D_PERM_PRES_GAZ',),
                                           ENSEMBLE('VG_N','VG_SR','VG_PR','VG_SMAX','VG_SATUR',),
                                           UN_PARMI('VG_N','SATU_PRES'),
                                           ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---Van Genhuchten et Muallen-----------------------------------------------------------------------------

                                           VG_N    = SIMP(statut='f',typ='R'),
                                           VG_SR    = SIMP(statut='f',typ='R'),
                                           VG_PR   = SIMP(statut='f',typ='R'),
                                           VG_SMAX = SIMP(statut='f',typ='R'),
                                           VG_SATUR = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL        = SIMP(statut='o',typ='R'),
                                           VISC            = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP              = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE GAZ -------------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_GAZ ------------------------------------------------
# =================================================================================
           b_gaz          = BLOC(condition = "COMP_THM == 'GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='o',typ='R'),
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 2.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
                                            ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           SATU_PRES       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_LIQU        =FACT(statut='f',
             RHO             =SIMP(statut='f',typ='R'),
             UN_SUR_K        =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_HENRY      =SIMP(statut='f',typ='R'),
           ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_GAZ_ATM ----------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ --------------------------------------
# =================================================================================
           b_liqugazatm   = BLOC(condition = "COMP_THM == 'LIQU_GAZ_ATM' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_GAZ_ATM",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 6.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
                                            ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
             EMMAG           = SIMP(statut='f',typ='R'),
             R_GAZ           =SIMP(statut='f',typ='R'),
             PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='f',
                                           MASS_MOL         = SIMP(statut='f',typ='R'),
                                           VISC             = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
                                 ),

# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_AD_GAZ -------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ,  THM_AIR_DISSOUS---------
# =================================================================================
           b_liquadgaz  = BLOC(condition = "COMP_THM == 'LIQU_AD_GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_AD_GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 10.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
                                           ENSEMBLE('SATU_PRES','D_SATU_PRES','PERM_LIQU','D_PERM_LIQU_SATU',
                                                            'PERM_GAZ','D_PERM_SATU_GAZ','D_PERM_PRES_GAZ',),
                                           ENSEMBLE('VG_N','VG_SR','VG_PR','VG_SMAX','VG_SATUR',),
                                           UN_PARMI('VG_N','SATU_PRES'),
                                           ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---Van Genhuchten et Muallen-----------------------------------------------------------------------------
                                           VG_N     = SIMP(statut='f',typ='R'),
                                           VG_SR    = SIMP(statut='f',typ='R'),
                                           VG_PR    = SIMP(statut='f',typ='R'),
                                           VG_SMAX  = SIMP(statut='f',typ='R'),
                                           VG_SATUR = SIMP(statut='f',typ='R'),
#
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L     = SIMP(statut='f',typ='R'),
                                           LAMB_C_N     = SIMP(statut='f',typ='R'),
                                           LAMB_C_T     = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                             ),
# =================================================================================
# --- MOT-CLE FACULTATIF ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='f',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_AIR_DISS = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='o',typ='R'),
                                           COEF_HENRY       = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
                                 ),

# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_VAPE_GAZ ---------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ, THM_VAPE_GAZ ------------------------
# =================================================================================
           b_liquvapegaz  = BLOC(condition = "COMP_THM == 'LIQU_VAPE_GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_VAPE_GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 4.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---Van Genhuchten et Muallen-----------------------------------------------------------------------------

                                           VG_N     = SIMP(statut='f',typ='R'),
                                           VG_SR    = SIMP(statut='f',typ='R'),
                                           VG_PR    = SIMP(statut='f',typ='R'),
                                           VG_SMAX  = SIMP(statut='f',typ='R'),
                                           VG_SATUR = SIMP(statut='f',typ='R'),
#
                                           FICKV_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L     = SIMP(statut='f',typ='R'),
                                           LAMB_C_N     = SIMP(statut='f',typ='R'),
                                           LAMB_C_T     = SIMP(statut='f',typ='R'),
#
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),

                                            ENSEMBLE('SATU_PRES','D_SATU_PRES','PERM_LIQU','D_PERM_LIQU_SATU',
                                                            'PERM_GAZ','D_PERM_SATU_GAZ','D_PERM_PRES_GAZ',),
                                            ENSEMBLE('VG_N','VG_SR','VG_PR','VG_SMAX','VG_SATUR',),
                                            UN_PARMI('VG_N','SATU_PRES'),
                                           ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVE   ----------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_AD_GAZ_VAPE -------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ, THM_VAPE_GAZ THM_AIR_DISSOUS---------
# =================================================================================
           b_liquadvape  = BLOC(condition = "COMP_THM == 'LIQU_AD_GAZ_VAPE' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_AD_GAZ_VAPE",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 9.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---Van Genhuchten et Muallen-----------------------------------------------------------------------------
                                           VG_N     = SIMP(statut='f',typ='R'),
                                           VG_SR    = SIMP(statut='f',typ='R'),
                                           VG_PR    = SIMP(statut='f',typ='R'),
                                           VG_SMAX  = SIMP(statut='f',typ='R'),
                                           VG_SATUR = SIMP(statut='f',typ='R'),
#
                                           FICKV_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
#
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
         PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
         PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
         PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
         PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
         PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
         PRESENT_PRESENT('BIOT_L','PERMIN_L',),
         PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),
                                            ENSEMBLE('SATU_PRES','D_SATU_PRES','PERM_LIQU','D_PERM_LIQU_SATU',
                                                            'PERM_GAZ','D_PERM_SATU_GAZ','D_PERM_PRES_GAZ',),
                                            ENSEMBLE('VG_N','VG_SR','VG_PR','VG_SMAX','VG_SATUR',),
                                            UN_PARMI('VG_N','SATU_PRES'),
                                           ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_AIR_DISS = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='o',typ='R'),
                                           COEF_HENRY       = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_VAPE -------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_VAPE_GAZ ---------------------------------
# =================================================================================
           b_liquvape  = BLOC(condition = "COMP_THM == 'LIQU_VAPE' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_VAPE",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 3.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='f',typ='R'),
                                           BIOT_L           = SIMP(statut='f',typ='R'),
                                           BIOT_N           = SIMP(statut='f',typ='R'),
                                           BIOT_T           = SIMP(statut='f',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---Van Genhuchten et Muallen-----------------------------------------------------------------------------

                                           VG_N    = SIMP(statut='f',typ='R'),
                                           VG_SR    = SIMP(statut='f',typ='R'),
                                           VG_PR   = SIMP(statut='f',typ='R'),
                                           VG_SMAX = SIMP(statut='f',typ='R'),
                                           VG_SATUR = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           PESA_MULT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP          = SIMP(statut='f',typ='R'),
                                           PERM_IN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_L    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_N    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TL     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TN     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_TT     = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT     = SIMP(statut='f',typ='R'),
                                           LAMB_C_L   = SIMP(statut='f',typ='R'),
                                           LAMB_C_N   = SIMP(statut='f',typ='R'),
                                           LAMB_C_T   = SIMP(statut='f',typ='R'),
#
                                  regles = (EXCLUS('BIOT_COEF','BIOT_N',),
                                            PRESENT_PRESENT('BIOT_N','BIOT_L',),
                                            PRESENT_PRESENT('BIOT_T','BIOT_L','BIOT_N',),
                                            EXCLUS('PERM_IN','PERM_END','PERMIN_L',),
                                            PRESENT_ABSENT('PERMIN_N','PERMIN_T',),
                                            PRESENT_PRESENT('PERMIN_N','PERMIN_L',),
                                            PRESENT_PRESENT('PERMIN_T','PERMIN_L',),
                                            EXCLUS('LAMB_T','LAMB_TL',),
                                            PRESENT_ABSENT('LAMB_TN','LAMB_TT',),
                                            PRESENT_PRESENT('LAMB_TN','LAMB_TL',),
                                            PRESENT_PRESENT('LAMB_TT','LAMB_TL',),
                                            EXCLUS('D_LB_T','D_LB_TL',),
                                            PRESENT_ABSENT('D_LB_TN','D_LB_TT',),
                                            PRESENT_PRESENT('D_LB_TN','D_LB_TL',),
                                            PRESENT_PRESENT('D_LB_TT','D_LB_TL',),
                                            EXCLUS('LAMB_CT','LAMB_C_L',),
                                            PRESENT_ABSENT('LAMB_C_N','LAMB_C_T',),
                                            PRESENT_PRESENT('LAMB_C_N','LAMB_C_L',),
                                            PRESENT_PRESENT('LAMB_C_T','LAMB_C_L',),
                                            EXCLUS('PERMIN_L','BIOT_COEF'),
                                            EXCLUS('PERMIN_L','LAMB_T'),
                                            PRESENT_PRESENT('BIOT_L','PERMIN_L',),
                                            PRESENT_PRESENT('BIOT_T','PERMIN_T',),
                                            PRESENT_PRESENT('LAMB_TN','PERMIN_N',),
                                            PRESENT_PRESENT('LAMB_TL','PERMIN_L',),
                                            PRESENT_PRESENT('LAMB_TT','PERMIN_T',),

                                            ENSEMBLE('SATU_PRES','D_SATU_PRES','PERM_LIQU','D_PERM_LIQU_SATU',
                                                            'PERM_GAZ','D_PERM_SATU_GAZ','D_PERM_PRES_GAZ',),
                                            ENSEMBLE('VG_N','VG_SR','VG_PR','VG_SMAX','VG_SATUR',),
                                            UN_PARMI('VG_N','SATU_PRES'),
                                           ),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_GAZ         =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
                                 ),
# courbes et coefficients associés à la fatigue et au dommage
#
           FATIGUE         =FACT(statut='f',
             regles=(PRESENT_ABSENT('WOHLER','A_BASQUIN','BETA_BASQUIN'),
                     PRESENT_ABSENT('WOHLER','A0','A1','A2','A3','SL'),
                     PRESENT_ABSENT('A_BASQUIN','A0','A1','A2','A3','SL'),
                     ENSEMBLE('A_BASQUIN','BETA_BASQUIN'),
                     ENSEMBLE('A0','A1','A2','A3','SL'),
                     PRESENT_PRESENT('A0','E_REFE'),
                     ENSEMBLE('D0','TAU0'),),
             WOHLER          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_BASQUIN       =SIMP(statut='f',typ='R'),
             BETA_BASQUIN    =SIMP(statut='f',typ='R'),
             A0              =SIMP(statut='f',typ='R'),
             A1              =SIMP(statut='f',typ='R'),
             A2              =SIMP(statut='f',typ='R'),
             A3              =SIMP(statut='f',typ='R'),
             SL              =SIMP(statut='f',typ='R'),
             MANSOP_COFFIN   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_REFE          =SIMP(statut='f',typ='R'),
             D0              =SIMP(statut='f',typ='R'),
             TAU0            =SIMP(statut='f',typ='R'),
           ),
           DOMMA_LEMAITRE  =FACT(statut='f',
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             EPSP_SEUIL      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             EXP_S           =SIMP(statut='f',typ='R',val_min=0.0E0,defaut=1.0),
           ),
           CISA_PLAP_CRIT  =FACT(statut='f',
             CRITERE       =SIMP(statut='o',typ='TXM',into=("MATAKE_MODI_AC",
                                                            "DANG_VAN_MODI_AC",
                                                            "DANG_VAN_MODI_AV",
                                                            "MATAKE_MODI_AV",
                                                            "FATESOCI_MODI_AV",
                                                            ) ),

             b_critere_matake =BLOC(condition="CRITERE=='MATAKE_MODI_AC' or CRITERE=='MATAKE_MODI_AV'",
                         fr="Cisaillement plan critique critère de matake pour les cas amplitude constante et amplitude variable",
               MATAKE_A         =SIMP(statut='o',typ='R'),
               MATAKE_B         =SIMP(statut='o',typ='R'),
               COEF_FLEX_TORS   =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),

             b_critere_dang_van =BLOC(condition="(CRITERE=='DANG_VAN_MODI_AC' or CRITERE=='DANG_VAN_MODI_AV')",
                                 fr="Critère de Dang Van modifié pour les cas amplitude constante et amplitude variable",
               D_VAN_A            =SIMP(statut='o',typ='R'),
               D_VAN_B            =SIMP(statut='o',typ='R'),
               COEF_CISA_TRAC     =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),

             b_critere_fate_soci =BLOC(condition="CRITERE=='FATESOCI_MODI_AV'",
                               fr="Critère de Fatemi et Socie, en élasticité ou élastoplasticité, pour le cas amplitude variable",
               FATSOC_A           =SIMP(statut='o',typ='R'),
               COEF_CISA_TRAC     =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),
           ),


           THM_RUPT       =FACT(statut='f',
             OUV_FICT        =SIMP(statut='o',typ='R'),
             UN_SUR_N        =SIMP(statut='f',typ='R',defaut= 0.),
           ),
#
# autres comportements ...
#
           WEIBULL         =FACT(statut='f',
             M               =SIMP(statut='o',typ='R'),
             VOLU_REFE       =SIMP(statut='o',typ='R'),
             SIGM_REFE       =SIMP(statut='o',typ='R'),
             SEUIL_EPSP_CUMU =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ),
           WEIBULL_FO      =FACT(statut='f',
             M               =SIMP(statut='o',typ='R'),
             VOLU_REFE       =SIMP(statut='o',typ='R'),
             SIGM_CNV        =SIMP(statut='o',typ='R'),
             SIGM_REFE       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SEUIL_EPSP_CUMU =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ),
           NON_LOCAL       =FACT(statut='f',
             regles=(AU_MOINS_UN('LONG_CARA','C_GONF','C_GRAD_VARI','PENA_LAGR',),),
             LONG_CARA       =SIMP(statut='f',typ='R'),
             C_GRAD_VARI     =SIMP(statut='f',typ='R'),
             PENA_LAGR       =SIMP(statut='f',typ='R',defaut= 1.0E3),
             C_GONF          =SIMP(statut='f',typ='R'),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R'),
           ),
           RUPT_FRAG       =FACT(statut='f',
             GC              =SIMP(statut='o',typ='R'),
             SIGM_C          =SIMP(statut='f',typ='R'),
             PENA_ADHERENCE  =SIMP(statut='f',typ='R',val_min=1.E-12,val_max=1.E+0),
             PENA_CONTACT    =SIMP(statut='f',typ='R',defaut=1.),
             PENA_LAGR       =SIMP(statut='f',typ='R',defaut=1.0E2,val_min=1.01E+0),
             RIGI_GLIS       =SIMP(statut='f',typ='R',defaut=1.0E1),
             CINEMATIQUE     =SIMP(statut='f',typ='TXM',defaut="UNILATER",into=("UNILATER","GLIS_1D","GLIS_2D")),
           ),
           RUPT_FRAG_FO   =FACT(statut='f',
             GC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PENA_ADHERENCE  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PENA_CONTACT    =SIMP(statut='f',typ='R',defaut=1.),
             CINEMATIQUE     =SIMP(statut='f',typ='TXM',defaut="UNILATER",into=("UNILATER","GLIS_1D","GLIS_2D")),
           ),
           CZM_LAB_MIX    =FACT(statut='f',
             SIGM_C          =SIMP(statut='o',typ='R',              val_min=1.E-100),
             GLIS_C          =SIMP(statut='o',typ='R',              val_min=1.E-100),
             ALPHA           =SIMP(statut='f',typ='R',  defaut=0.5, val_min=1.E-3),
             BETA            =SIMP(statut='f',typ='R',  defaut=1.,  val_min=0.),
             PENA_LAGR       =SIMP(statut='f',typ='R',  defaut=100.,val_min=1.01E+0),
             CINEMATIQUE     =SIMP(statut='f',typ='TXM',defaut="GLIS_1D",into=("UNILATER","GLIS_1D","GLIS_2D")),
           ),
           RUPT_DUCT       =FACT(statut='f',
             GC              =SIMP(statut='o',typ='R'),
             SIGM_C          =SIMP(statut='o',typ='R'),
             COEF_EXTR       =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=9.99E-1),
             COEF_PLAS       =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=9.99E-1),
             PENA_LAGR       =SIMP(statut='f',typ='R',defaut=1.0E2,val_min=1.01E+0),
             RIGI_GLIS       =SIMP(statut='f',typ='R',defaut=1.0E1),
           ),
           JOINT_MECA_RUPT  =FACT(statut='f',
             regles=(EXCLUS('PRES_FLUIDE','PRES_CLAVAGE'),
                     EXCLUS('PRES_FLUIDE','SCIAGE'),
                     PRESENT_PRESENT('RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('PRES_FLUIDE','RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('PRES_CLAVAGE','RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('SCIAGE','RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('RHO_FLUIDE','PRES_FLUIDE','PRES_CLAVAGE','SCIAGE'),
                     PRESENT_ABSENT('VISC_FLUIDE','PRES_FLUIDE','PRES_CLAVAGE','SCIAGE'),
                     PRESENT_ABSENT('OUV_MIN','PRES_FLUIDE','PRES_CLAVAGE','SCIAGE'),
                     ),
             K_N             =SIMP(statut='o',typ='R',val_min=1.E-12),
             K_T             =SIMP(statut='f',typ='R',val_min=1.E-12),
             SIGM_MAX        =SIMP(statut='o',typ='R',val_min=0.),
             ALPHA           =SIMP(statut='f',typ='R',defaut=1., val_min=0., val_max=2.),
             PENA_RUPTURE    =SIMP(statut='f',typ='R',val_min=1.E-12,val_max=10.E+0),
             PENA_CONTACT    =SIMP(statut='f',typ='R',defaut=1.,val_min=1.E-12),
             PRES_FLUIDE     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PRES_CLAVAGE    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SCIAGE          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_FLUIDE      =SIMP(statut='f',typ='R',val_min=0.),
             VISC_FLUIDE     =SIMP(statut='f',typ='R',val_min=1.E-20),
             OUV_MIN         =SIMP(statut='f',typ='R',val_min=1.E-15),
           ),
           JOINT_MECA_FROT   =FACT(statut='f',
             regles=(
                     EXCLUS('PRES_FLUIDE','SCIAGE'),
                     PRESENT_PRESENT('RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('PRES_FLUIDE','RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('SCIAGE','RHO_FLUIDE','VISC_FLUIDE','OUV_MIN'),
                     PRESENT_ABSENT('RHO_FLUIDE','PRES_FLUIDE'),
                     PRESENT_ABSENT('VISC_FLUIDE','PRES_FLUIDE'),
                     PRESENT_ABSENT('OUV_MIN','PRES_FLUIDE'),
                     ),
             K_N             =SIMP(statut='o',typ='R',val_min=1.E-12),
             K_T             =SIMP(statut='f',typ='R',val_min=1.E-12),
             MU              =SIMP(statut='o',typ='R',val_min=1.E-3),
             PENA_TANG       =SIMP(statut='f',typ='R',val_min=0.),
             ADHESION        =SIMP(statut='f',typ='R',defaut=0., val_min=0.),
             PRES_FLUIDE     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SCIAGE          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_FLUIDE      =SIMP(statut='f',typ='R',val_min=0.),
             VISC_FLUIDE     =SIMP(statut='f',typ='R',val_min=1.E-20),
             OUV_MIN         =SIMP(statut='f',typ='R',val_min=1.E-15),
           ),
           RCCM            =FACT(statut='f',
             regles=(ENSEMBLE('A_AMORC','B_AMORC','D_AMORC','R_AMORC'),),
             SY_02           =SIMP(statut='f',typ='R'),
             SM              =SIMP(statut='f',typ='R'),
             SU              =SIMP(statut='f',typ='R'),
             SC              =SIMP(statut='f',typ='R'),
             SH              =SIMP(statut='f',typ='R'),
             N_KE            =SIMP(statut='f',typ='R'),
             M_KE            =SIMP(statut='f',typ='R'),
             A_AMORC         =SIMP(statut='f',typ='R'),
             B_AMORC         =SIMP(statut='f',typ='R'),
             D_AMORC         =SIMP(statut='f',typ='R'),
             R_AMORC         =SIMP(statut='f',typ='R'),
           ),
           RCCM_FO         =FACT(statut='f',
             regles=(ENSEMBLE('A_AMORC','B_AMORC','D_AMORC','R_AMORC'),),
             SY_02           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SM              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SU              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N_KE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_KE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_AMORC         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B_AMORC         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_AMORC         =SIMP(statut='f',typ='R'),
             R_AMORC         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           LAIGLE          =FACT(statut='f',
             GAMMA_ULT       =SIMP(statut='o',typ='R'),
             GAMMA_E         =SIMP(statut='o',typ='R'),
             M_ULT           =SIMP(statut='o',typ='R'),
             M_E             =SIMP(statut='o',typ='R'),
             A_E             =SIMP(statut='o',typ='R'),
             M_PIC           =SIMP(statut='o',typ='R'),
             A_PIC           =SIMP(statut='o',typ='R'),
             ETA             =SIMP(statut='o',typ='R'),
             SIGMA_C         =SIMP(statut='o',typ='R'),
             GAMMA           =SIMP(statut='o',typ='R'),
             KSI             =SIMP(statut='o',typ='R'),
             GAMMA_CJS       =SIMP(statut='o',typ='R'),
             SIGMA_P1        =SIMP(statut='o',typ='R'),
             PA              =SIMP(statut='o',typ='R'),
           ),
           LETK          =FACT(statut='f',
             PA         =SIMP(statut='o',typ='R',fr="pression atmospherique"),
             NELAS      =SIMP(statut='o',typ='R',fr="exposant de la loi de variation des modules K et G"),
             SIGMA_C    =SIMP(statut='o',typ='R',fr="résistance en compression simple "),
             H0_EXT     =SIMP(statut='o',typ='R',fr="parametre pilotant la résistance en extension"),
             GAMMA_CJS  =SIMP(statut='o',typ='R',fr="parametre de forme du critere ds le plan déviatoire entre 0 et 1."),
             XAMS       =SIMP(statut='o',typ='R',fr="parametre non nul intervenant dans les lois d'écrouissage pre pic"),
             ETA        =SIMP(statut='o',typ='R',fr="parametre non nul intervenant dans les lois d'écrouissage post pic"),
             A_0        =SIMP(statut='o',typ='R',fr="a de la limite d'élasticité initiale"),
             A_E        =SIMP(statut='o',typ='R',fr="a de la limite de clivage ou seuil intermédiaire"),
             A_PIC      =SIMP(statut='o',typ='R',fr="a du seuil de pic"),
             S_0        =SIMP(statut='o',typ='R',fr="s de la limite d'élasticité initiale"),
             M_0        =SIMP(statut='o',typ='R',fr="m de la limite d'élasticité initiale"),
             M_E        =SIMP(statut='o',typ='R',fr="m de la limite de clivage ou seuil intermédiaire"),
             M_PIC      =SIMP(statut='o',typ='R',fr="m du seuil de pic"),
             M_ULT      =SIMP(statut='o',typ='R',fr="m du seuil residuel"),
             XI_ULT     =SIMP(statut='o',typ='R',fr="niveau d écrouissage pour atteindre le seuil résiduel"),
             XI_E       =SIMP(statut='o',typ='R',fr="niveau d écrouissage pour atteindre le seuil de clivage"),
             XI_PIC     =SIMP(statut='o',typ='R',fr="niveau d écrouissage pour atteindre le seuil de pic"),
             MV_MAX     =SIMP(statut='o',typ='R',fr="m du seuil viscoplastique maximal"),
             XIV_MAX    =SIMP(statut='o',typ='R',fr="niveau d écrouissage pour atteindre le seuil viscoplastique maximal"),
             A          =SIMP(statut='o',typ='R',fr="parametre carcaterisant l amplitude de la vitesse de fluage"),
             N          =SIMP(statut='o',typ='R',fr="parametre intervenant dans la formule pilotant la cinetique de fluage"),
             SIGMA_P1   =SIMP(statut='o',typ='R',fr="SIG min de l intersection du seuil de pic et intermediaire "),
             MU0_V      =SIMP(statut='o',typ='R',fr="relatif à l angle de dilatance des mecanismes pre pic et viscoplastique"),
             XI0_V      =SIMP(statut='o',typ='R',fr="relatif à l angle de dilatance des mecanismes pre pic et viscoplastique"),
             MU1        =SIMP(statut='o',typ='R',fr="relatif à l angle de dilatance du mecanisme post pic "),
             XI1        =SIMP(statut='o',typ='R',fr="relatif à l angle de dilatance du mecanisme post pic "),
           ),
           DRUCK_PRAGER  =FACT(statut='f',
             ALPHA           =SIMP(statut='o',typ='R'),
             SY              =SIMP(statut='o',typ='R'),
             P_ULTM          =SIMP(statut='o',typ='R'),
             ECROUISSAGE = SIMP(statut='o',typ='TXM',into=("LINEAIRE","PARABOLIQUE")),
             b_lineaire =BLOC(condition="ECROUISSAGE=='LINEAIRE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage lineaire",
                    H               =SIMP(statut='o',typ='R'),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 1.0,),
             ),
             b_parabolique =BLOC(condition="ECROUISSAGE=='PARABOLIQUE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage parabolique",
                    SY_ULTM         =SIMP(statut='o',typ='R'),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 2.0,),
             ),
             DILAT           =SIMP(statut='f',typ='R',defaut=0.0),
           ),

           DRUCK_PRAGER_FO  =FACT(statut='f',
             ALPHA           =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             SY              =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             P_ULTM          =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             ECROUISSAGE = SIMP(statut='o',typ='TXM',into=("LINEAIRE","PARABOLIQUE")),
             b_lineaire =BLOC(condition="ECROUISSAGE=='LINEAIRE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage lineaire",
                    H               =SIMP(statut='o',typ=(fonction_sdaster,formule)),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 1.0,),
             ),
             b_parabolique =BLOC(condition="ECROUISSAGE=='PARABOLIQUE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage parabolique",
                    SY_ULTM         =SIMP(statut='o',typ=(fonction_sdaster,formule)),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 2.0,),
             ),
            DILAT           =SIMP(statut='f',typ='R',defaut=0.0),
           ),

           VISC_DRUC_PRAG          =FACT(statut='f',
             PREF       =SIMP(statut='o',typ='R',fr="pression de reference"),
             A          =SIMP(statut='o',typ='R',fr="parametre carcaterisant l amplitude de la vitesse de fluage"),
             N          =SIMP(statut='o',typ='R',fr="parametre intervenant dans la formule pilotant la cinetique de fluage"),
             P_PIC      =SIMP(statut='o',typ='R',fr="niveau d ecrouissage pour atteindre le seuil de pic"),
             P_ULT      =SIMP(statut='o',typ='R',fr="niveau d ecrouissage pour atteindre le seuil utime"),
             ALPHA_0    =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la cohesion au seuil d elasticite"),
             ALPHA_PIC  =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la cohesion au seuil de pic"),
             ALPHA_ULT  =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la cohesion au seuil ultime"),
             R_0        =SIMP(statut='o',typ='R',fr="parametre d ecrouissage correspondant au seuil d'elasticite"),
             R_PIC      =SIMP(statut='o',typ='R',fr="parametre d ecrouissage correspondant au seuil de pic"),
             R_ULT      =SIMP(statut='o',typ='R',fr="parametre d ecrouissage correspondant au seuil ultime"),
             BETA_0     =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la dilatance au seuil d elasticite"),
             BETA_PIC   =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la dilatance au seuil de pic"),
             BETA_ULT   =SIMP(statut='o',typ='R',fr="parametre d ecrouissage relatif à la dilatance au seuil ultime"),
           ),
             HOEK_BROWN          =FACT(statut='f',
             GAMMA_RUP       =SIMP(statut='o',typ='R'),
             GAMMA_RES       =SIMP(statut='o',typ='R'),
             S_END           =SIMP(statut='o',typ='R'),
             S_RUP           =SIMP(statut='o',typ='R'),
             M_END           =SIMP(statut='o',typ='R'),
             M_RUP           =SIMP(statut='o',typ='R'),
             BETA            =SIMP(statut='o',typ='R'),
             ALPHAHB         =SIMP(statut='o',typ='R'),
             PHI_RUP         =SIMP(statut='o',typ='R'),
             PHI_RES         =SIMP(statut='o',typ='R'),
             PHI_END         =SIMP(statut='f',typ='R'),
           ),
             ELAS_GONF             =FACT(statut='f',
             BETAM           =SIMP(statut='o',typ='R'),
             PREF            =SIMP(statut='o',typ='R'),
           ),
             JOINT_BANDIS         =FACT(statut='f',
             K                =SIMP(statut='o',typ='R'),
             DMAX             =SIMP(statut='o',typ='R'),
             GAMMA            =SIMP(statut='o',typ='R'),
             KT               =SIMP(statut='f',typ='R',defaut = 1.E12),
           ),
####  MONOCRISTAL

           MONO_VISC1      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
           ),
           MONO_VISC2      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
             D               =SIMP(statut='o',typ='R'),
             A               =SIMP(statut='o',typ='R'),
           ),
           MONO_ISOT1      =FACT(statut='f',
              regles=(UN_PARMI('H','H1'),
                      PRESENT_PRESENT('H1','H2','H3','H4'),
                      PRESENT_ABSENT('H','H1','H2','H3','H4','H5','H6'),
                      ),
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_ISOT",),),
             R_0             =SIMP(statut='o',typ='R'),
             Q               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R'),
             H2              =SIMP(statut='f',typ='R'),
             H3              =SIMP(statut='f',typ='R'),
             H4              =SIMP(statut='f',typ='R'),
             H5              =SIMP(statut='f',typ='R'),
             H6              =SIMP(statut='f',typ='R'),
           ),
           MONO_ISOT2      =FACT(statut='f',
              regles=(UN_PARMI('H','H1'),
                      PRESENT_PRESENT('H1','H2','H3','H4'),
                      PRESENT_ABSENT('H','H1','H2','H3','H4','H5','H6'),
                      ),
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_ISOT",),),
             R_0             =SIMP(statut='o',typ='R'),
             Q1              =SIMP(statut='o',typ='R'),
             B1              =SIMP(statut='o',typ='R'),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R'),
             H2              =SIMP(statut='f',typ='R'),
             H3              =SIMP(statut='f',typ='R'),
             H4              =SIMP(statut='f',typ='R'),
             H5              =SIMP(statut='f',typ='R'),
             H6              =SIMP(statut='f',typ='R'),
             Q2              =SIMP(statut='o',typ='R'),
             B2              =SIMP(statut='o',typ='R'),
           ),
           MONO_CINE1      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_CINE",),),
             D               =SIMP(statut='o',typ='R'),
           ),
           MONO_CINE2      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_CINE",),),
             D               =SIMP(statut='o',typ='R'),
             GM              =SIMP(statut='o',typ='R'),
             PM              =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
           ),
           MONO_DD_KR      =FACT(statut='f',
              regles=(UN_PARMI('H','H1'),
                      PRESENT_PRESENT('H1','H2','H3','H4'),
                      PRESENT_ABSENT('H','H1','H2','H3','H4','H5','H6'),
                      ),
            # TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             K               =SIMP(statut='o',typ='R',fr="Constante de Boltzmann, en eV/K"),
             TAUR            =SIMP(statut='o',typ='R',fr="Contraintes de cisaillement à T=0K, en unite de contraintes"),
             TAU0            =SIMP(statut='o',typ='R',fr="Contraintes critique initiale de cisaillement, en unite de contraintes"),
             GAMMA0          =SIMP(statut='o',typ='R',fr="Vitesse d ecoulement initiale"),
             DELTAG0         =SIMP(statut='o',typ='R',fr="Gain d energie lie au franchissement d obstacle"),
             BSD             =SIMP(statut='o',typ='R',fr="fonction de la taille du grain B/D"),
             GCB             =SIMP(statut='o',typ='R',fr="distance critique d'annihilation GC/B"),
             KDCS            =SIMP(statut='o',typ='R',fr="Parametre relatif à la direction principale de la dislocation"),
             P               =SIMP(statut='o',typ='R',fr="Parametre materiau dépendant de la forme de l'obstacle"),
             Q               =SIMP(statut='o',typ='R',fr="Parametre materiau dépendant de la forme de l'obstacle"),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R'),
             H2              =SIMP(statut='f',typ='R'),
             H3              =SIMP(statut='f',typ='R'),
             H4              =SIMP(statut='f',typ='R'),
             H5              =SIMP(statut='f',typ='R'),
             H6              =SIMP(statut='f',typ='R'),
           ),
           MONO_DD_CFC      =FACT(statut='f',
             regles=(UN_PARMI('H','H1'),
                     PRESENT_PRESENT('H1','H2','H3','H4','H5'),
                     PRESENT_ABSENT('H','H1','H2','H3','H4','H5'),
                     ),
             #TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             GAMMA0          =SIMP(statut='f',typ='R',defaut=0.001,fr="Vitesse d ecoulement initiale en s**-1"),
             TAU_F           =SIMP(statut='o',typ='R',fr="Contraintes , en unite de contraintes ex 20 MPa"),
             A               =SIMP(statut='f',typ='R',defaut=0.13,fr="paramètre A, sans unité"),
             B               =SIMP(statut='f',typ='R',defaut=0.005,fr="paramètre B, sans unité"),
             N               =SIMP(statut='f',typ='R',defaut=200.,fr="paramètre n, sans unité"),
             Y               =SIMP(statut='o',typ='R',fr="paramète Y, en unité de longueur ex 2.5 A"),
             ALPHA           =SIMP(statut='f',typ='R',defaut=0.35,fr="ecrouissage, paramètre alpha"),
             BETA            =SIMP(statut='o',typ='R',fr="ecrouissage, paramètre b, en unite de longueur"),
             RHO_REF         =SIMP(statut='o',typ='R',fr="ecrouissage, paramètre rho_ref, en unité de longueur **-2"),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R',defaut=0.124,fr="matrice d'interaction, terme a*",),
             H2              =SIMP(statut='f',typ='R',defaut=0.625,fr="matrice d'interaction, terme a_colineaire",),
             H3              =SIMP(statut='f',typ='R',defaut=0.137,fr="matrice d'interaction, terme a_glissile",),
             H4              =SIMP(statut='f',typ='R',defaut=0.122,fr="matrice d'interaction, terme a_Lomer",),
             H5              =SIMP(statut='f',typ='R',defaut=0.07,fr="matrice d'interaction, terme a_Hirth",),
           ),

           MONO_DD_CFC_IRRA      =FACT(statut='f',
             regles=(UN_PARMI('H','H1'),
                     PRESENT_PRESENT('H1','H2','H3','H4','H5'),
                     PRESENT_ABSENT('H','H1','H2','H3','H4','H5'),
                     ),
             #TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             GAMMA0          =SIMP(statut='f',typ='R',defaut=0.001,fr="Vitesse d ecoulement initiale en s**-1"),
             TAU_F           =SIMP(statut='o',typ='R',fr="Contraintes , en unite de contraintes ex 20 MPa"),
             A               =SIMP(statut='f',typ='R',defaut=0.13,fr="paramètre A, sans unité"),
             B               =SIMP(statut='f',typ='R',defaut=0.005,fr="paramètre B, sans unité"),
             N               =SIMP(statut='f',typ='R',defaut=200.,fr="paramètre n, sans unité"),
             Y               =SIMP(statut='o',typ='R',fr="paramète Y, en unité de longueur ex 2.5 A"),
             ALPHA           =SIMP(statut='f',typ='R',defaut=0.35,fr="ecrouissage, paramètre alpha"),
             BETA            =SIMP(statut='o',typ='R',fr="ecrouissage, paramètre b, en unite de longueur"),
             RHO_REF         =SIMP(statut='o',typ='R',fr="ecrouissage, paramètre rho_ref, en unité de longueur **-2"),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R',defaut=0.124,fr="matrice d'interaction, terme a*",),
             H2              =SIMP(statut='f',typ='R',defaut=0.625,fr="matrice d'interaction, terme a_colineaire",),
             H3              =SIMP(statut='f',typ='R',defaut=0.137,fr="matrice d'interaction, terme a_glissile",),
             H4              =SIMP(statut='f',typ='R',defaut=0.122,fr="matrice d'interaction, terme a_Lomer",),
             H5              =SIMP(statut='f',typ='R',defaut=0.07,fr="matrice d'interaction, terme a_Hirth",),

             DZ_IRRA         =SIMP(statut='o',typ='R',val_min=0.E+0,fr="Parametre dzeta pour irradiation"),
             XI_IRRA         =SIMP(statut='o',typ='R',val_min=0.E+0,fr="Parametre xi pour irradiation"),
             RHO_VOID        =SIMP(statut='o',typ='R',fr="Parametre rho_voids pour irradiation"),
             PHI_LOOP        =SIMP(statut='o',typ='R',fr="Parametre phi_loops pour irradiation"),
             ALP_VOID        =SIMP(statut='o',typ='R',fr="Parametre alpha_voids pour irradiation"),
             ALP_LOOP        =SIMP(statut='o',typ='R',fr="Parametre alpha_loops pour irradiation"),
             RHO_SAT         =SIMP(statut='o',typ='R',fr="Parametre rho_sat*b*b pour irradiation"),
             PHI_SAT         =SIMP(statut='o',typ='R',fr="Parametre phi_sat pour irradiation"),

           ),

           MONO_DD_FAT      =FACT(statut='f',
             regles=(UN_PARMI('H','H1'),
                     PRESENT_PRESENT('H1','H2','H3','H4','H5'),
                     PRESENT_ABSENT('H','H1','H2','H3','H4','H5'),
                     ),
             #TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             GAMMA0          =SIMP(statut='o',typ='R',fr="Vitesse d ecoulement initiale en s**-1"),
             TAU_F           =SIMP(statut='o',typ='R',fr="Contraintes , en unite de contraintes ex 20 MPa"),
             BETA            =SIMP(statut='o',typ='R',fr="ecrouissage, paramètre b, en unite de longueur"),
             N               =SIMP(statut='o',typ='R',fr="paramètre n, sans unite"),
             UN_SUR_D        =SIMP(statut='o',typ='R',fr="paramètre 1/D, en unite de 1/longueur"),
             GC0             =SIMP(statut='o',typ='R',fr="paramètre GC0, en unite de longueur"),
             K               =SIMP(statut='o',typ='R',fr="paramètre K, sans unite"),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R',defaut=0.124,fr="matrice d'interaction, terme a*",),
             H2              =SIMP(statut='f',typ='R',defaut=0.625,fr="matrice d'interaction, terme a_colineaire",),
             H3              =SIMP(statut='f',typ='R',defaut=0.137,fr="matrice d'interaction, terme a_glissile",),
             H4              =SIMP(statut='f',typ='R',defaut=0.122,fr="matrice d'interaction, terme a_Lomer",),
             H5              =SIMP(statut='f',typ='R',defaut=0.07,fr="matrice d'interaction, terme a_Hirth",),
           ),

          MONO_DD_CC      =FACT(statut='f',
             #TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             B               =SIMP(statut='o',typ='R',fr="parametre B, en unite de longueur"),
             GH               =SIMP(statut='o',typ='R',fr="parametre H, en unite de 1/temps"),
             DELTAG0         =SIMP(statut='o',typ='R',fr="energie d'activation, en unite d'energie (eV ou J)"),
             TAU_0           =SIMP(statut='o',typ='R',fr="contrainte ultime, en unite de contraintes "),
             TAU_F           =SIMP(statut='o',typ='R',fr="seuil en contrainte , en unite de contraintes"),
             GAMMA0          =SIMP(statut='o',typ='R',fr="Vitesse d ecoulement initiale en s**-1"),
             N               =SIMP(statut='o',typ='R',fr="parametre n, sans unite"),
             RHO_MOB         =SIMP(statut='o',typ='R',fr="densite de dislocations mobiles, en unite de longueur **-2"),
             D               =SIMP(statut='o',typ='R',fr="parametre D, en unite de longueur"),
             BETA            =SIMP(statut='o',typ='R',fr="parametre beta, sans unite"),
             D_LAT           =SIMP(statut='o',typ='R',fr="parametre D_LAT, en unite de longueur"),
             Y_AT            =SIMP(statut='o',typ='R',fr="parametre Y_AT, en unite de longueur"),
             K_F             =SIMP(statut='o',typ='R',fr="Parametre K_F"),
             K_SELF          =SIMP(statut='o',typ='R',fr="Parametre K_SELF"),
             K_BOLTZ         =SIMP(statut='o',typ='R',fr="Constante de Boltzmann, en eV/K"),
             H1              =SIMP(statut='o',typ='R',fr="Parametre a_self"),
             H2              =SIMP(statut='o',typ='R',fr="Parametre a_coli"),
             H3              =SIMP(statut='o',typ='R',fr="Parametre a_ncol"),
             H4              =SIMP(statut='f',typ='R',defaut=0.),
             H5              =SIMP(statut='f',typ='R',defaut=0.),
             H6              =SIMP(statut='f',typ='R',defaut=0.),
             DELTA1          =SIMP(statut='f',typ='R',defaut=1.,fr="parametre permettant la variation de Y_AT avec tau_eff"),
             DELTA2          =SIMP(statut='f',typ='R',defaut=1.,fr="parametre permettant la variation de a_AT avec tau_eff"),
             DEPDT           =SIMP(statut='f',typ='R',defaut=0.,fr="parametre dEps/dT pour le calcul de DeltaG"),
           ),

          MONO_DD_CC_IRRA =FACT(statut='f',
             #TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             B               =SIMP(statut='o',typ='R',fr="parametre B, en unite de longueur"),
             GH               =SIMP(statut='o',typ='R',fr="parametre H, en unite de 1/temps"),
             DELTAG0         =SIMP(statut='o',typ='R',fr="Gain d energie lie au franchissement d obstacle"),
             TAU_0           =SIMP(statut='o',typ='R',fr="Contraintes , en unite de contraintes ex 20 MPa"),
             TAU_F           =SIMP(statut='o',typ='R',fr="Contraintes , en unite de contraintes ex 20 MPa"),
             GAMMA0          =SIMP(statut='o',typ='R',fr="Vitesse d ecoulement initiale en s**-1"),
             N               =SIMP(statut='o',typ='R',fr="parametre n, sans unite"),
             RHO_MOB         =SIMP(statut='o',typ='R',fr="densite de dislocations mobiles, en unite de longueur **-2"),
             D               =SIMP(statut='o',typ='R',fr="parametre D, en unite de longueur"),
             BETA            =SIMP(statut='o',typ='R',fr="ecrouissage, parametre beta"),
             D_LAT           =SIMP(statut='o',typ='R',fr="parametre D_LAT, en unite de longueur"),
             Y_AT            =SIMP(statut='o',typ='R',fr="parametre Y_AT, en unite de longueur"),
             K_F             =SIMP(statut='o',typ='R',fr="Parametre K_F"),
             K_SELF          =SIMP(statut='o',typ='R',fr="Parametre K_SELF"),
             K_BOLTZ         =SIMP(statut='o',typ='R',fr="Constante de Boltzmann, en eV/K"),
             H1              =SIMP(statut='o',typ='R',fr="Parametre a_self"),
             H2              =SIMP(statut='o',typ='R',fr="Parametre a_coli"),
             H3              =SIMP(statut='o',typ='R',fr="Parametre a_ncol"),
             H4              =SIMP(statut='f',typ='R',defaut=0.),
             H5              =SIMP(statut='f',typ='R',defaut=0.),
             H6              =SIMP(statut='f',typ='R',defaut=0.),
             DELTA1          =SIMP(statut='f',typ='R',defaut=1.,fr="parametre permettant la variation de Y_AT avec tau_eff"),
             DELTA2          =SIMP(statut='f',typ='R',defaut=1.,fr="parametre permettant la variation de a_AT avec tau_eff"),
             DEPDT           =SIMP(statut='f',typ='R',defaut=0.,fr="parametre dEps/dT pour le calcul de DeltaG"),
             A_IRRA          =SIMP(statut='o',typ='R',fr="Parametre a_loops pour irradiation"),
             XI_IRRA         =SIMP(statut='o',typ='R',fr="Parametre xi pour irradiation"),
           ),


####  FIN MONOCRISTAL

### UMAT
           UMAT   =FACT(statut='f',
             NB_VALE =SIMP(statut='f',typ='R'),
             C1 =SIMP(statut='f',typ='R'),
             C2 =SIMP(statut='f',typ='R'),
             C3 =SIMP(statut='f',typ='R'),
             C4 =SIMP(statut='f',typ='R'),
             C5 =SIMP(statut='f',typ='R'),
             C6 =SIMP(statut='f',typ='R'),
             C7 =SIMP(statut='f',typ='R'),
             C8 =SIMP(statut='f',typ='R'),
             C9 =SIMP(statut='f',typ='R'),
             C10 =SIMP(statut='f',typ='R'),
             C11 =SIMP(statut='f',typ='R'),
             C12 =SIMP(statut='f',typ='R'),
             C13 =SIMP(statut='f',typ='R'),
             C14 =SIMP(statut='f',typ='R'),
             C15 =SIMP(statut='f',typ='R'),
             C16 =SIMP(statut='f',typ='R'),
             C17 =SIMP(statut='f',typ='R'),
             C18 =SIMP(statut='f',typ='R'),
             C19 =SIMP(statut='f',typ='R'),
             C20 =SIMP(statut='f',typ='R'),
             C21 =SIMP(statut='f',typ='R'),
             C22 =SIMP(statut='f',typ='R'),
             C23 =SIMP(statut='f',typ='R'),
             C24 =SIMP(statut='f',typ='R'),
             C25 =SIMP(statut='f',typ='R'),
             C26 =SIMP(statut='f',typ='R'),
             C27 =SIMP(statut='f',typ='R'),
             C28 =SIMP(statut='f',typ='R'),
             C29 =SIMP(statut='f',typ='R'),
             C30 =SIMP(statut='f',typ='R'),
             C31 =SIMP(statut='f',typ='R'),
             C32 =SIMP(statut='f',typ='R'),
             C33 =SIMP(statut='f',typ='R'),
             C34 =SIMP(statut='f',typ='R'),
             C35 =SIMP(statut='f',typ='R'),
             C36 =SIMP(statut='f',typ='R'),
             C37 =SIMP(statut='f',typ='R'),
             C38 =SIMP(statut='f',typ='R'),
             C39 =SIMP(statut='f',typ='R'),
             C40 =SIMP(statut='f',typ='R'),
             C41 =SIMP(statut='f',typ='R'),
             C42 =SIMP(statut='f',typ='R'),
             C43 =SIMP(statut='f',typ='R'),
             C44 =SIMP(statut='f',typ='R'),
             C45 =SIMP(statut='f',typ='R'),
             C46 =SIMP(statut='f',typ='R'),
             C47 =SIMP(statut='f',typ='R'),
             C48 =SIMP(statut='f',typ='R'),
             C49 =SIMP(statut='f',typ='R'),
             C50 =SIMP(statut='f',typ='R'),
             C51 =SIMP(statut='f',typ='R'),
             C52 =SIMP(statut='f',typ='R'),
             C53 =SIMP(statut='f',typ='R'),
             C54 =SIMP(statut='f',typ='R'),
             C55 =SIMP(statut='f',typ='R'),
             C56 =SIMP(statut='f',typ='R'),
             C57 =SIMP(statut='f',typ='R'),
             C58 =SIMP(statut='f',typ='R'),
             C59 =SIMP(statut='f',typ='R'),
             C60 =SIMP(statut='f',typ='R'),
             C61 =SIMP(statut='f',typ='R'),
             C62 =SIMP(statut='f',typ='R'),
             C63 =SIMP(statut='f',typ='R'),
             C64 =SIMP(statut='f',typ='R'),
             C65 =SIMP(statut='f',typ='R'),
             C66 =SIMP(statut='f',typ='R'),
             C67 =SIMP(statut='f',typ='R'),
             C68 =SIMP(statut='f',typ='R'),
             C69 =SIMP(statut='f',typ='R'),
             C70 =SIMP(statut='f',typ='R'),
             C71 =SIMP(statut='f',typ='R'),
             C72 =SIMP(statut='f',typ='R'),
             C73 =SIMP(statut='f',typ='R'),
             C74 =SIMP(statut='f',typ='R'),
             C75 =SIMP(statut='f',typ='R'),
             C76 =SIMP(statut='f',typ='R'),
             C77 =SIMP(statut='f',typ='R'),
             C78 =SIMP(statut='f',typ='R'),
             C79 =SIMP(statut='f',typ='R'),
             C80 =SIMP(statut='f',typ='R'),
             C81 =SIMP(statut='f',typ='R'),
             C82 =SIMP(statut='f',typ='R'),
             C83 =SIMP(statut='f',typ='R'),
             C84 =SIMP(statut='f',typ='R'),
             C85 =SIMP(statut='f',typ='R'),
             C86 =SIMP(statut='f',typ='R'),
             C87 =SIMP(statut='f',typ='R'),
             C88 =SIMP(statut='f',typ='R'),
             C89 =SIMP(statut='f',typ='R'),
             C90 =SIMP(statut='f',typ='R'),
             C91 =SIMP(statut='f',typ='R'),
             C92 =SIMP(statut='f',typ='R'),
             C93 =SIMP(statut='f',typ='R'),
             C94 =SIMP(statut='f',typ='R'),
             C95 =SIMP(statut='f',typ='R'),
             C96 =SIMP(statut='f',typ='R'),
             C97 =SIMP(statut='f',typ='R'),
             C98 =SIMP(statut='f',typ='R'),
             C99 =SIMP(statut='f',typ='R'),
             C100 =SIMP(statut='f',typ='R'),
             C101 =SIMP(statut='f',typ='R'),
             C102 =SIMP(statut='f',typ='R'),
             C103 =SIMP(statut='f',typ='R'),
             C104 =SIMP(statut='f',typ='R'),
             C105 =SIMP(statut='f',typ='R'),
             C106 =SIMP(statut='f',typ='R'),
             C107 =SIMP(statut='f',typ='R'),
             C108 =SIMP(statut='f',typ='R'),
             C109 =SIMP(statut='f',typ='R'),
             C110 =SIMP(statut='f',typ='R'),
             C111 =SIMP(statut='f',typ='R'),
             C112 =SIMP(statut='f',typ='R'),
             C113 =SIMP(statut='f',typ='R'),
             C114 =SIMP(statut='f',typ='R'),
             C115 =SIMP(statut='f',typ='R'),
             C116 =SIMP(statut='f',typ='R'),
             C117 =SIMP(statut='f',typ='R'),
             C118 =SIMP(statut='f',typ='R'),
             C119 =SIMP(statut='f',typ='R'),
             C120 =SIMP(statut='f',typ='R'),
             C121 =SIMP(statut='f',typ='R'),
             C122 =SIMP(statut='f',typ='R'),
             C123 =SIMP(statut='f',typ='R'),
             C124 =SIMP(statut='f',typ='R'),
             C125 =SIMP(statut='f',typ='R'),
             C126 =SIMP(statut='f',typ='R'),
             C127 =SIMP(statut='f',typ='R'),
             C128 =SIMP(statut='f',typ='R'),
             C129 =SIMP(statut='f',typ='R'),
             C130 =SIMP(statut='f',typ='R'),
             C131 =SIMP(statut='f',typ='R'),
             C132 =SIMP(statut='f',typ='R'),
             C133 =SIMP(statut='f',typ='R'),
             C134 =SIMP(statut='f',typ='R'),
             C135 =SIMP(statut='f',typ='R'),
             C136 =SIMP(statut='f',typ='R'),
             C137 =SIMP(statut='f',typ='R'),
             C138 =SIMP(statut='f',typ='R'),
             C139 =SIMP(statut='f',typ='R'),
             C140 =SIMP(statut='f',typ='R'),
             C141 =SIMP(statut='f',typ='R'),
             C142 =SIMP(statut='f',typ='R'),
             C143 =SIMP(statut='f',typ='R'),
             C144 =SIMP(statut='f',typ='R'),
             C145 =SIMP(statut='f',typ='R'),
             C146 =SIMP(statut='f',typ='R'),
             C147 =SIMP(statut='f',typ='R'),
             C148 =SIMP(statut='f',typ='R'),
             C149 =SIMP(statut='f',typ='R'),
             C150 =SIMP(statut='f',typ='R'),
             C151 =SIMP(statut='f',typ='R'),
             C152 =SIMP(statut='f',typ='R'),
             C153 =SIMP(statut='f',typ='R'),
             C154 =SIMP(statut='f',typ='R'),
             C155 =SIMP(statut='f',typ='R'),
             C156 =SIMP(statut='f',typ='R'),
             C157 =SIMP(statut='f',typ='R'),
             C158 =SIMP(statut='f',typ='R'),
             C159 =SIMP(statut='f',typ='R'),
             C160 =SIMP(statut='f',typ='R'),
             C161 =SIMP(statut='f',typ='R'),
             C162 =SIMP(statut='f',typ='R'),
             C163 =SIMP(statut='f',typ='R'),
             C164 =SIMP(statut='f',typ='R'),
             C165 =SIMP(statut='f',typ='R'),
             C166 =SIMP(statut='f',typ='R'),
             C167 =SIMP(statut='f',typ='R'),
             C168 =SIMP(statut='f',typ='R'),
             C169 =SIMP(statut='f',typ='R'),
             C170 =SIMP(statut='f',typ='R'),
             C171 =SIMP(statut='f',typ='R'),
             C172 =SIMP(statut='f',typ='R'),
             C173 =SIMP(statut='f',typ='R'),
             C174 =SIMP(statut='f',typ='R'),
             C175 =SIMP(statut='f',typ='R'),
             C176 =SIMP(statut='f',typ='R'),
             C177 =SIMP(statut='f',typ='R'),
             C178 =SIMP(statut='f',typ='R'),
             C179 =SIMP(statut='f',typ='R'),
             C180 =SIMP(statut='f',typ='R'),
             C181 =SIMP(statut='f',typ='R'),
             C182 =SIMP(statut='f',typ='R'),
             C183 =SIMP(statut='f',typ='R'),
             C184 =SIMP(statut='f',typ='R'),
             C185 =SIMP(statut='f',typ='R'),
             C186 =SIMP(statut='f',typ='R'),
             C187 =SIMP(statut='f',typ='R'),
             C188 =SIMP(statut='f',typ='R'),
             C189 =SIMP(statut='f',typ='R'),
             C190 =SIMP(statut='f',typ='R'),
             C191 =SIMP(statut='f',typ='R'),
             C192 =SIMP(statut='f',typ='R'),
             C193 =SIMP(statut='f',typ='R'),
             C194 =SIMP(statut='f',typ='R'),
             C195 =SIMP(statut='f',typ='R'),
             C196 =SIMP(statut='f',typ='R'),
             C197 =SIMP(statut='f',typ='R'),
           ),
           UMAT_FO   =FACT(statut='f',
             NB_VALE =SIMP(statut='f',typ='R'),
             C1 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C2 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C3 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C4 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C5 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C6 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C7 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C8 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C9 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C10 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C11 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C12 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C13 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C14 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C15 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C16 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C17 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C18 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C19 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C20 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C21 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C22 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C23 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C24 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C25 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C26 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C27 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C28 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C29 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C30 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C31 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C32 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C33 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C34 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C35 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C36 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C37 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C38 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C39 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C40 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C41 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C42 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C43 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C44 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C45 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C46 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C47 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C48 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C49 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C50 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C51 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C52 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C53 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C54 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C55 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C56 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C57 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C58 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C59 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C60 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C61 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C62 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C63 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C64 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C65 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C66 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C67 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C68 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C69 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C70 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C71 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C72 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C73 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C74 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C75 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C76 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C77 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C78 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C79 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C80 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C81 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C82 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C83 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C84 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C85 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C86 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C87 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C88 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C89 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C90 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C91 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C92 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C93 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C94 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C95 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C96 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C97 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C98 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C99 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C100 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C101 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C102 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C103 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C104 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C105 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C106 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C107 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C108 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C109 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C110 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C111 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C112 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C113 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C114 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C115 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C116 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C117 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C118 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C119 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C120 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C121 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C122 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C123 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C124 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C125 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C126 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C127 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C128 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C129 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C130 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C131 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C132 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C133 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C134 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C135 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C136 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C137 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C138 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C139 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C140 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C141 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C142 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C143 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C144 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C145 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C146 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C147 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C148 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C149 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C150 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C151 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C152 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C153 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C154 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C155 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C156 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C157 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C158 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C159 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C160 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C161 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C162 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C163 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C164 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C165 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C166 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C167 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C168 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C169 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C170 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C171 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C172 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C173 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C174 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C175 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C176 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C177 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C178 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C179 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C180 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C181 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C182 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C183 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C184 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C185 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C186 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C187 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C188 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C189 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C190 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C191 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C192 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C193 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C194 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C195 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C196 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
             C197 =SIMP(statut='f',typ=(fonction_sdaster,formule)),
           ),
### UMAT
### CRITERE DE RUPTURE
           CRIT_RUPT      =FACT(statut='f',
             SIGM_C           =SIMP(statut='o',typ='R',fr="contrainte critique"),
             COEF             =SIMP(statut='o',typ='R',fr="E=E/COEF,si la contrainte principale max est atteinte dans l'element"),
           ),
#

           INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
DEFI_MODELE_GENE=OPER(nom="DEFI_MODELE_GENE",op= 126,sd_prod=modele_gene,
                      reentrant='n',
            fr="Créer la structure globale à partir des sous-structures en sous-structuration dynamique", 
            UIinfo={"groupes":("Matrices et vecteurs",)},
         SOUS_STRUC      =FACT(statut='o',max='**',
           NOM             =SIMP(statut='o',typ='TXM' ),
           MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
           ANGL_NAUT       =SIMP(statut='o',typ='R',max=3),
           TRANS           =SIMP(statut='o',typ='R',max=3),
         ),
         LIAISON         =FACT(statut='o',max='**',
           SOUS_STRUC_1    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_1     =SIMP(statut='o',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_2     =SIMP(statut='o',typ='TXM' ),
           regles=(EXCLUS('GROUP_MA_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),
                   EXCLUS('MAILLE_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),),
           GROUP_MA_MAIT_1   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_1     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_MAIT_2   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_2     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           OPTION            =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("REDUIT","CLASSIQUE") ),
         ),
         VERIF           =FACT(statut='f',max='**',
#  dans la doc U stop_erreur est obligatoire         
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
DEFI_NAPPE=OPER(nom="DEFI_NAPPE",op=4,sd_prod=nappe_sdaster,
                fr="Définir une fonction réelle de deux variables réelles",
                reentrant='n',UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('FONCTION','DEFI_FONCTION'),
                 EXCLUS('FONCTION','NOM_PARA_FONC',),
                 ENSEMBLE('NOM_PARA_FONC','DEFI_FONCTION'),),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         PARA            =SIMP(statut='o',typ='R',max='**'),
         FONCTION        =SIMP(statut='f',typ=fonction_sdaster, max='**' ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM',into=C_PARA_FONCTION() ),
         DEFI_FONCTION   =FACT(statut='f',max='**',
           VALE            =SIMP(statut='o',typ='R',max='**'),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG"),
                                 fr="Type d'interpolation pour les abscisses et les ordonnées de la fonction."),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG"),
                               fr="Type d'interpolation pour le paramètre de la nappe"),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1, 2) ),
         VERIF           =SIMP(statut='f',typ='TXM',into=("CROISSANT",) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: marc.kham at edf.fr
DEFI_OBSTACLE=OPER(nom="DEFI_OBSTACLE",op=  73,sd_prod=table_fonction,
                   fr="Définition d'un obstacle plan perpendiculaire à une structure filaire",
                   reentrant='n',
         UIinfo={"groupes":("Modélisation",)},
         TYPE            =SIMP(statut='o',typ='TXM',defaut="CERCLE",
                             into=("CERCLE","PLAN_Y","PLAN_Z","DISCRET",
                             "BI_CERCLE","BI_PLAN_Y","BI_PLAN_Z","BI_CERC_INT",
                             ) ),
         VALE            =SIMP(statut='f',typ='R',max='**'),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="FERME"),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr

DEFI_PART_OPS=OPER(nom="DEFI_PART_OPS",op=21,sd_prod=sd_partit,
                    fr="Creation partitionnement en sous-domaines",
                    docu="U4.23.05",reentrant='n',
                    UIinfo={"groupes":("Modélisation",)},
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
         NOM             =SIMP(statut='f',typ='TXM',defaut='SD'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4) ),
         DEFI          =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma),
           GROUP_MA_BORD   =SIMP(statut='f',typ=grma),
         ),
         EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),
         ),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr

DEFI_PART_PA_OPS=PROC(nom="DEFI_PART_PA_OPS",op=29,
                    fr="Creation partitionnement en sous-domaines",
                    docu="U4.00.00",
                    UIinfo={"groupes":("Modélisation",)},
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster,squelette) ),
         MODELE          =SIMP(statut='f',typ=(modele_sdaster)),
         NB_PART         =SIMP(statut='o',typ='I',),

         # Methode de partitionnement
         METHODE         =SIMP(statut='f',typ='TXM',into=("PMETIS","SCOTCH","KMETIS",), defaut="KMETIS" ),

         LOGICIEL      =SIMP(statut='f',typ='TXM'),

         # Corrige les problemes possibles de non-connexite des sous-domaines
         CORRECTIOP_CONNEX    =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON')),

         # Permet de grouper des mailles dans un meme sous-doamine
         GROUPAGE        =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
                          ),
         # Permet d'appliquer des poids sur certaines mailles
         POIDS_MAILLES   =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
           POIDS          =SIMP(statut='f',typ='I'),
                          ),
         # Prefixe pour le nom des group_ma definissant les sous-domaines
         NOM_GROUP_MA    =SIMP(statut='f',typ='TXM',defaut='SD' ),

         # Traiter les mailles de bords (elles sont enlevees du graphe puis reinjectees)
         TRAITER_BORDS   =SIMP(statut='f',typ='TXM',defaut='OUI',into=('OUI','NON') ),

         # Si le mot-clé suivant est renseigné, crée de nouveau group_ma a partir des bords
         b_traiter_bords =BLOC(condition="TRAITER_BORDS == 'OUI'", fr="Crée t on des nouveaux group_ma",
           NOM_GROUP_MA_BORD  =SIMP(statut='f',typ='TXM'),
             ),

         INFO            =SIMP(statut='f',typ='I',into=(1, 2), defaut=1),

);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr


DEFI_PARTITION=MACRO(nom="DEFI_PARTITION",
                     op=OPS('Macro.defi_partition_ops.defi_partition_ops'),
                     sd_prod=sd_partit,
                     reentrant='n',UIinfo={"groupes":("Modélisation",)},
                     fr="Creation partitionnement en sous-domaines",
         regles=(UN_PARMI('MAILLAGE','MODELE'),PRESENT_PRESENT('MODELE','EXCIT'),),

         NB_PART         =SIMP(statut='o',typ='I',val_min=2),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),
         EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),),

         # Methode de partitionnement
         METHODE         =SIMP(statut='f',typ='TXM',into=("PMETIS","SCOTCH","KMETIS",), defaut="KMETIS" ),

         LOGICIEL      =SIMP(statut='f',typ='TXM'),

         # Corrige les problemes possibles de non-connexite des sous-domaines
         CORRECTIOP_CONNEX    =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON')),

         # Permet de grouper des mailles dans un meme sous-doamine
         GROUPAGE        =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
                          ),
         # Permet d'appliquer des poids sur certaines mailles
         POIDS_MAILLES   =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
           POIDS          =SIMP(statut='f',typ='I',val_min=2),
                          ),
         # Prefixe pour le nom des group_ma definissant les sous-domaines
         NOM_GROUP_MA    =SIMP(statut='f',typ='TXM',defaut='SD' ),

         # Traiter les mailles de bords (elles sont enlevees du graphe puis reinjectees)
         TRAITER_BORDS   =SIMP(statut='f',typ='TXM',defaut='OUI',into=('OUI','NON') ),

         # Si le mot-clé suivant est renseigné, crée de nouveau group_ma a partir des bords
         b_traiter_bords =BLOC(condition="TRAITER_BORDS == 'OUI'", fr="Crée t on des nouveaux group_ma",
           NOM_GROUP_MA_BORD  =SIMP(statut='f',typ='TXM'),
             ),

         INFO            =SIMP(statut='f',typ='I',into=(1, 2), defaut=1),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


DEFI_SOL_MISS = MACRO(nom="DEFI_SOL_MISS",
                      op=OPS('Macro.defi_sol_miss_ops.defi_sol_miss_ops'),
                      sd_prod=table_sdaster,
                      fr="Définition des données de sol pour Miss",
                      reentrant='n',
                      UIinfo={"groupes":("Modélisation","Outils-métier",)},
   MATERIAU = FACT(statut='o', max='**',
            fr="Définition des matériaux",
      E         = SIMP(statut='o', typ='R', fr="Module d'Young"),
      NU        = SIMP(statut='o', typ='R', fr="Coefficient de Poisson"),
      RHO       = SIMP(statut='o', typ='R', fr="Masse volumique"),
      AMOR_HYST = SIMP(statut='o', typ='R', fr="Coefficient d'amortissement"),
   ),
   COUCHE = FACT(statut='o', max='**',
                 fr="Définition des couches",
      regles=(AU_MOINS_UN('EPAIS','SUBSTRATUM'),),
      SUBSTRATUM= SIMP(statut='f', typ='TXM', into=("OUI","NON"),),
      EPAIS     = SIMP(statut='f', typ='R', fr="Epaisseur de la couche"),
      RECEPTEUR = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON"),),
      SOURCE    = SIMP(statut='f', typ='TXM', defaut="NON", into=("OUI", "NON"),),
      NUME_MATE = SIMP(statut='o', typ='I', fr="Numéro du matériau"),
   ),
   TITRE = SIMP(statut='f', typ='TXM', max='**',
                fr="Titre de la table produite"),
   INFO  = SIMP(statut='f', typ='I', defaut=1, into=(1,2)),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
DEFI_SPEC_TURB=OPER(nom="DEFI_SPEC_TURB",op= 145,sd_prod=spectre_sdaster,
                    fr="Definition d'un spectre d'excitation turbulente",
                    reentrant='n',
            UIinfo={"groupes":("Modelisation","Outils-metier",)},
         regles=(UN_PARMI('SPEC_LONG_COR_1','SPEC_LONG_COR_2','SPEC_LONG_COR_3',
                          'SPEC_LONG_COR_4','SPEC_CORR_CONV_1','SPEC_CORR_CONV_2',
                          'SPEC_CORR_CONV_3','SPEC_FONC_FORME','SPEC_EXCI_POINT'),),
         SPEC_LONG_COR_1 =FACT(statut='f',
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VISC_CINE       =SIMP(statut='o',typ='R' ),
         ),
         SPEC_LONG_COR_2 =FACT(statut='f',
           regles=(ENSEMBLE('FREQ_COUP','PHI0','BETA' ),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FREQ_COUP       =SIMP(statut='f',typ='R',defaut= 0.1 ),
           PHI0            =SIMP(statut='f',typ='R',defaut= 1.5E-3 ),
           BETA            =SIMP(statut='f',typ='R',defaut= 2.7 ),
         ),
         SPEC_LONG_COR_3 =FACT(statut='f',
           regles=(ENSEMBLE('PHI0_1','BETA_1','PHI0_2','BETA_2','FREQ_COUP'),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FREQ_COUP       =SIMP(statut='f',typ='R',defaut= 0.2 ),
           PHI0_1          =SIMP(statut='f',typ='R',defaut= 5.E-3 ),
           BETA_1          =SIMP(statut='f',typ='R',defaut= 0.5 ),
           PHI0_2          =SIMP(statut='f',typ='R',defaut= 4.E-5 ),
           BETA_2          =SIMP(statut='f',typ='R',defaut= 3.5 ),
         ),
         SPEC_LONG_COR_4 =FACT(statut='f',
           regles=(ENSEMBLE('BETA','GAMMA'),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TAUX_VIDE       =SIMP(statut='o',typ='R' ),
           BETA            =SIMP(statut='f',typ='R',defaut= 2. ),
           GAMMA           =SIMP(statut='f',typ='R',defaut= 4. ),
         ),
         SPEC_CORR_CONV_1=FACT(statut='f',
           LONG_COR_1      =SIMP(statut='o',typ='R' ),
           LONG_COR_2      =SIMP(statut='f',typ='R' ),
           VITE_FLUI       =SIMP(statut='o',typ='R' ),
           RHO_FLUI        =SIMP(statut='o',typ='R' ),
           FREQ_COUP       =SIMP(statut='f',typ='R' ),
           K               =SIMP(statut='f',typ='R',defaut= 5.8E-3 ),
           D_FLUI          =SIMP(statut='o',typ='R' ),
           COEF_VITE_FLUI_A=SIMP(statut='f',typ='R' ),
           COEF_VITE_FLUI_O=SIMP(statut='f',typ='R' ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="GENERALE",
                                 into=("AU_YANG","GENERALE","CORCOS") ),
         ),
         SPEC_CORR_CONV_2=FACT(statut='f',
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE_FLUI       =SIMP(statut='o',typ='R' ),
           FREQ_COUP       =SIMP(statut='f',typ='R' ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="GENERALE",
                                 into=("AU_YANG","GENERALE","CORCOS",) ),
           COEF_VITE_FLUI_A=SIMP(statut='f',typ='R' ),
           COEF_VITE_FLUI_O=SIMP(statut='f',typ='R' ),
         ),
         SPEC_CORR_CONV_3=FACT(statut='f',
           TABLE_FONCTION  =SIMP(statut='o',typ=(table_fonction) ),
         ),
         SPEC_FONC_FORME =FACT(statut='f',
           regles=(UN_PARMI('INTE_SPEC','GRAPPE_1'),
                   ENSEMBLE('INTE_SPEC','FONCTION'),),
           INTE_SPEC       =SIMP(statut='f',typ=interspectre),
           FONCTION        =SIMP(statut='f',typ=(table_fonction),max='**'),
           GRAPPE_1        =SIMP(statut='f',typ='TXM',into=("DEBIT_180","DEBIT_300",) ),
           NOEUD           =SIMP(statut='o',typ=no),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         ),
         SPEC_EXCI_POINT =FACT(statut='f',
           regles=(UN_PARMI('INTE_SPEC','GRAPPE_2'),),
           INTE_SPEC       =SIMP(statut='f',typ=interspectre),
           GRAPPE_2        =SIMP(statut='f',typ='TXM',
                                 into=("ASC_CEN","ASC_EXC","DES_CEN","DES_EXC",) ),
#  Quels sont les statuts des mots cles a l interieur des deux blocs qui suivent
           b_inte_spec =BLOC(condition = "INTE_SPEC != None",
             NATURE          =SIMP(statut='o',typ='TXM',max='**',into=("FORCE","MOMENT",) ),
             ANGLE           =SIMP(statut='o',typ='R',max='**'),
             NOEUD           =SIMP(statut='o',typ=no,max='**'),
           ),
           b_grappe_2      =BLOC(condition = "GRAPPE_2 != None",
             RHO_FLUI        =SIMP(statut='o',typ='R' ),
             NOEUD           =SIMP(statut='o',typ=no),
           ),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
DEFI_SQUELETTE=OPER(nom="DEFI_SQUELETTE",op= 110,sd_prod=squelette,
                    fr="Définit un maillage pour visualiser les résultats d'une sous-structuration dynamique",
                    reentrant='n',
            UIinfo={"groupes":("Maillage","Dynamique",)},
         regles=(UN_PARMI('CYCLIQUE','MODELE_GENE','MAILLAGE'),
                 PRESENT_PRESENT('CYCLIQUE','SECTEUR'),
                 EXCLUS('SOUS_STRUC','SECTEUR'),
                 PRESENT_PRESENT('NOM_GROUP_MA','MODELE_GENE'),
                 PRESENT_PRESENT('NOM_GROUP_MA','SOUS_STRUC'),),
         CYCLIQUE    =FACT(statut='f',max='**',
           regles=(UN_PARMI('MODE_CYCL','MAILLAGE'),
                   PRESENT_PRESENT('NB_SECTEUR','MAILLAGE'),),
           MODE_CYCL       =SIMP(statut='f',typ=mode_cycl ),
           NB_SECTEUR      =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         SQUELETTE       =SIMP(statut='f',typ=squelette ),
         RECO_GLOBAL     =FACT(statut='f',max='**',
           regles=(EXCLUS('TOUT','GROUP_NO_1'),
                   PRESENT_PRESENT('GROUP_NO_1','GROUP_NO_2'),
                   PRESENT_PRESENT('GROUP_NO_1','SOUS_STRUC_1'),
                   PRESENT_PRESENT('GROUP_NO_2','SOUS_STRUC_2'),
                   PRESENT_PRESENT('SOUS_STRUC_1','SOUS_STRUC_2'),),
           TOUT            =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",) ),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           SOUS_STRUC_1    =SIMP(statut='f',typ='TXM' ),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           SOUS_STRUC_2    =SIMP(statut='f',typ='TXM' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           DIST_REFE       =SIMP(statut='f',typ='R' ),
         ),
         NOM_GROUP_MA    =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ='TXM' ),
           SOUS_STRUC      =SIMP(statut='o',typ='TXM' ),
           GROUP_MA        =SIMP(statut='o',typ=grma),
         ),
         EXCLUSIF        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         TRANS           =SIMP(statut='f',typ='R',min=3,max=3),
         ANGL_NAUT       =SIMP(statut='f',typ='R',min=3,max=3),
         SOUS_STRUC      =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','MAILLE','GROUP_MA'),),
           NOM             =SIMP(statut='o',typ='TXM' ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),
         SECTEUR         =FACT(statut='f',max='**',
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: renaud.bargellini at edf.fr
DEFI_TRC=OPER(nom="DEFI_TRC",op=94,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Modélisation","Thermique",)},
              fr="Définir d'un diagramme de transformations en refroidissement continu (TRC) de référence d'un acier"
                +" pour les calculs métallurgiques.",
         HIST_EXP        =FACT(statut='o',max='**',
           VALE            =SIMP(statut='o',typ='R',max='**'),
         ),
         TEMP_MS         =FACT(statut='o',max='**',
           SEUIL           =SIMP(statut='o',typ='R'),
           AKM             =SIMP(statut='o',typ='R'),
           BKM             =SIMP(statut='o',typ='R'),
           TPLM            =SIMP(statut='o',typ='R'),
         ),
         GRAIN_AUST      =FACT(statut='f',max='**',
           DREF           =SIMP(statut='f',typ='R'),
           A              =SIMP(statut='f',typ='R'),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def depl_interne_prod(DEPL_GLOBAL,**args ):
    if AsType(DEPL_GLOBAL)     == cham_no_sdaster: return cham_no_sdaster
    if AsType(DEPL_GLOBAL)     == evol_elas      : return evol_elas
    if AsType(DEPL_GLOBAL)     == dyna_trans     : return dyna_trans
    if AsType(DEPL_GLOBAL)     == dyna_harmo     : return dyna_harmo
    if AsType(DEPL_GLOBAL)     == mode_meca      : return mode_meca
    if AsType(DEPL_GLOBAL)     == mode_meca_c    : return mode_meca_c
    raise AsException("type de concept resultat non prevu")

DEPL_INTERNE=OPER(nom="DEPL_INTERNE",op=89,sd_prod=depl_interne_prod,reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
                  fr="Calculer le champ de déplacement à l'intérieur d'une sous-structure statique",
         DEPL_GLOBAL     =SIMP(statut='o',typ=(cham_no_sdaster,mode_meca,mode_meca_c,evol_elas,dyna_trans,dyna_harmo),),
         SUPER_MAILLE    =SIMP(statut='o',typ=ma,),
         NOM_CAS         =SIMP(statut='f',typ='TXM',defaut=" "),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
DETRUIRE=MACRO(nom="DETRUIRE",
               op=OPS("Cata.ops.DETRUIRE"),
               UIinfo={"groupes":("Gestion du travail",)},
               fr="Détruit des concepts utilisateurs dans la base GLOBALE ou des objets JEVEUX",
               op_init=ops.build_detruire,
    regles=(UN_PARMI('CONCEPT', 'OBJET',),),

    CONCEPT = FACT(statut='f',max='**',
        NOM         = SIMP(statut='o',typ=assd,validators=NoRepeat(),max='**'),
    ),
    OBJET = FACT(statut='f',max='**',
       CLASSE   = SIMP(statut='f', typ='TXM', into=('G', 'V', 'L'), defaut='G'),
       CHAINE   = SIMP(statut='o', typ='TXM', validators=NoRepeat(), max='**'),
       POSITION = SIMP(statut='f', typ='I', max='**'),
    ),
    INFO   = SIMP(statut='f', typ='I', into=(1, 2), defaut=2, ),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
DYNA_ALEA_MODAL=OPER(nom="DYNA_ALEA_MODAL",op= 131,sd_prod=interspectre,
                     fr="Calcul de la réponse spectrale d'une structure linéaire sous une excitation connue par sa DSP",
                     reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         BASE_MODALE     =FACT(statut='o',
           regles=(UN_PARMI('NUME_ORDRE','BANDE'),),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           BANDE           =SIMP(statut='f',typ='R',validators=NoRepeat(),max=2),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           b_bande =BLOC(condition = "BANDE != None",
             AMOR_UNIF       =SIMP(statut='o',typ='R' ),
           ),
           b_nume_ordre =BLOC(condition = "NUME_ORDRE != None",
             AMOR_REDUIT     =SIMP(statut='o',typ='R',max='**'),
           ),
         ),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca),
# MODE_STAT devrait etre dans EXCIT car est utile et obligatoire que si NOM_CMP=depl_r, on pourrait
# ainsi rajouter un bloc du genre  b_mod_stat= BLOC(condition = "(GRANDEUR == None) or (GRANDEUR == 'DEPL_R')",
         EXCIT           =FACT(statut='o',
           INTE_SPEC       =SIMP(statut='o',typ=interspectre),
           NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG",) ),
           MODAL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           b_modal_non = BLOC(condition = "(MODAL == None) or (MODAL == 'NON')",
             regles=(UN_PARMI('NOEUD_I','NUME_ORDRE_I'),),
             NUME_ORDRE_I    =SIMP(statut='f',typ='I',max='**'),
             NOEUD_I         =SIMP(statut='f',typ=no,max='**'),
             b_nume_ordre_i  =BLOC(condition = "NUME_ORDRE_I != None",
               regles=(EXCLUS('CHAM_NO','NOEUD'),),
# on devrait rajouter EXCLUS('GRANDEUR','CHAM_NO') pour eviter ambiguite car CHAM_NO => GRANDEUR='EFFO'
# cela impliquerait d'enlever la valeur par defaut a GRANDEUR
               NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**'),
               CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
               NOEUD           =SIMP(statut='f',typ=no,max='**'),
               b_noeud         =BLOC(condition = "NOEUD != None",
                  NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
                ),
               GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
# que se passe-t-il en cas d'incompatibilite entre GRANDEUR et NOM_CMP
               DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
             ),
             b_noeud_i       =BLOC(condition = "NOEUD_I != None",
               NOEUD_J         =SIMP(statut='o',typ=no,max='**'),
               NOM_CMP_I       =SIMP(statut='o',typ='TXM',max='**'),
               NOM_CMP_J       =SIMP(statut='o',typ='TXM',max='**'),
               NOEUD           =SIMP(statut='o',typ=no,max='**'),
               NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
# ne serait-il pas bien que NOEUD et NOM_CMP soient facultatifs, car l'information peut etre contenue dans
# NOEUD_I, NOM_CMP_I ...  => modif. du Fortran
               GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
# que se passe-t-il en cas d'incompatibilite entre GRANDEUR et NOM_CMP_I
               DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
             ),
           ),
           b_modal_oui = BLOC(condition = "(MODAL == 'OUI')",
# dans ce cas, y-a-t-il vraiment la possibilite d'une matrice interspectrale avec plusieurs termes
             NUME_ORDRE_I    =SIMP(statut='o',typ='I',max='**'),
             NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**'),
             GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
             DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
# dans le cas MODAL=OUI, GRANDEUR peut-il etre different de EFFO et doit il etre impose a EFFO   On devrait
# pouvoir supprimer GRANDEUR et DERIVATION ici
           ),

         ),
         REPONSE         =FACT(statut='f',
           regles=( ENSEMBLE('FREQ_MIN','FREQ_MAX'),),
           DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ,) ),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG") ),
           FREQ_MIN        =SIMP(statut='f',typ='R' ),
           FREQ_MAX        =SIMP(statut='f',typ='R' ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_defaut_freq   =BLOC(condition = "FREQ_MIN == NONE",
              FREQ_EXCIT      =SIMP(statut='f',typ='TXM',defaut="AVEC",into=("AVEC","SANS") ),
              NB_POIN_MODE    =SIMP(statut='f',typ='I',defaut= 50 ),
           ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr

def dyna_iss_vari_prod(self, FONC_SIGNAL,**args):
   if FONC_SIGNAL !=None :
       return tran_gene
   else:
      return  interspectre
   raise AsException("type de concept resultat non prevu")

DYNA_ISS_VARI=MACRO(nom="DYNA_ISS_VARI",
                    op=OPS('Macro.dyna_iss_vari_ops.dyna_iss_vari_ops'),
                    sd_prod=dyna_iss_vari_prod,
                    fr="Calcul du spectre de réponse ou de la reponse temporelle " \
                       "sismique incoherente par decomposition spectrale",
                    reentrant='n',
                    UIinfo={"groupes":("Outils métier",)},
         regles=(UN_PARMI('FONC_SIGNAL','NB_FREQ'),),
         FONC_SIGNAL     =SIMP(statut='f',typ=(fonction_sdaster) ),
         NB_FREQ       =SIMP(statut='f',typ='I' ),
         NOM_CMP       =SIMP(statut='o',typ='TXM',into=("DX","DY","DZ") ),
         PRECISION     =SIMP(statut='f',typ='R',defaut=0.999 ),
         ISSF          =SIMP(statut='f',typ='TXM',into=("OUI","NON",),defaut="NON"),
         INTERF           =FACT(statut='o',
              GROUP_NO_INTERF =SIMP(statut='o',typ=grno,),
              MODE_INTERF  =SIMP(statut='o',typ='TXM',into=("CORP_RIGI","TOUT","QUELCONQUE")),
         ),
         MATR_COHE       =FACT(statut='o',
              TYPE = SIMP(statut='o',typ='TXM' , into=("MITA_LUCO","ABRAHAMSON")   ),            
              b_type_coh = BLOC(condition="TYPE=='MITA_LUCO' ",
                 VITE_ONDE       =SIMP(statut='f',typ='R', defaut=600.),
                 PARA_ALPHA     =SIMP(statut='f',typ='R',defaut=0.5),),
         ),
#        LIST_FREQ        =SIMP(statut='o',typ='liste' ),
         UNITE_RESU_FORC = SIMP(statut='f',typ='I',defaut=33),
         UNITE_RESU_IMPE  = SIMP(statut='f',typ='I',defaut=32),
         TYPE             = SIMP(statut='f',typ='TXM', into=("BINAIRE","ASCII"), defaut="ASCII"),
#         NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","VITE","ACCE") , validators=NoRepeat(),max=3,defaut="DEPL" ),
#
         MATR_GENE         = FACT(statut='o',
            MATR_MASS     = SIMP(statut='o',typ=(matr_asse_gene_r ) ),
            MATR_RIGI     = SIMP(statut='o',typ=(matr_asse_gene_r,matr_asse_gene_c ) ),
            MATR_AMOR     = SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c ) ),
         ),
#
        INFO           =SIMP(statut='f',typ='I' ,defaut=1,into=( 1 , 2)),
#
         b_type_trans = BLOC(condition="FONC_SIGNAL !=None",
                        FREQ_MAX       =SIMP(statut='f',typ='R' ),
                        FREQ_PAS       =SIMP(statut='f',typ='R' ),
                        regles=( ENSEMBLE('FREQ_MAX','FREQ_PAS'),  )

                        ),

        b_type_spec = BLOC(condition="NB_FREQ != None",
                       FREQ_INIT       =SIMP(statut='o',typ='R' ),
                       FREQ_PAS     =SIMP(statut='o',typ='R' ),
                       OPTION        = SIMP(statut='f',typ='TXM',into=("TOUT","DIAG"),defaut="TOUT"),
                       ),


         )  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr
def dyna_line_harm_prod(MATR_RIGI,**args):
   if (AsType(MATR_RIGI) == matr_asse_depl_r) : return dyna_harmo
   elif (AsType(MATR_RIGI) == matr_asse_depl_c) : return dyna_harmo
   elif (AsType(MATR_RIGI) == matr_asse_pres_c) : return acou_harmo
   elif (AsType(MATR_RIGI) == matr_asse_gene_r) : return harm_gene
   elif (AsType(MATR_RIGI) == matr_asse_gene_c) : return harm_gene
   raise AsException("type de concept resultat non prevu")

DYNA_LINE_HARM=OPER(nom="DYNA_LINE_HARM",op=  60,sd_prod=dyna_line_harm_prod,
                    fr="Calcul de la réponse dynamique complexe d'un système à une excitation harmonique",
                    reentrant='f',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         regles=(PRESENT_ABSENT('MATR_AMOR','AMOR_MODAL'),
                 UN_PARMI('FREQ','LIST_FREQ'),),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
         MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r ) ),
         MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_pres_c
                                              ,matr_asse_gene_r,matr_asse_gene_c ) ),
         MATR_AMOR       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r ) ),
         AMOR_MODAL      =FACT(statut='f', max=1,
                    regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
                AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
                LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         ),
         MATR_IMPE_PHI   =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",)),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,into=("DEPL","VITE","ACCE") ),
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : RESULTAT obligatoire",
             RESULTAT      =SIMP(statut='o',typ=(dyna_harmo,harm_gene)),
         ),
         EXCIT           =FACT(statut='o',max='**',
           regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE','CHARGE'),
                   UN_PARMI('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),
                  ),
           VECT_ASSE       =SIMP(statut='f',position='global',typ=cham_no_sdaster),
           VECT_ASSE_GENE  =SIMP(statut='f',position='global',typ=vect_asse_gene),
           CHARGE          =SIMP(statut='f',position='global', typ=char_meca ),
           FONC_MULT_C     =SIMP(statut='f',typ=(fonction_c,formule_c) ),
           COEF_MULT_C     =SIMP(statut='f',typ='C' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           PHAS_DEG        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_PULS       =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         b_modele_char =BLOC(condition = " CHARGE != None ",
                       MODELE    =SIMP(statut='o',typ=modele_sdaster ),
                       ),
         b_modele_vect =BLOC(condition = " VECT_ASSE != None ",
                       MODELE    =SIMP(statut='f',typ=modele_sdaster ),
                       ),
         EXCIT_RESU      =FACT(statut='f',max='**',
           RESULTAT        =SIMP(statut='o',typ=(dyna_harmo,harm_gene)),
           COEF_MULT_C     =SIMP(statut='o',typ='C' ),
         ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         b_matr_gene =BLOC(condition = "AsType(MATR_MASS) in (matr_asse_gene_r,)",
                           fr="Methode de resolution matrice generalisee",
          SOLVEUR         =C_SOLVEUR('DYNA_LINE_HARM','GENE'),
         ),

         b_matr_phys =BLOC(condition = "AsType(MATR_MASS) in (matr_asse_depl_r,matr_asse_pres_c,)",
                           fr="Methode de resolution matrice sur ddl physique",
          SOLVEUR         =C_SOLVEUR('DYNA_LINE_HARM','PHYS'),
         ),
#-------------------------------------------------------------------

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
DYNA_LINE_TRAN=OPER(nom="DYNA_LINE_TRAN",op=  48,sd_prod=dyna_trans,
                    fr="Calcul de la réponse dynamique transitoire à une excitation temporelle quelconque",
                    reentrant='f',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
         MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),

         SCHEMA_TEMPS  =FACT(statut='d',
                SCHEMA =SIMP(statut='f',typ='TXM',defaut="NEWMARK",
                      into=("NEWMARK","WILSON","DIFF_CENTRE","ADAPT_ORDRE2")),
                b_newmark       =BLOC(condition="SCHEMA=='NEWMARK'",
                        BETA           =SIMP(statut='f',typ='R',defaut= 0.25 ),
                        GAMMA           =SIMP(statut='f',typ='R',defaut= 0.5 ),
                        ),
                b_wilson        =BLOC(condition="SCHEMA=='WILSON'",
                        THETA           =SIMP(statut='f',typ='R',defaut= 1.4 ),
                        ),
         ),

         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('RESULTAT', 'DEPL', 'VITE', 'ACCE'),
                   PRESENT_ABSENT('RESULTAT', 'DEPL', 'VITE', 'ACCE'),),
           RESULTAT     =SIMP(statut='f',typ=dyna_trans ),
           b_dyna_trans    =BLOC(condition = "RESULTAT != None",
             regles=(EXCLUS('NUME_ORDRE','INST_INIT' ),),
             NUME_ORDRE       =SIMP(statut='f',typ='I' ),
             INST_INIT       =SIMP(statut='f',typ='R' ),
             b_inst_init     =BLOC(condition = "INST_INIT != None",
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
             ),
           ),
           DEPL         =SIMP(statut='f',typ=cham_no_sdaster),
           VITE         =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE         =SIMP(statut='f',typ=cham_no_sdaster),
         ),
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('CHARGE','VECT_ASSE'),
                   EXCLUS('CHARGE','COEF_MULT'),
                   EXCLUS('FONC_MULT','COEF_MULT'),
                   EXCLUS('ACCE','COEF_MULT'),
                   PRESENT_ABSENT('ACCE','FONC_MULT'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   # PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),
                   ),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           CHARGE          =SIMP(statut='f',typ=char_meca ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           b_mult_appui     =BLOC(condition = "MULT_APPUI == 'OUI'",
           regles=(EXCLUS('NOEUD','GROUP_NO'),),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),),
###
         MODE_STAT       =SIMP(statut='f',typ=mode_meca),
###
         EXCIT_RESU      =FACT(statut='f',max='**',
           RESULTAT        =SIMP(statut='o',typ=dyna_trans ),
           COEF_MULT       =SIMP(statut='o',typ='R' ),
         ),
         AMOR_MODAL      =FACT(statut='f',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           AMOR_REDUIT     =SIMP(statut='o',typ='R',max='**'),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
         ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('DYNA_LINE_TRAN'),
#-------------------------------------------------------------------
         INCREMENT       =FACT(statut='o',max='**',
           regles=(UN_PARMI('LIST_INST','PAS'),),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_pas           =BLOC(condition = "PAS != None",
               INST_INIT       =SIMP(statut='f',typ='R' ),
               INST_FIN        =SIMP(statut='o',typ='R' ),
           ),
           b_list_fonc     =BLOC(condition = "LIST_INST != None",
               regles=(EXCLUS('INST_FIN','NUME_FIN'),),
               NUME_FIN        =SIMP(statut='f',typ='I' ),
               INST_FIN        =SIMP(statut='f',typ='R' ),
           ),
           VITE_MIN        =SIMP(statut='f',typ='TXM',defaut="NORM",into=("MAXI","NORM") ),
           COEF_MULT_PAS   =SIMP(statut='f',typ='R',defaut= 1.1 ),
           COEF_DIVI_PAS   =SIMP(statut='f',typ='R',defaut= 1.33334 ),
           PAS_LIMI_RELA   =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           NB_POIN_PERIODE =SIMP(statut='f',typ='I',defaut= 50 ),
           NMAX_ITER_PAS   =SIMP(statut='f',typ='I',defaut= 16 ),
           PAS_MINI         =SIMP(statut='f',typ='R' ),
         ),
         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),
         ARCHIVAGE       =FACT(statut='f',max=1,
           regles         = (EXCLUS('PAS_ARCH','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_ARCH       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                    PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                    PRECISION       =SIMP(statut='o',typ='R',),),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("DEPL","VITE","ACCE") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
#
DYNA_NON_LINE=OPER(nom="DYNA_NON_LINE",op= 70,sd_prod=evol_noli,reentrant='f',
            fr="Calcul de l'évolution dynamique d'une structure dont le matériau ou la géométrie ont un comportement non linéaire",
            UIinfo={"groupes":("Résolution","Dynamique",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         MASS_DIAG       =SIMP(statut='f',typ='TXM',into=("OUI","NON",) ),
         EXCIT           =FACT(statut='f',max='**',
           regles=(PRESENT_ABSENT('FONC_MULT','ACCE'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   # PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),
                   ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","SUIV","DIDI")),
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         EXCIT_GENE      =FACT(statut='f',max='**',
           FONC_MULT       =SIMP(statut='f',typ=fonction_sdaster,max='**' ),
           VECT_GENE       =SIMP(statut='f',typ=vect_asse_gene,max='**' ),
         ),
         CONTACT         =SIMP(statut='f',typ=char_contact),
         SOUS_STRUC      =FACT(statut='f',min=01,max='**',
                regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                SUPER_MAILLE=SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
                FONC_MULT   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
              ),
         AMOR_RAYL_RIGI = SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE"),),
         AMOR_MODAL      =FACT(statut='f',
           regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
           MODE_MECA       =SIMP(statut='f',typ=mode_meca),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**' ),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           REAC_VITE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         PROJ_MODAL      =FACT(statut='f',max='**',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           regles=(PRESENT_PRESENT('MASS_GENE','RIGI_GENE'),),
           MASS_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           RIGI_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           DEPL_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
           VITE_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
           ACCE_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene),
         ),
#-------------------------------------------------------------------
         COMPORTEMENT       =C_COMPORTEMENT('DYNA_NON_LINE'),
#-------------------------------------------------------------------
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : ETAT_INIT obligatoire",
         ETAT_INIT       =FACT(statut='o',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI',),
                 #  EXCLUS('EVOL_NOLI','DEPL',),
                 #  EXCLUS('EVOL_NOLI','VITE'),
                 #  EXCLUS('EVOL_NOLI','ACCE'),
                 #  EXCLUS('EVOL_NOLI','SIGM',),
                 #  EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           STRX            =SIMP(statut='f',typ=cham_elem),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
               PRECISION       =SIMP(statut='o',typ='R',),),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant : ETAT_INIT facultatif",
         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI',),
                 #  EXCLUS('EVOL_NOLI','DEPL',),
                 #  EXCLUS('EVOL_NOLI','VITE'),
                 #  EXCLUS('EVOL_NOLI','ACCE'),
                 #  EXCLUS('EVOL_NOLI','SIGM',),
                 #  EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
               PRECISION       =SIMP(statut='o',typ='R',),),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
#-------------------------------------------------------------------
         INCREMENT       =C_INCREMENT('MECANIQUE'),
#-------------------------------------------------------------------
         SCHEMA_TEMPS     =FACT(statut='o',
            SCHEMA          =SIMP(statut='o',min=1,max=1,typ='TXM',
            into=("DIFF_CENT","TCHAMWA","NEWMARK","HHT","THETA_METHODE","KRENK"),),
            COEF_MASS_SHIFT =SIMP(statut='f',typ='R',defaut= 0.0E+0 ),
            b_tchamwa = BLOC(condition="SCHEMA=='TCHAMWA'",
               PHI          =SIMP(statut='f',typ='R',defaut= 1.05),),

            b_newmark = BLOC(condition="SCHEMA=='NEWMARK'",
               BETA         =SIMP(statut='f',typ='R',defaut= 0.25),
               GAMMA        =SIMP(statut='f',typ='R',defaut= 0.5),),

            b_hht     = BLOC(condition="SCHEMA=='HHT'",
               ALPHA        =SIMP(statut='f',typ='R',defaut= -0.3 ),
               MODI_EQUI    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),),),

            b_theta   = BLOC(condition="SCHEMA=='THETA_METHODE'",
               THETA         =SIMP(statut='f',typ='R',defaut= 1.,val_min=0.5,val_max=100. ),),

            b_krenk   = BLOC(condition="SCHEMA=='KRENK'",
               KAPPA         =SIMP(statut='f',typ='R',defaut= 1.0,val_min=1.0,val_max=100. ),),

            b_explicit= BLOC(condition="SCHEMA=='TCHAMWA'or SCHEMA=='DIFF_CENT'",
               STOP_CFL     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),),
               FORMULATION  =SIMP(statut='o',typ='TXM',into=("ACCELERATION",),),),

            b_implicit= BLOC(condition="SCHEMA!='TCHAMWA'and SCHEMA!='DIFF_CENT'",
               FORMULATION  =SIMP(statut='o',max=1,typ='TXM',into=("DEPLACEMENT","VITESSE","ACCELERATION"),),),
         ),
#-------------------------------------------------------------------
         METHODE        =SIMP(statut='d',typ='TXM',defaut="NEWTON",into=("NEWTON","NEWTON_KRYLOV")),
         NEWTON          =C_NEWTON(),
#-------------------------------------------------------------------
         RECH_LINEAIRE   =C_RECH_LINEAIRE(),
#-------------------------------------------------------------------
         CONVERGENCE     =C_CONVERGENCE(),
#-------------------------------------------------------------------
         SOLVEUR         =C_SOLVEUR('DYNA_NON_LINE'),
#-------------------------------------------------------------------
         OBSERVATION     =C_OBSERVATION(),
#-------------------------------------------------------------------
         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),
#-------------------------------------------------------------------
         SUIVI_DDL       =C_SUIVI_DDL(),
#-------------------------------------------------------------------
         AFFICHAGE       =C_AFFICHAGE(),
#-------------------------------------------------------------------
         ARCHIVAGE       =C_ARCHIVAGE(),
#-------------------------------------------------------------------
         CRIT_STAB      =FACT(statut='f',min=1,max=1,
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,val_min=1,defaut=3),
           COEF_DIM_ESPACE =SIMP(statut='f',typ='I',max=1,val_min=2,defaut=5),
           RIGI_GEOM     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           MODI_RIGI     =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
           bloc_char_crit=BLOC(condition="(RIGI_GEOM=='OUI')",
              CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max=2,
                               fr="Valeur des deux charges critiques délimitant la bande de recherche en HPP"),),
           TYPE          =SIMP(statut='f',typ='TXM',defaut="FLAMBEMENT",into=("FLAMBEMENT","STABILITE")),
           PREC_INSTAB   =SIMP(statut='f',typ='R',defaut=1.E-6,max=1,),
           SIGNE         =SIMP(statut='f',typ='TXM',defaut=("POSITIF_NEGATIF"),into=("NEGATIF","POSITIF","POSITIF_NEGATIF"),max=1,),
           bloc_rigi_geom=BLOC(condition="(RIGI_GEOM=='NON'or MODI_RIGI=='OUI')",
              DDL_EXCLUS      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=40,
                                    into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                          'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                          'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                          'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                          'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                          'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                          'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                          'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                          'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG','DH')),
           bloc_type_stab =BLOC(condition= "TYPE == 'STABILITE' and RIGI_GEOM == 'NON'",
              DDL_STAB        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=40,
                                       into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                             'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                             'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                             'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                             'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                             'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                             'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                             'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                             'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG','DH')),),
                            ),
           regles         = (EXCLUS('PAS_CALC','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_CALC       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),
         MODE_VIBR     =FACT(statut='f',min=1,max=1,
           MATR_RIGI        =SIMP(statut='f',typ='TXM',defaut="ELASTIQUE",into=("ELASTIQUE","TANGENTE","SECANTE",) ),
           NB_FREQ          =SIMP(statut='f',typ='I',max=1,val_min=1,defaut=3,
                            fr="Nombre de fréquences propres à calculer"),
           COEF_DIM_ESPACE  =SIMP(statut='f',typ='I',max=1,val_min=2,defaut=5),
           BANDE            =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Valeur des deux fréquences délimitant la bande de recherche",),
           regles         = (EXCLUS('PAS_CALC','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_CALC       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         b_info=BLOC(condition="(INFO==2)",
               fr="filtre les messages émis dans le .mess selon le type de message demandé",
               INFO_DBG = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                               into=("CONTACT",
                                     "MECA_NON_LINE",
                                     "PILOTAGE",
                                     "FACTORISATION",
                                     "APPARIEMENT"),
                             ),
                    ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
DYNA_SPEC_MODAL=OPER(nom="DYNA_SPEC_MODAL",op= 147,sd_prod=interspectre,
                     fr="Calcul de la réponse par recombinaison modale d'une structure linéaire pour une excitation aléatoire",
                     reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         BASE_ELAS_FLUI  =SIMP(statut='o',typ=melasflu_sdaster ),
         VITE_FLUI      =SIMP(statut='o',typ='R'),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
         EXCIT           =FACT(statut='o',
           INTE_SPEC_GENE  =SIMP(statut='o',typ=interspectre),
         ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
DYNA_TRAN_MODAL=OPER(nom="DYNA_TRAN_MODAL",op=  74,sd_prod=tran_gene,
                     fr="Calcul de la reponse dynamique transitoire d'un systeme amorti ou non en coordonees generalisees"
                        +" par superposition modale ou par sous structuration",
                     reentrant='f',
            UIinfo={"groupes":("Resolution","Dynamique",)},
      regles=(EXCLUS('AMOR_MODAL','MATR_AMOR'),
              PRESENT_ABSENT('MODE_STAT','MODE_CORR'),),
          SCHEMA_TEMPS  =FACT(statut='d',
                SCHEMA  =SIMP(statut='f',typ='TXM',defaut="NEWMARK",
  into=("NEWMARK","EULER","DEVOGE","ADAPT_ORDRE1","ADAPT_ORDRE2","ITMI","RUNGE_KUTTA_54","RUNGE_KUTTA_32")),
                b_newmark     =BLOC(condition="SCHEMA=='NEWMARK'",
                        BETA           =SIMP(statut='f',typ='R',defaut= 0.25 ),
                        GAMMA           =SIMP(statut='f',typ='R',defaut= 0.5 ),
                        ),
                b_runge_kutta     =BLOC(condition="SCHEMA=='RUNGE_KUTTA_54' or SCHEMA=='RUNGE_KUTTA_32'",
                        TOLERANCE           =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
                        ),
                b_itmi          =BLOC(condition = "SCHEMA=='ITMI'",
               regles=(ENSEMBLE('BASE_ELAS_FLUI','NUME_VITE_FLUI'),),
                BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
                NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
                ETAT_STAT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                PREC_DUREE      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
                CHOC_FLUI       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                NB_MODE         =SIMP(statut='f',typ='I' ),
                NB_MODE_FLUI    =SIMP(statut='f',typ='I' ),
                TS_REG_ETAB     =SIMP(statut='f',typ='R' ),
         ),
         ),
         MATR_MASS       =SIMP(statut='o',typ=matr_asse_gene_r ),
         MATR_RIGI       =SIMP(statut='o',typ=matr_asse_gene_r ),
         MATR_AMOR       =SIMP(statut='f',typ=matr_asse_gene_r ),
         VITESSE_VARIABLE     =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         b_variable          =BLOC(condition="VITESSE_VARIABLE=='OUI'",
               MATR_GYRO       =SIMP(statut='o',typ=matr_asse_gene_r ),
               VITE_ROTA       =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
               MATR_RIGY       =SIMP(statut='f',typ=matr_asse_gene_r ),
               ACCE_ROTA       =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
           ),
         b_constante         =BLOC(condition="VITESSE_VARIABLE=='NON'",
               VITE_ROTA          = SIMP(statut='o',typ='R',defaut=0.E0),
               COUPLAGE_EDYOS     =FACT(statut='f',max=1,
                                   PAS_TPS_EDYOS      = SIMP(statut='o',typ='R' ),
         ),
               
           ),
               
         AMOR_MODAL      =FACT(statut='f', max=1,
                    regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
                AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
                LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         ),

         ROTOR_FISS = FACT(statut='f',max='**',
                           regles=(UN_PARMI('NOEUD_D','GROUP_NO_D'),
                                   EXCLUS('NOEUD_G','GROUP_NO_G'),
                                   PRESENT_PRESENT('NOEUD_D','NOEUD_G'),
                                   PRESENT_PRESENT('GROUP_NO_D','GROUP_NO_G',),),
                             ANGL_INIT          = SIMP(statut='o',typ='R',defaut=0.E0),
                             ANGL_ROTA          = SIMP(statut='f',typ=(fonction_sdaster,formule) ),
                             NOEUD_G            = SIMP(statut='f',typ=no),
                             NOEUD_D            = SIMP(statut='f',typ=no),
                             GROUP_NO_G         = SIMP(statut='f',typ=grno),
                             GROUP_NO_D         = SIMP(statut='f',typ=grno),
                             K_PHI              = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                             DK_DPHI            = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
         ),

         PALIER_EDYOS      =FACT(statut='f',max='**',
         regles=(PRESENT_ABSENT('UNITE','GROUP_NO'),
                 PRESENT_ABSENT('UNITE','TYPE_EDYOS'),
                 EXCLUS('GROUP_NO','NOEUD'),),
                                     UNITE       = SIMP(statut='f',typ='I',),
                                     GROUP_NO    = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                                     NOEUD       = SIMP(statut='f',typ=no),
                                     TYPE_EDYOS  = SIMP(statut='f',typ='TXM',
                                     into=("PAPANL","PAFINL","PACONL","PAHYNL",),),
         ),

         ETAT_INIT       =FACT(statut='f',
           regles=(EXCLUS('RESULTAT','DEPL'),
                   EXCLUS('RESULTAT','VITE'),),
           RESULTAT   =SIMP(statut='f',typ=tran_gene ),
           b_resu     =BLOC(condition = "RESULTAT != None",
           regles=(EXCLUS('NUME_ORDRE','INST_INIT' ),),
             INST_INIT       =SIMP(statut='f',typ='R' ),
             NUME_ORDRE      =SIMP(statut='f',typ='I' ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                PRECISION       =SIMP(statut='o',typ='R',),),
           ),
           DEPL  =SIMP(statut='f',typ=vect_asse_gene ),
           VITE  =SIMP(statut='f',typ=vect_asse_gene ),
         ),
         INCREMENT       =FACT(statut='o',max='**',
           regles=(UN_PARMI('LIST_INST','PAS'),),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           b_list_inst         =BLOC(condition = "LIST_INST != None",
           regles=(EXCLUS('NUME_FIN','INST_FIN'),),
               NUME_FIN       =SIMP(statut='f',typ='I' ),
               INST_FIN        =SIMP(statut='f',typ='R' ),
           ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_pas           =BLOC(condition = "PAS != None",
               INST_INIT       =SIMP(statut='f',typ='R' ),
               INST_FIN        =SIMP(statut='o',typ='R' ),
           ),
           VERI_PAS        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           VITE_MIN        =SIMP(statut='f',typ='TXM',defaut="NORM",into=("MAXI","NORM") ),
           COEF_MULT_PAS   =SIMP(statut='f',typ='R',defaut= 1.1 ),
           COEF_DIVI_PAS   =SIMP(statut='f',typ='R',defaut= 1.3333334 ),
           PAS_LIMI_RELA   =SIMP(statut='f',typ='R',defaut= 1.0E-6 ),
           NB_POIN_PERIODE =SIMP(statut='f',typ='I',defaut= 50 ),
           NMAX_ITER_PAS   =SIMP(statut='f',typ='I',defaut= 16 ),
           PAS_MAXI         =SIMP(statut='f',typ='R' ),
           PAS_MINI         =SIMP(statut='f',typ='R' ),
         ),
         ARCHIVAGE       =FACT(statut='f',max=1,
           regles         = (EXCLUS('PAS_ARCH','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_ARCH       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                    PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                    PRECISION       =SIMP(statut='o',typ='R',),),
         ),
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('FONC_MULT','COEF_MULT','ACCE'),
                   UN_PARMI('VECT_ASSE_GENE','NUME_ORDRE',),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
#                   PRESENT_ABSENT('NUME_ORDRE','VECT_ASSE_GENE','COEF_MULT'),
                   EXCLUS('MULT_APPUI','CORR_STAT'),
                   PRESENT_PRESENT('MULT_APPUI','ACCE'),),
           VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
           NUME_ORDRE      =SIMP(statut='f',typ='I' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           b_mult_appui     =BLOC(condition = "MULT_APPUI == 'OUI'",
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
             regles=(EXCLUS('NOEUD','GROUP_NO'),),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           ),
           CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           b_corr_stat     =BLOC(condition = "CORR_STAT == 'OUI'",
           D_FONC_DT       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           D_FONC_DT2      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),),

         MODE_STAT       =SIMP(statut='f',typ=mode_meca ),
         MODE_CORR       =SIMP(statut='f',typ=(mult_elas,mode_meca),),

         EXCIT_RESU      =FACT(statut='f',max='**',
           RESULTAT        =SIMP(statut='o',typ=tran_gene ),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut=1.0 ),
         ),

         CHOC            =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD_1','GROUP_NO_1' ),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('GROUP_MA','NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('MAILLE','NOEUD_2','GROUP_NO_2'),),
           INTITULE        =SIMP(statut='f',typ='TXM' ),
           GROUP_MA        =SIMP(statut='f',typ=grma,max='**'),
           MAILLE          =SIMP(statut='f',typ=ma,max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',min=3,max=3),
           NORM_OBST       =SIMP(statut='o',typ='R',min=3,max=3),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           DIST_2          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           SOUS_STRUC_1    =SIMP(statut='f',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='f',typ='TXM' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           AMOR_NOR        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           AMOR_TAN        =SIMP(statut='f',typ='R' ),
           FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","COULOMB","COULOMB_STAT_DYNA") ),
           b_coulomb       =BLOC(condition="FROTTEMENT=='COULOMB'",
               COULOMB         =SIMP(statut='o',typ='R' ),),
           b_coulomb_stat_dyna  =BLOC(condition="FROTTEMENT=='COULOMB_STAT_DYNA'",
               COULOMB_STAT    =SIMP(statut='o',typ='R' ),
               COULOMB_DYNA    =SIMP(statut='o',typ='R' ),),
         ),
         VERI_CHOC       =FACT(statut='f',
           STOP_CRITERE    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 0.5 ),
         ),
         FLAMBAGE        =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',max='**'),
           NORM_OBST       =SIMP(statut='o',typ='R',max='**'),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R' ),
           DIST_2          =SIMP(statut='f',typ='R' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           FNOR_CRIT       =SIMP(statut='f',typ='R' ),
           FNOR_POST_FL    =SIMP(statut='f',typ='R' ),
           RIGI_NOR_POST_FL=SIMP(statut='f',typ='R' ),
         ),
         ANTI_SISM       =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   UN_PARMI('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           RIGI_K1         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_K2         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           SEUIL_FX        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           C               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_ALPHA      =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           DX_MAX          =SIMP(statut='f',typ='R',defaut= 1. ),
         ),
         RELA_EFFO_DEPL  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         RELA_EFFO_VITE  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         IMPRESSION      =FACT(statut='f',
           regles=(EXCLUS('TOUT','NIVEAU'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NIVEAU          =SIMP(statut='f',typ='TXM',into=("DEPL_LOC","VITE_LOC","FORC_LOC","TAUX_CHOC") ),
           INST_INIT       =SIMP(statut='f',typ='R' ),
           INST_FIN        =SIMP(statut='f',typ='R' ),
         ),


#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('DYNA_TRAN_MODAL'),
#-------------------------------------------------------------------

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
 )  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: albert.alarcon at edf.fr

#choix de structure de donnees de sortie en fonction de BASE_CALCUL et TYPE_CALCUL
def dyna_vibra_prod(self,BASE_CALCUL,TYPE_CALCUL,MATR_RIGI,**args):
        if BASE_CALCUL == 'PHYS':
          if TYPE_CALCUL == 'TRAN': return dyna_trans
          else:
              if (AsType(MATR_RIGI) == matr_asse_pres_c) : return acou_harmo
              else: return dyna_harmo
        else:
          if TYPE_CALCUL == 'TRAN': return tran_gene
          else: return harm_gene

#from Macro.dyna_vibra_ops import dyna_vibra_ops

DYNA_VIBRA=MACRO(nom="DYNA_VIBRA",
                 op=OPS('Macro.dyna_vibra_ops.dyna_vibra_ops'),
#                 op=dyna_vibra_ops,
                 sd_prod=dyna_vibra_prod,
                 reentrant='f',
                 fr="Calcul dynamique",
                 UIinfo={"groupes":("Resolution","Dynamique",)},
        BASE_CALCUL     =SIMP(statut='o',typ='TXM',position='global',into=("PHYS","GENE") ),
        TYPE_CALCUL     =SIMP(statut='o',typ='TXM',position='global',into=("HARM","TRAN") ),

#parametres de mise en donnees
        b_donnees    =BLOC(condition = "TYPE_CALCUL=='HARM'or (TYPE_CALCUL=='TRAN' and BASE_CALCUL=='PHYS')",
            MODELE          =SIMP(statut='f',typ=modele_sdaster ),
            CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
            CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
        ),
        b_matr_tran_phys    =BLOC(condition = "TYPE_CALCUL=='TRAN' and BASE_CALCUL=='PHYS'",
            MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r),
            MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r),
            MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r),
        ),
        b_matr_tran_gene    =BLOC(condition = "TYPE_CALCUL=='TRAN' and BASE_CALCUL=='GENE'",
            MATR_MASS       =SIMP(statut='o',typ=matr_asse_gene_r),
            MATR_RIGI       =SIMP(statut='o',typ=matr_asse_gene_r),
            MATR_AMOR       =SIMP(statut='f',typ=matr_asse_gene_r),
            VITESSE_VARIABLE     =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
            b_variable          =BLOC(condition="VITESSE_VARIABLE=='OUI'",
               MATR_GYRO       =SIMP(statut='o',typ=matr_asse_gene_r ),
               VITE_ROTA       =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
               MATR_RIGY       =SIMP(statut='f',typ=matr_asse_gene_r ),
               ACCE_ROTA       =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
            ),
            b_constante         =BLOC(condition="VITESSE_VARIABLE=='NON'",
               VITE_ROTA          = SIMP(statut='o',typ='R',defaut=0.E0),
            ),
        ),
        b_reuse_harm =BLOC(condition = "reuse and TYPE_CALCUL == 'HARM'",fr="en mode concept reentrant : RESULTAT obligatoire",
             RESULTAT      =SIMP(statut='o',typ=(dyna_harmo,harm_gene)),
            ),
        b_matr_harm     =BLOC(condition="TYPE_CALCUL == 'HARM'",
            MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r ) ),
            MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_pres_c
                                              ,matr_asse_gene_r,matr_asse_gene_c )),
            MATR_AMOR       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r) ),
            MATR_IMPE_PHI       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
        ),

        AMOR_MODAL      =FACT(statut='f',
            AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
            LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           b_mode    =BLOC(condition = "BASE_CALCUL == 'PHYS' and TYPE_CALCUL == 'TRAN'",
            MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
            NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
            ),
         ),
#introduction parametres du calcul harmonique
        b_param_harm      =BLOC(condition="TYPE_CALCUL == 'HARM'",
           regles=(UN_PARMI('FREQ','LIST_FREQ'),
                   EXCLUS('NOM_CHAM','TOUT_CHAM')),
        FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
        LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
        NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,into=("DEPL","VITE","ACCE") ),
        TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",)),
        ),

#parametrage des calculs transitoires
        b_tran = BLOC(condition = "TYPE_CALCUL == 'TRAN'",
#parametrage des schemas d'integration
        SCHEMA_TEMPS    =FACT(statut='d',
        SCHEMA           =SIMP(statut='f',typ='TXM',defaut="NEWMARK",
          into=("NEWMARK","WILSON","ADAPT_ORDRE2","DIFF_CENTRE","ADAPT_ORDRE1","DEVOGE","EULER","ITMI","RUNGE_KUTTA_54","RUNGE_KUTTA_32"),),
          b_itmi         =BLOC(condition = "SCHEMA == 'ITMI'",
regles=(ENSEMBLE('BASE_ELAS_FLUI','NUME_VITE_FLUI'),),
                BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
                NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
                ETAT_STAT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                PREC_DUREE      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
                CHOC_FLUI       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                NB_MODE         =SIMP(statut='f',typ='I' ),
                NB_MODE_FLUI    =SIMP(statut='f',typ='I' ),
                TS_REG_ETAB     =SIMP(statut='f',typ='R' ),
            ),
          b_newmark       =BLOC(condition = "SCHEMA == 'NEWMARK'",
                BETA           =SIMP(statut='f',typ='R',defaut= 0.25 ),
                GAMMA           =SIMP(statut='f',typ='R',defaut= 0.5 ),
            ),
          b_wilson        =BLOC(condition = "SCHEMA == 'WILSON'",
                THETA           =SIMP(statut='f',typ='R',defaut= 1.4 ),
            ),
          b_runge_kutta     =BLOC(condition="SCHEMA=='RUNGE_KUTTA_54' or SCHEMA=='RUNGE_KUTTA_32'",
                TOLERANCE           =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
            ),
          ),

        INCREMENT       =FACT(statut='o',
           regles=(UN_PARMI('LIST_INST','PAS'),),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_pas           =BLOC(condition = "PAS != None",
               INST_INIT       =SIMP(statut='f',typ='R' ),
               INST_FIN        =SIMP(statut='o',typ='R' ),
             ),
           b_list     =BLOC(condition = "LIST_INST != None",
               regles=(EXCLUS('INST_FIN','NUME_FIN'),),
               NUME_FIN        =SIMP(statut='f',typ='I' ),
               INST_FIN        =SIMP(statut='f',typ='R' ),
             ),
           b_veri_pas = BLOC(condition="BASE_CALCUL == 'GENE'",
           VERI_PAS       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PAS_MAXI        =SIMP(statut='f',typ='R' ),
             ),
           VITE_MIN        =SIMP(statut='f',typ='TXM',defaut="NORM",into=("MAXI","NORM") ),
           COEF_MULT_PAS   =SIMP(statut='f',typ='R',defaut= 1.1 ),
           COEF_DIVI_PAS   =SIMP(statut='f',typ='R',defaut= 1.3333334 ),
           PAS_LIMI_RELA   =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           NB_POIN_PERIODE =SIMP(statut='f',typ='I',defaut= 50 ),
           NMAX_ITER_PAS   =SIMP(statut='f',typ='I',defaut= 16 ),
           PAS_MINI        =SIMP(statut='f',typ='R' ),
         ),

#declaration de l'etat initial
       b_init_gene     =BLOC(condition="BASE_CALCUL == 'GENE'",
        ETAT_INIT       =FACT(statut='f',
               regles=(EXCLUS('RESULTAT','DEPL'),
                   EXCLUS('RESULTAT','VITE'),),
             RESULTAT      =SIMP(statut='f',typ=tran_gene),
                b_resu            =BLOC(condition = "RESULTAT != NONE",
                   regles=( EXCLUS('NUME_ORDRE','INST_INIT' ),),
             NUME_ORDRE =SIMP(statut='f',typ='I' ),
             INST_INIT       =SIMP(statut='f',typ='R' ),
                        b_inst_init     =BLOC(condition = "INST_INIT != None",
             CRITERE        =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION    =SIMP(statut='f',typ='R',defaut= 1.E-6,),
                              ),
                        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION     =SIMP(statut='o',typ='R',),
                              ),
                        ),
                  ),
             DEPL          =SIMP(statut='f',typ=vect_asse_gene),
             VITE       =SIMP(statut='f',typ=vect_asse_gene),
              ),
        ),
        b_init_phys     =BLOC(condition="BASE_CALCUL == 'PHYS'",
        ETAT_INIT       =FACT(statut='f',
              regles=(AU_MOINS_UN('RESULTAT', 'DEPL', 'VITE', 'ACCE'),
                   PRESENT_ABSENT('RESULTAT', 'DEPL', 'VITE', 'ACCE'),),
             RESULTAT      =SIMP(statut='f',typ=dyna_trans),
                b_resu            =BLOC(condition = "RESULTAT != NONE",
                   regles=( EXCLUS('NUME_ORDRE','INST_INIT' ),),
             NUME_ORDRE =SIMP(statut='f',typ='I' ),
             INST_INIT       =SIMP(statut='f',typ='R' ),
                        b_inst_init     =BLOC(condition = "INST_INIT != None",
             CRITERE        =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION    =SIMP(statut='f',typ='R',defaut= 1.E-6,),
                              ),
                        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION     =SIMP(statut='o',typ='R',),
                              ),
                        ),
                  ),
             DEPL          =SIMP(statut='f',typ=cham_no_sdaster),
             VITE       =SIMP(statut='f',typ=cham_no_sdaster),
             ACCE       =SIMP(statut='f',typ=cham_no_sdaster),
              ),
        ),
#parametres d'archivage
        bloc_archi      =BLOC(condition="TYPE_CALCUL == 'TRAN'",
        ARCHIVAGE       =FACT(statut='f',max=1,
            regles=(EXCLUS('LIST_INST','PAS_ARCH','INST'),),
                LIST_INST       = SIMP(statut='f',typ=(listr8_sdaster) ),
                INST            = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
                PAS_ARCH        = SIMP(statut='f',typ='I' ),
                CRITERE         = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                   b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                        PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                   b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                        PRECISION       =SIMP(statut='o',typ='R',),),

                b_cham_exclu  =BLOC(condition="BASE_CALCUL == 'PHYS'",
                        CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("DEPL","VITE","ACCE") ),
                ),
        ),),),

#calcul des energies
        bloc_ener       =BLOC(condition="TYPE_CALCUL == 'TRAN' and BASE_CALCUL == 'PHYS'",
         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),
        ),

#definition du chargement
        b_excit_harm    =BLOC(condition="TYPE_CALCUL == 'HARM'",
          EXCIT           =FACT(statut='o',max='**',
           regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE','CHARGE'),
                   UN_PARMI('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),
                  ),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene),
           CHARGE          =SIMP(statut='f', typ=char_meca ),
           FONC_MULT_C     =SIMP(statut='f',typ=(fonction_c,formule_c) ),
           COEF_MULT_C     =SIMP(statut='f',typ='C' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           PHAS_DEG        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_PULS       =SIMP(statut='f',typ='I',defaut= 0 ),

         ),
          EXCIT_RESU       =FACT(statut='f',max='**',
           RESULTAT     =SIMP(statut='o',typ=(dyna_harmo,harm_gene) ),
           COEF_MULT_C     =SIMP(statut='o',typ='C' ),),

         ),
        b_excit_tran_mod=BLOC(condition="TYPE_CALCUL == 'TRAN' and BASE_CALCUL == 'GENE'",
        regles=(PRESENT_ABSENT('MODE_STAT','MODE_CORR'),),
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('FONC_MULT','COEF_MULT','ACCE'),
                   UN_PARMI('VECT_ASSE_GENE','NUME_ORDRE',),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   EXCLUS('MULT_APPUI','CORR_STAT'),
                   PRESENT_PRESENT('MULT_APPUI','ACCE'),
                   ),
           VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
           NUME_ORDRE      =SIMP(statut='f',typ='I' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           b_mult_appui     =BLOC(condition = "MULT_APPUI == 'OUI'",
           regles=(EXCLUS('NOEUD','GROUP_NO'),),
                  DIRECTION       =SIMP(statut='f',typ='R',max='**'),
                  NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                  GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           ),
           CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           b_corr_stat     =BLOC(condition = "CORR_STAT == 'OUI'",
                  D_FONC_DT       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                  D_FONC_DT2      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          ),
         ),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca ),
         MODE_CORR       =SIMP(statut='f',typ=(mult_elas,mode_meca),),

         EXCIT_RESU       =FACT(statut='f',max='**',
           RESULTAT     =SIMP(statut='o',typ=tran_gene ),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut=1.0 ),
                                ),

        ),
        b_excit_line_tran =BLOC(condition="TYPE_CALCUL == 'TRAN' and BASE_CALCUL == 'PHYS'",
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('CHARGE','VECT_ASSE'),
                   EXCLUS('CHARGE','COEF_MULT'),
                   EXCLUS('FONC_MULT','COEF_MULT'),
                   EXCLUS('ACCE','COEF_MULT'),
                   PRESENT_ABSENT('ACCE','FONC_MULT'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   ),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           CHARGE          =SIMP(statut='f',typ=char_meca ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           b_mult_appui     =BLOC(condition = "MULT_APPUI == 'OUI'",
            regles=(EXCLUS('NOEUD','GROUP_NO'),),
                   DIRECTION       =SIMP(statut='f',typ='R',max='**'),
                   NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                   GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
          ),
        ),
        MODE_STAT       =SIMP(statut='f',typ=mode_meca ),
        EXCIT_RESU       =FACT(statut='f',
           RESULTAT     =SIMP(statut='o',typ=dyna_trans ),
           COEF_MULT       =SIMP(statut='o',typ='R' ),
        ),
       ),

#definition des chocs
        b_non_line_loca =BLOC(condition="TYPE_CALCUL == 'TRAN' and BASE_CALCUL=='GENE'",
        CHOC            =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD_1','GROUP_NO_1' ),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('GROUP_MA','NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('MAILLE','NOEUD_2','GROUP_NO_2'),),
           INTITULE        =SIMP(statut='f',typ='TXM' ),
           GROUP_MA        =SIMP(statut='f',typ=grma,max='**'),
           MAILLE          =SIMP(statut='f',typ=ma,max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',min=3,max=3),
           NORM_OBST       =SIMP(statut='o',typ='R',min=3,max=3),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           DIST_2          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           SOUS_STRUC_1    =SIMP(statut='f',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='f',typ='TXM' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           AMOR_NOR        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           AMOR_TAN        =SIMP(statut='f',typ='R' ),
           FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","COULOMB","COULOMB_STAT_DYNA") ),
           b_coulomb       =BLOC(condition="FROTTEMENT=='COULOMB'",
               COULOMB         =SIMP(statut='o',typ='R' ),),
           b_coulomb_stat_dyna  =BLOC(condition="FROTTEMENT=='COULOMB_STAT_DYNA'",
               COULOMB_STAT    =SIMP(statut='o',typ='R' ),
               COULOMB_DYNA    =SIMP(statut='o',typ='R' ),),
           ),
        VERI_CHOC       =FACT(statut='f',
           STOP_CRITERE    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 0.5 ),
         ),

         ROTOR_FISS = FACT(statut='f',max='**',
                           regles=(UN_PARMI('NOEUD_D','GROUP_NO_D'),
                                   EXCLUS('NOEUD_G','GROUP_NO_G'),
                                   PRESENT_PRESENT('NOEUD_D','NOEUD_G'),
                                   PRESENT_PRESENT('GROUP_NO_D','GROUP_NO_G',),),
                             ANGL_INIT          = SIMP(statut='o',typ='R',defaut=0.E0),
                             ANGL_ROTA          = SIMP(statut='f',typ=(fonction_sdaster,formule) ),
                             NOEUD_G            = SIMP(statut='f',typ=no),
                             NOEUD_D            = SIMP(statut='f',typ=no),
                             GROUP_NO_G         = SIMP(statut='f',typ=grno),
                             GROUP_NO_D         = SIMP(statut='f',typ=grno),
                             K_PHI              = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                             DK_DPHI            = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
         ),

#parametres flambage
        FLAMBAGE        =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',max='**'),
           NORM_OBST       =SIMP(statut='o',typ='R',max='**'),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R' ),
           DIST_2          =SIMP(statut='f',typ='R' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           FNOR_CRIT       =SIMP(statut='f',typ='R' ),
           FNOR_POST_FL    =SIMP(statut='f',typ='R' ),
           RIGI_NOR_POST_FL=SIMP(statut='f',typ='R' ),
         ),

#non-linearite si dispositif anti-sismique
        ANTI_SISM       =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   UN_PARMI('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           RIGI_K1         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_K2         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           SEUIL_FX        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           C               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_ALPHA      =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           DX_MAX          =SIMP(statut='f',typ='R',defaut= 1. ),
         ),
#non-linearite effort-deplacement
        RELA_EFFO_DEPL  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
#non-linearite effort-vitesse
        RELA_EFFO_VITE  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
        ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         b_solv_harm_gene =BLOC(condition = "BASE_CALCUL=='GENE' and TYPE_CALCUL=='HARM'",
                           fr="Methode de resolution matrice generalisee",
        SOLVEUR         =C_SOLVEUR('DYNA_LINE_HARM','GENE'),
         ),
         b_solv_harm_phys =BLOC(condition = "BASE_CALCUL=='PHYS' and TYPE_CALCUL=='HARM'",
                           fr="Methode de resolution matrice sur ddl physique",
        SOLVEUR         =C_SOLVEUR('DYNA_LINE_HARM','PHYS'),
         ),
         b_solv_line_tran      =BLOC(condition = "BASE_CALCUL=='PHYS' and TYPE_CALCUL=='TRAN'",
        SOLVEUR         =C_SOLVEUR('DYNA_LINE_TRAN'),
          ),
         b_solv_tran_gene      =BLOC(condition = "BASE_CALCUL=='GENE' and TYPE_CALCUL=='TRAN'",
        SOLVEUR         =C_SOLVEUR('DYNA_TRAN_MODAL'),
          ),
#-------------------------------------------------------------------
        TITRE           =SIMP(statut='f',typ='TXM',max='**'),
        INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
        b_impression = BLOC(condition = "BASE_CALCUL=='GENE' and TYPE_CALCUL=='TRAN'",
        IMPRESSION      =FACT(statut='f',
           regles=(EXCLUS('TOUT','NIVEAU'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NIVEAU          =SIMP(statut='f',typ='TXM',into=("DEPL_LOC","VITE_LOC","FORC_LOC","TAUX_CHOC") ),
           INST_INIT       =SIMP(statut='f',typ='R' ),
           INST_FIN        =SIMP(statut='f',typ='R' ),
         ),
         ),
        );

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def elim_lagr_prod(MATR_RIGI,**args):
  if AsType(MATR_RIGI) == matr_asse_depl_r : return matr_asse_depl_r
  raise AsException("type de concept resultat non prevu")

ELIM_LAGR=OPER(nom="ELIM_LAGR",op=69,sd_prod=elim_lagr_prod,
               fr="Créer une matrice en ayant éliminé les condition cinématiques dualisées.",
               reentrant='f', UIinfo={"groupes":("Résolution",)},

         # Matrice de "rigidité" (celle qui contient les équations dualisées) :
         MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,) ),

         # Matrice à réduire (si ce n'est pas la matrice de rigidité) :
         MATR_ASSE       =SIMP(statut='f',typ=(matr_asse_depl_r,) ),


         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
ENGENDRE_TEST=PROC(nom="ENGENDRE_TEST",op=178,
                   UIinfo={"groupes":("Impression","Utilitaires",)},
                   fr="Engendre des tests pour la non régression du code (pour développeurs)",
         UNITE           =SIMP(statut='f',typ='I',defaut=8),
         FORMAT          =SIMP(statut='f',typ='TXM',into=("OBJET",) ),
         FORMAT_R        =SIMP(statut='f',typ='TXM',defaut="1PE20.13"),
         PREC_R          =SIMP(statut='f',typ='TXM',defaut="1.E-10"),
#============================================================================
         b_aster     =BLOC( condition = "FORMAT==None",
            CO              =SIMP(statut='o',typ=(cham_gd_sdaster,resultat_sdaster,table_sdaster),
                                  validators=NoRepeat(),max='**'),
            TYPE_TEST       =SIMP(statut='f',typ='TXM',defaut="SOMM_ABS",into=("SOMME","SOMM_ABS","MAX","MIN") ),
         ),
#============================================================================
         b_objet     =BLOC( condition = "FORMAT=='OBJET'",
                            regles=(UN_PARMI('TOUT','CO'),),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            CO              =SIMP(statut='f',typ=assd,validators=NoRepeat(),max='**'),
            TYPE_TEST       =SIMP(statut='f',typ='TXM',defaut="SOMME",into=("SOMME",) ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
# 
#  ENVOI DES CHAMPS CINEMATIQUES VIA YACS POUR COUPLAGE IFS 
#
ENV_CINE_YACS=PROC(nom             = "ENV_CINE_YACS",
                   op              = 111,
                   UIinfo          = {"groupes":("Résultats et champs",)},
                   fr              = "Envoi des champs de deplacement et vitesse via YACS pour Couplage de Code_Aster et Saturne",
                   regles          = (EXCLUS('ETAT_INIT','RESULTAT',),),
                   MATR_PROJECTION = SIMP(statut='o', typ=corresp_2_mailla,),
                   VIS_A_VIS = FACT(statut='o', max='**',
                                   GROUP_MA_1=SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                                   GROUP_NO_2=SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),),
                   RESULTAT  = FACT(statut='f',
                                   NUME_ORDRE=SIMP(statut='o', typ='I',              validators=NoRepeat()),
                                   RESU      =SIMP(statut='o', typ=resultat_sdaster, validators=NoRepeat()),),
                   ETAT_INIT = FACT(statut='f',
                                    DEPL=SIMP(statut='f', typ=cham_no_sdaster,  validators=NoRepeat()),
                                    VITE=SIMP(statut='f', typ=cham_no_sdaster,  validators=NoRepeat()),
                                    ACCE=SIMP(statut='f', typ=cham_no_sdaster,  validators=NoRepeat()),),
                   INST         = SIMP(statut='o',typ='R', ),
                   PAS             = SIMP(statut='o',typ='R', ),
                   NUME_ORDRE_YACS = SIMP(statut='o', typ='I',),
                   INFO            = SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
) ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr

def exec_logiciel_prod(self, MAILLAGE, **args):
   if MAILLAGE != None:
      mcf = MAILLAGE[0]
      self.type_sdprod(mcf['MAILLAGE'], maillage_sdaster)
   return None

EXEC_LOGICIEL = MACRO(nom="EXEC_LOGICIEL",
                      op=OPS('Macro.exec_logiciel_ops.exec_logiciel_ops'),
                      sd_prod=exec_logiciel_prod,
                      fr="Exécute un logiciel ou une commande système depuis Aster",
                      UIinfo={"groupes":("Gestion du travail","Outils-métier",)},

      regles = ( AU_MOINS_UN('LOGICIEL', 'MAILLAGE', 'SALOME'),
                 EXCLUS('MACHINE_DISTANTE','MAILLAGE'),
                 EXCLUS('MAILLAGE','SALOME'),
                 ),

      LOGICIEL = SIMP(statut='f', typ='TXM'),
      ARGUMENT = SIMP(statut='f', max='**', typ='TXM'),


      MACHINE_DISTANTE = FACT(statut='f',
        SSH_ADRESSE  = SIMP(statut='o', typ='TXM', val_min=1, val_max=255,
                           fr="Adresse IP ou nom de la machine sur laquelle le logiciel/script sera exécuté via SSH"),
        SSH_LOGIN    = SIMP(statut='f', typ='TXM', val_min=1, val_max=255,
                           fr="Nom d'utilisateur sur la machine distante"),
        SSH_PORT     = SIMP(statut='f', typ='I', val_min=1, val_max=65535, defaut=22,
                           fr="Port SSH de la machien distante"),
      ),


      MAILLAGE = FACT(statut='f',
         FORMAT     = SIMP(statut='o', typ='TXM', into=("GMSH", "GIBI", "SALOME")),
         UNITE_GEOM = SIMP(statut='f', typ='I', val_min=10, val_max=90, defaut=16,
                           fr="Unité logique définissant le fichier (fort.N) contenant les données géométriques (datg)"),
         UNITE      = SIMP(statut='f', typ='I', val_min=10, val_max=90, defaut=19,
                           fr="Unité logique définissant le fichier (fort.N) produit par le mailleur"),
         MAILLAGE   = SIMP(statut='o', typ=CO),
      ),


      SALOME = FACT(statut='f',
           regles=(UN_PARMI('CHEMIN_SCRIPT', 'UNITE_SCRIPT'),
                   PRESENT_PRESENT('NOM_PARA','VALE'),),
         CHEMIN_SCRIPT     = SIMP(statut='f', typ='TXM',
                               fr="Chemin du script Salome"),
         UNITE_SCRIPT      = SIMP(statut='f', typ='I', val_min=80, val_max=99,
                               fr="Unité logique du script Salome"),
         SALOME_HOST       = SIMP(statut='f', typ='TXM', defaut='localhost',
                               fr="Machine sur laquelle tourne Salome"),
         SALOME_PORT       = SIMP(statut='f', typ='I', val_min=2800, val_max=2900, defaut=2810,
                               fr="Port de l'instance Salome (2810 ou supérieur)"),
         SALOME_RUNAPPLI   = SIMP(statut='f', typ='TXM',
                               fr="Chemin vers le script de lancement runAppli de Salome"),
         FICHIERS_ENTREE   = SIMP(statut='f', typ='TXM', validators=NoRepeat(),max='**',
                               fr="Liste des fichiers d'entrée du script Salome"),
         FICHIERS_SORTIE   = SIMP(statut='f', typ='TXM', validators=NoRepeat(),max='**',
                               fr="Liste des fichiers générés par le script Salome"),
         NOM_PARA          = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                               fr="Liste des noms des paramètres à modifier dans le script Salome"),
         VALE              = SIMP(statut='f',typ='TXM',max='**',
                               fr="Valeur des paramètres à) modifier dans le script Salome"),
      ),

      CODE_RETOUR_MAXI = SIMP(statut='f', typ='I', defaut=0, val_min=-1,
                              fr="Valeur maximale du code retour toléré (-1 pour l'ignorer)"),

      INFO     = SIMP(statut='f', typ='I', defaut=2, into=(1,2),),
)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr

def extr_mode_prod(FILTRE_MODE,**args):
  vale=FILTRE_MODE[0]['MODE']
  if AsType(vale) == mode_meca   : return mode_meca
  if AsType(vale) == mode_meca_c : return mode_meca_c
  if AsType(vale) == mode_gene   : return mode_gene
  raise AsException("type de concept resultat non prevu")

EXTR_MODE=OPER(nom="EXTR_MODE",op= 168,sd_prod=extr_mode_prod,
               reentrant='n',fr="Extraire séléctivement des modes des structures de données modales",
            UIinfo={"groupes":("Résolution","Dynamique",)},
         FILTRE_MODE     =FACT(statut='o',max='**',
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','NUME_MODE','NUME_MODE_EXCLU','FREQ_MIN','CRIT_EXTR',),),
           MODE            =SIMP(statut='o',typ=(mode_meca,mode_meca_c,mode_gene ) ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE_EXCLU =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           FREQ_MIN        =SIMP(statut='f',typ='R' ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',into=("MASS_EFFE_UN","MASS_GENE") ),
           b_freq_min      =BLOC(condition = "FREQ_MIN != None",  
             FREQ_MAX        =SIMP(statut='o',typ='R' ),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
           b_crit_extr     =BLOC(condition = "CRIT_EXTR != None",
             regles=(AU_MOINS_UN('SEUIL','SEUIL_X','SEUIL_Y','SEUIL_Z'),),
             SEUIL           =SIMP(statut='f',typ='R'),
             SEUIL_X         =SIMP(statut='f',typ='R'),
             SEUIL_Y         =SIMP(statut='f',typ='R'),
             SEUIL_Z         =SIMP(statut='f',typ='R'),
           ),    
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         IMPRESSION      =FACT(statut='f',
           CUMUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",into=("MASS_EFFE_UN","MASS_GENE") ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr

def extr_resu_prod(RESULTAT,**args):
  if AsType(RESULTAT) == evol_elas    : return evol_elas
  if AsType(RESULTAT) == evol_noli    : return evol_noli
  if AsType(RESULTAT) == evol_ther    : return evol_ther
  if AsType(RESULTAT) == evol_varc    : return evol_varc
  if AsType(RESULTAT) == dyna_trans   : return dyna_trans
  if AsType(RESULTAT) == dyna_harmo   : return dyna_harmo
  if AsType(RESULTAT) == acou_harmo   : return acou_harmo
  if AsType(RESULTAT) == mode_meca    : return mode_meca
  if AsType(RESULTAT) == mode_acou    : return mode_acou
  if AsType(RESULTAT) == mult_elas    : return mult_elas
  if AsType(RESULTAT) == fourier_elas : return fourier_elas

  raise AsException("type de concept resultat non prevu")

EXTR_RESU=OPER(nom="EXTR_RESU",op=176,sd_prod=extr_resu_prod,reentrant='f',
            UIinfo={"groupes":("Résultats et champs",)},
            fr="Extraire des champs au sein d'une SD Résultat",
         RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,dyna_harmo,acou_harmo,mode_meca,
                                               mode_acou,evol_ther,evol_noli,evol_varc,
                                               mult_elas,fourier_elas,fourier_ther ) ),


         ARCHIVAGE       =FACT(statut='f',
           regles=(  UN_PARMI('NUME_ORDRE', 'INST', 'FREQ', 'NUME_MODE',
                        'NOEUD_CMP', 'LIST_INST', 'LIST_FREQ', 'LIST_ORDRE',
                        'NOM_CAS', 'LIST_ARCH', 'PAS_ARCH' ),
                     EXCLUS( 'CHAM_EXCLU','NOM_CHAM' ),   ),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO()),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           PAS_ARCH        =SIMP(statut='f',typ='I'),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
           NOM_CAS         =SIMP(statut='f',typ='TXM'),
                               ),

         RESTREINT   =FACT(statut='f', max=1,
            fr="Pour réduire une ou plusieurs sd_resultat sur un maillage ou un modèle réduit",
            regles=(UN_PARMI('MAILLAGE','MODELE'),),
            MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
            MODELE          =SIMP(statut='f',typ=modele_sdaster),
            ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def extr_table_prod(TYPE_RESU,**args):
  defs = globals()
  typ = TYPE_RESU.lower()
  if defs.get(typ) is not None:
     return defs[typ]
  raise AsException("type de concept resultat non prevu")

EXTR_TABLE=OPER(nom="EXTR_TABLE",
                op=173,
                sd_prod=extr_table_prod,
                reentrant='n',
                UIinfo={"groupes":("Résultats et champs","Tables")},
                fr="Extraire d'une table des concepts Code_Aster",
         TYPE_RESU       =SIMP(statut='o',typ='TXM',
                               into=('MATR_ASSE_GENE_R', 'MATR_ELEM_DEPL_R',
                                     'VECT_ELEM_DEPL_R',
                                     'CHAM_GD_SDASTER', 'CHAM_NO_SDASTER',
                                     'CARTE_SDASTER', 'CHAM_ELEM',
                                     'MODE_MECA','TABLE_SDASTER',
                                     'FONCTION_SDASTER', 'FONCTION_C', 'NAPPE_SDASTER',
                                     'ENTIER', 'REEL'),),

         TABLE           =SIMP(statut='o',typ=(table_sdaster,table_container)),

         NOM_PARA        =SIMP(statut='o',typ='TXM'),

         FILTRE          =FACT(statut='f',min=1,max='**',
           NOM_PARA        =SIMP(statut='o',typ='TXM'),
           CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                 into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                       "NON_VIDE","MAXI","MAXI_ABS","MINI","MINI_ABS") ),
           b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
              regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
              VALE            =SIMP(statut='f',typ='R'),
              VALE_I          =SIMP(statut='f',typ='I'),
              VALE_C          =SIMP(statut='f',typ='C'),
              VALE_K          =SIMP(statut='f',typ='TXM'),),

           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def factoriser_prod(MATR_ASSE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r : return matr_asse_depl_r
  if AsType(MATR_ASSE) == matr_asse_depl_c : return matr_asse_depl_c
  if AsType(MATR_ASSE) == matr_asse_temp_r : return matr_asse_temp_r
  if AsType(MATR_ASSE) == matr_asse_temp_c : return matr_asse_temp_c
  if AsType(MATR_ASSE) == matr_asse_pres_r : return matr_asse_pres_r
  if AsType(MATR_ASSE) == matr_asse_pres_c : return matr_asse_pres_c
  raise AsException("type de concept resultat non prevu")

FACTORISER=OPER(nom="FACTORISER",op=14,sd_prod=factoriser_prod,
               fr="Factoriser une matrice assemblée en un produit de deux matrices triangulaires"+
                  "ou construire une matrice de préconditionnement pour une résolution par gradient conjugué",
               reentrant='f', UIinfo={"groupes":("Résolution",)},
         regles=(EXCLUS('BLOC_DEBUT','DDL_DEBUT'),
                 EXCLUS('BLOC_FIN','DDL_FIN'),),
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),

         # mots clés pour solveur LDLT et MULT_FRONT et MUMPS:
         STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NPREC           =SIMP(statut='f',typ='I',defaut=8),

         # mots clés pour solveur LDLT :
         BLOC_DEBUT      =SIMP(statut='f',typ='I',val_min=1,),
         DDL_DEBUT       =SIMP(statut='f',typ='I',val_min=1,),
         BLOC_FIN        =SIMP(statut='f',typ='I',val_min=1,),
         DDL_FIN         =SIMP(statut='f',typ='I',val_min=1,),

         # mots clés pour solveur MUMPS :
         TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut='AUTO',into=('NONSYM','SYMGEN','SYMDEF','AUTO')),
         PRETRAITEMENTS  =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
         PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=20,),
         ELIM_LAGR       =SIMP(statut='f',typ='TXM',defaut="LAGR2",into=("LAGR2","NON")),
         GESTION_MEMOIRE =SIMP(statut='f',typ='TXM',defaut="IP_CORE",into=("IP_CORE","OUT_OF_CORE","EVAL")),

         # mots clés pour solveur GCPC et PETSc :
         PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC","JACOBI","SOR","LDLT_SP"),defaut="LDLT_INC" ),
         b_ldlt_inc     =BLOC(condition = "PRE_COND == 'LDLT_INC' ",
           NIVE_REMPLISSAGE = SIMP(statut='f',typ='I',defaut= 0 ),
           REMPLISSAGE      = SIMP(statut='f',typ='R',defaut= 1.0),
         ),
         b_ldlt_sp      =BLOC(condition = "PRE_COND == 'LDLT_SP' ", fr="Paramètres de la factorisation simple précision",
           REAC_PRECOND        =SIMP(statut='f',typ='I',defaut=30, ),
         ),
         b_jacobi_sor   =BLOC(condition = "PRE_COND == 'JACOBI' or PRE_COND == 'SOR'",
                                                                         fr="Paramètres des préconditionneurs JACOBI et SOR",
           RENUM               =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","RCMK") ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
FIN=PROC(nom="FIN",op=9999,repetable='n',fr="Fin d'une étude, fin du travail engagé par une des commandes DEBUT ou POURSUITE",
            UIinfo={"groupes":("Gestion du travail",)},
#
# FIN est appelé prématurément en cas d'exception ("SIGUSR1", ArretCPUError,
# NonConvergenceError..., erreurs <S> ou erreurs <F> récupérées).
# En cas d'ArretCPUError, on limite au maximum le travail à faire dans FIN.
# Pour cela, on force certains mots-clés dans Execution/E_JDC.py.
# 
         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
                               typ='TXM',defaut="NON",into=("OUI","NON",) ), 
         RETASSAGE       =SIMP(fr="provoque le retassage de la base GLOBALE",
                               statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
         INFO_RESU       =SIMP(fr="provoque l'impression des informations sur les structures de données",
                               statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",) ),
         UNITE           =SIMP(statut='f',typ='I',defaut=6),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
FONC_FLUI_STRU=OPER(nom="FONC_FLUI_STRU",op= 169,sd_prod=fonction_sdaster,
                    reentrant='n',fr="Crée une fonction constante paramétrée par l'abscisse curviligne",
            UIinfo={"groupes":("Fonctions",)},
         TYPE_FLUI_STRU  =SIMP(statut='o',typ=(type_flui_stru) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def formule_prod(self, VALE, VALE_C, **args):
    if VALE != None:
        return formule
    elif VALE_C != None:
        return formule_c

FORMULE=FORM(nom="FORMULE",
             op_init=ops.build_formule,
             op=-5,
             sd_prod=formule_prod,
             UIinfo={"groupes":("Fonctions",)},
             fr="Définit une formule réelle ou complexe à partir de son expression mathématique",
    regles = (UN_PARMI('VALE', 'VALE_C',),),
    VALE     = SIMP(statut='f', typ='TXM'),
    VALE_C   = SIMP(statut='f', typ='TXM'),
    NOM_PARA = SIMP(statut='o', typ='TXM', max='**'),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
GENE_ACCE_SEISME=MACRO(nom="GENE_ACCE_SEISME",
                     op=OPS('Macro.gene_acce_seisme_ops.gene_acce_seisme_ops'),
                     sd_prod=table_fonction,
                     fr="Generation d'accelerogrammes sismiques ",
                     reentrant='n',
                     UIinfo={"groupes":("Fonctions","Dynamique",)},

         INIT_ALEA       =SIMP(statut='f',typ='I'),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         PAS_INST        =SIMP(statut='o',typ='R' ),
         NB_POIN           =SIMP(statut='f',typ='I',fr="nombre de points" ),
         PESANTEUR         =SIMP(statut='o', typ='R', fr="constante de normalisation de ACCE_MAX, ECART_TYPE et INTE_ARIAS (g) ou le spectre" ),
         DUREE_PHASE_FORTE =SIMP(statut='o',typ='R',fr="durée phase forte du signal" ),
         NB_TIRAGE        =SIMP(statut='f',typ='I',defaut= 1,fr="nombre accelerogrammes" ),
         FREQ_FILTRE       =SIMP(statut='f',typ='R',fr="frequence du filtre: corner frequency"),
#
         DSP        = FACT(statut='f',max=1,     
            AMOR_REDUIT   =SIMP(statut='o',typ='R'),
            FREQ_FOND     =SIMP(statut='o',typ='R', fr="frequence centrale"),
            FREQ_PENTE    =SIMP(statut='f',typ='R',  fr="pente pour l'evolution de la frequence centrale"),        
        ),
         SPEC_MEDIANE    = FACT(statut='f',max=1,
        regles=(ENSEMBLE('ERRE_ZPA','ERRE_MAX','ERRE_RMS'),EXCLUS('FREQ_PAS','LIST_FREQ'),),
            SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster),),
            AMOR_REDUIT     =SIMP(statut='o', typ='R', val_min=0., val_max=1.),
            FREQ_PAS      =SIMP(statut='f',typ='R' , fr="pas"),      
            LIST_FREQ       =SIMP(statut='f', typ=listr8_sdaster ),            
            NB_ITER      =SIMP(statut='f',typ='I' ,defaut=0, val_min=0,fr="nombre d'iterations pour fitter le spectre"  ,),
            ERRE_ZPA      =SIMP(statut='f',typ='R' ,defaut=(1.,0.2), min=1,max=2,  fr="coef et erreur maxi ZPA",),
            ERRE_MAX      =SIMP(statut='f',typ='R' ,defaut=(0.5,0.2), min=1,max=2,  fr="coef et erreur maxi global",),
            ERRE_RMS      =SIMP(statut='f',typ='R' ,defaut=(0.5,0.2), min=1,max=2,  fr="coef et erreur maxi rms",),
            FREQ_PENTE    =SIMP(statut='f',typ='R',  fr="pente pour l'evolution de la frequence centrale"), 
            METHODE         =SIMP(statut='f',typ='TXM',defaut="HARMO",into=("NIGAM","HARMO") ),            
        ),
         SPEC_UNIQUE    = FACT(statut='f',max=1,
        regles=(ENSEMBLE('ERRE_ZPA','ERRE_MAX','ERRE_RMS'),EXCLUS('FREQ_PAS','LIST_FREQ'),),
            ERRE_ZPA      =SIMP(statut='f',typ='R' ,defaut=(1.,0.2), min=1,max=2,  fr="coef et erreur maxi ZPA",),
            ERRE_MAX      =SIMP(statut='f',typ='R' ,defaut=(0.5,0.2), min=1,max=2,  fr="coef et erreur maxi global",),
            ERRE_RMS      =SIMP(statut='f',typ='R' ,defaut=(0.5,0.2), min=1,max=2,  fr="coef et erreur maxi rms",),
            SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster),),
            AMOR_REDUIT     =SIMP(statut='o', typ='R', val_min=0., val_max=1.),
            FREQ_PAS      =SIMP(statut='f',typ='R' , fr="pas"),
            LIST_FREQ       =SIMP(statut='f', typ=listr8_sdaster ),
            NB_ITER      =SIMP(statut='f',typ='I' ,defaut=0, val_min=0,fr="nombre d'iterations pour fitter le spectre" ,),
            METHODE         =SIMP(statut='f',typ='TXM',defaut="HARMO",into=("NIGAM","HARMO") ),    
        ),
#       
         SPEC_FRACTILE    = FACT(statut='f',max=1,
        regles=(ENSEMBLE('ERRE_ZPA','ERRE_MAX','ERRE_RMS'), EXCLUS('FREQ_PAS','LIST_FREQ'),),
            SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster),),
            SPEC_1_SIGMA       =SIMP(statut='o',typ=(fonction_sdaster),),  
            AMOR_REDUIT     =SIMP(statut='o', typ='R', val_min=0., val_max=1.),
            FREQ_PAS      =SIMP(statut='f',typ='R' , fr="pas"),    
            LIST_FREQ       =SIMP(statut='f', typ=listr8_sdaster ),               
           FREQ_PENTE    =SIMP(statut='f',typ='R',  fr="pente pour l'evolution de la frequence centrale"),           
        ),


         regles=(UN_PARMI('DSP','SPEC_MEDIANE','SPEC_UNIQUE','SPEC_FRACTILE'),),    
         MODULATION      = FACT(statut='o',max=1, 
            regles=(EXCLUS('ACCE_MAX','INTE_ARIAS','ECART_TYPE'),),         
            TYPE         = SIMP(statut='o',typ='TXM' , into=("GAMMA","JENNINGS_HOUSNER","CONSTANT")),
            ACCE_MAX     = SIMP(statut='f',typ='R',fr="PGA: acceleration max au sol (g)" ),
            ECART_TYPE   = SIMP(statut='f',typ='R',fr="ecart-type" ),
            INTE_ARIAS   = SIMP(statut='f',typ='R',fr="intensite d'Arias" ),
              c_type_mod   = BLOC(condition="TYPE=='GAMMA' ",
                           INST_INI     = SIMP(statut='o',typ='R',fr="instant debut phase forte" ),
                            ),
            ),
)  ;
 

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
GENE_FONC_ALEA=OPER(nom="GENE_FONC_ALEA",op= 118,sd_prod=table_fonction,
                    fr="Génération de la fonction temporelle à partir d une matrice interspectrale",
                    reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
         INTE_SPEC       =SIMP(statut='o',typ=interspectre),
         NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("NON","OUI") ),
         b_interpol_oui    =BLOC(condition = "INTERPOL == 'OUI' ",fr="Parametres cas interpolation autorisee",
           DUREE_TIRAGE    =SIMP(statut='f',typ='R' ),
           FREQ_INIT       =SIMP(statut='f',typ='R' ),
           FREQ_FIN        =SIMP(statut='f',typ='R' ),
             ),
         NB_POIN         =SIMP(statut='f',typ='I'),
         NB_TIRAGE       =SIMP(statut='f',typ='I',defaut= 1 ),
         INIT_ALEA       =SIMP(statut='f',typ='I'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
def gene_matr_alea_prod(MATR_MOYEN,**args ):
  if (AsType(MATR_MOYEN) == matr_asse_gene_r )  : return matr_asse_gene_r
  if (AsType(MATR_MOYEN) == macr_elem_dyna) : return macr_elem_dyna
  raise AsException("type de concept resultat non prevu")

GENE_MATR_ALEA=OPER(nom="GENE_MATR_ALEA",op=  27,
#sd_prod=matr_asse_gene_r,
sd_prod=gene_matr_alea_prod,
               fr="Générer une réalisation d'une matrice aléatoire réelle sym. déf. positive ou d'un macro élément dynamique",
               reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
   MATR_MOYEN   = SIMP(statut='o', typ=(matr_asse_gene_r,macr_elem_dyna)),

#    cas matrice generalisee
   b_matr =BLOC( condition = "AsType(MATR_MOYEN) in (matr_asse_gene_r,)",
           COEF_VAR     = SIMP(statut='f', typ='R', defaut=0.1, val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice a generer" ),
           ),
#    cas macr_elem_dyna
   b_macr =BLOC( condition = "AsType(MATR_MOYEN) in (macr_elem_dyna,)",
           fr="cas macr_elem_dyna (sous-structuratio)",
           COEF_VAR_RIGI     = SIMP(statut='f', typ='R', defaut=0.1, val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice de raideur" ),
           COEF_VAR_MASS     = SIMP(statut='f', typ='R', defaut=0., val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice de masse" ),
           COEF_VAR_AMOR     = SIMP(statut='f', typ='R', defaut=0., val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice d'amortissement" ),),

   INIT_ALEA    =SIMP(statut='f',typ='I'),
) ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr

GENE_VARI_ALEA=MACRO(nom="GENE_VARI_ALEA",
                     op_init=ops.build_gene_vari_alea,
                     op=EMPTY_OPS,
                     sd_prod=reel,
                     reentrant='n',
                     fr="Générer une réalisation d'une variable aléatoire réelle " \
                        "de loi de probabilité donnée (Gamma ou Exponentielle)",
                     UIinfo={"groupes":("Fonctions",)},
   TYPE       = SIMP(statut='f', typ='TXM', into=("EXP_TRONQUEE", "EXPONENTIELLE", "GAMMA"), defaut="GAMMA"),
   b_gamma    =BLOC(condition = "TYPE == 'GAMMA' ",fr="Parametres loi gamma",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=1.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=0.),
           COEF_VAR   = SIMP(statut='f', typ='R', defaut=0.1),
             ),
   b_expo    =BLOC(condition = "TYPE == 'EXPONENTIELLE' ",fr="Parametres loi exponentielle",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=0.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=-1.),
             ),
   b_expo_tronq    =BLOC(condition = "TYPE == 'EXP_TRONQUEE' ",fr="Parametres loi exponentielle tronquee",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=0.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=-1.),
           BORNE_SUP  = SIMP(statut='f', typ='R', defaut=1.),
             ),
   INIT_ALEA       =SIMP(statut='f',typ='I'),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
IMPR_CO=PROC(nom="IMPR_CO",op=17,
            UIinfo={"groupes":("Impression","Utilitaires",)},
             fr="Imprimer tous les objets JEVEUX qui constituent un concept utilisateur existant (pour les développeurs)",
         regles=(UN_PARMI('CONCEPT','CHAINE','TOUT' ),),

         UNITE           =SIMP(statut='f',typ='I',defaut=8),
         NIVEAU          =SIMP(statut='f',typ='I',defaut=2,into=(-1,0,1,2) ),
         ATTRIBUT        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","OUI") ),
         CONTENU         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("NON","OUI") ),
         BASE            =SIMP(statut='f',typ='TXM',defaut="G",into=(" ","G","V","L") ),
         CONCEPT    =FACT(statut='f',max='**',
             NOM         =SIMP(statut='o',typ=assd,validators=NoRepeat(),max='**'),),        
         CHAINE          =SIMP(statut='f',typ='TXM'),
         POSITION        =SIMP(statut='f',typ='I',defaut=1),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
#


IMPR_DIAG_CAMPBELL=MACRO(nom="IMPR_DIAG_CAMPBELL",
                         op=OPS('Macro.impr_diag_campbell_ops.impr_diag_campbell_ops'),
                         fr="Tracé du Diagramme de Campbell",
                         UIinfo={"groupes":("Impression","Outils-métier",)},
            MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
            MODES           =SIMP(statut='o',typ=table_container),
            NFREQ_CAMP      =SIMP(statut='o',typ='I' ),
            TYP_PREC        =SIMP(statut='f',typ='I',defaut= 1, into=(1,2) ),
            TYP_TRI         =SIMP(statut='f',typ='I',defaut= 2, into=(0,1,2) ),
            UNIT_FLE        =SIMP(statut='o',typ='I' ,val_min=1),
            UNIT_TOR        =SIMP(statut='o',typ='I' ,val_min=1),
            UNIT_LON        =SIMP(statut='o',typ='I' ,val_min=1),
            UNIT_TOT        =SIMP(statut='o',typ='I' ,val_min=1),
            UNIT_INT        =SIMP(statut='o',typ='I' ,val_min=1),
            L_S             =SIMP(statut='f',typ='R', defaut= 1., max='**'),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

IMPR_FONCTION=MACRO(nom="IMPR_FONCTION",
                    op=OPS('Macro.impr_fonction_ops.impr_fonction_ops'),
                    sd_prod=None,
                    fr="Imprime le contenu d'objets de type fonction ou liste de " \
                       "réels dans un fichier destiné à un traceur de courbe",
                    UIinfo={"groupes":("Impression","Fonctions",)},
         FORMAT          =SIMP(statut='o',typ='TXM',position='global',defaut='TABLEAU',
                               into=("TABLEAU","AGRAF","XMGRACE",),),
         b_pilote = BLOC(condition = "FORMAT == 'XMGRACE'",
                        fr="Mots-clés propres à XMGRACE",
           PILOTE          =SIMP(statut='f',typ='TXM',defaut='',
                                 into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),
                            fr="Pilote de sortie, PNG/JPEG/PDF ne sont pas disponibles sur toutes les installations de xmgrace"),
           UNITE           =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
         ),
         b_agraf = BLOC(condition = "FORMAT == 'AGRAF'",
                        fr="Mots-clés propres à AGRAF",
           UNITE           =SIMP(statut='o',typ='I',defaut=25,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
           UNITE_DIGR      =SIMP(statut='o',typ='I',defaut=26,
                                 fr="Unité logique définissant le fichier dans lequel on écrit les directives Agraf"),
         ),
         # unite pour TABLEAU dans le bloc de mise en forme spécifique

         COURBE          =FACT(statut='o',max='**',fr="Définition de la fonction à tracer",
           regles=(UN_PARMI('FONCTION','LIST_RESU','FONC_X','ABSCISSE'),),
           FONCTION        =SIMP(statut='f',typ=(fonction_sdaster, formule, fonction_c, nappe_sdaster),
                                 fr="Fonction réelle ou complexe", ),
           LIST_RESU       =SIMP(statut='f',typ=listr8_sdaster,
                                 fr="Liste des ordonnees d'une fonction réelle définie par deux listes", ),
           FONC_X          =SIMP(statut='f',typ=(fonction_sdaster,formule),
                                 fr="Fonction abscisses d'une fonction paramétrique",),
           ABSCISSE        =SIMP(statut='f',typ='R',max='**',
                                 fr="Valeurs des abscisses", ),
           b_fonction      =BLOC(condition = "FONCTION != None",
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
           ),
           b_fonction_c  =BLOC(condition = "AsType(FONCTION) in (fonction_c, formule_c)",
                                 fr="Fonction complexe définie par le mot-clé fonction",
             PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
           ),
           b_list_resu     =BLOC(condition = "LIST_RESU != None",
             LIST_PARA       =SIMP(statut='o',typ=listr8_sdaster ),
           ),
           b_fonc_x        =BLOC(condition = "FONC_X != None",
             FONC_Y          =SIMP(statut='o',typ=(fonction_sdaster,formule),fr="Fonction ordonnées d une fonction paramétrique" ),
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
           ),
           b_vale_resu     =BLOC(condition = "ABSCISSE != None",
             ORDONNEE      =SIMP(statut='o',typ='R',max='**',
                                 fr="Valeurs des ordonnées"),
           ),

           # mots-clés utilisant uniquement aux formats autres que TABLEAU
           # mais ce serait trop pénible de devoir les supprimer quand on change de format
           # donc on ne les met pas dans un bloc
           # "pseudo" bloc mise en forme :
               LEGENDE         =SIMP(statut='f',typ='TXM',
                                    fr="Légende associée à la fonction" ),
               STYLE           =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Style de la ligne représentant la fonction",),
               COULEUR         =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Couleur associée à la fonction",),
               MARQUEUR        =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Type du marqueur associé à la fonction",),
               FREQ_MARQUEUR   =SIMP(statut='f',typ='I',defaut=0,
                                    fr="Fréquence d impression du marqueur associé à la fonction", ),
           # fin bloc mise en forme

           TRI             =SIMP(statut='f',typ='TXM',defaut="N",
                                 fr="Choix du tri effectué sur les abscisses ou sur les ordonnées",
                                 into=("N","X","Y","XY","YX") ),
         ),
         # Mise en page du tableau ou du graphique
         b_tableau = BLOC(condition = "FORMAT == 'TABLEAU'",
                          fr="Mots-clés propres au format Tableau",
           UNITE           =SIMP(statut='o',typ='I',defaut=8,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
           TITRE           =SIMP(statut='f',typ='TXM',
                                 fr="Titre associé au graphique" ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',
                                 fr="Sous-titre du graphique" ),
           SEPARATEUR      =SIMP(statut='f',typ='TXM',defaut=' ',
                                 fr="Séparateur des colonnes du tableau (ex : ' ', ';'...)"),
           COMMENTAIRE     =SIMP(statut='f',typ='TXM',defaut='#',
                                 fr="Caractère indiquant au traceur de fonction que la ligne peut etre ignorée"),
           COMM_PARA       =SIMP(statut='f',typ='TXM',defaut='',
                                 fr="Caractère utilisé pour commentariser la ligne des labels de colonnes"),
           DEBUT_LIGNE     =SIMP(statut='f',typ='TXM',defaut='',
                                 fr="Caractère de debut de ligne"),
           FIN_LIGNE       =SIMP(statut='f',typ='TXM',defaut='\n',
                                 fr="Caractère de fin de ligne"),
         ),
         b_graphique = BLOC(condition = "FORMAT != 'TABLEAU'",
                        fr="Mise en page du graphique",
           TITRE           =SIMP(statut='f',typ='TXM',
                                 fr="Titre associé au graphique" ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',
                                 fr="Sous-titre du graphique" ),
           BORNE_X         =SIMP(statut='f',typ='R',min=2,max=2,
                                 fr="Intervalles de variation des abscisses"),
           BORNE_Y         =SIMP(statut='f',typ='R',min=2,max=2,
                                 fr="Intervalles de variation des ordonnées"),
           ECHELLE_X       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                                 fr="Type d'échelle pour les abscisses" ),
           ECHELLE_Y       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                                 fr="Type d'échelle pour les ordonnées" ),
           GRILLE_X        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                                 fr="Pas du quadrillage vertical" ),
           GRILLE_Y        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                                 fr="Pas du quadrillage horizontal" ),
           LEGENDE_X       =SIMP(statut='f',typ='TXM',
                                 fr="Légende associée à l'axe des abscisses" ),
           LEGENDE_Y       =SIMP(statut='f',typ='TXM',
                                 fr="Légende associée à l'axe des ordonnées" ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
IMPR_GENE=PROC(nom="IMPR_GENE",op= 157,
            fr="Imprimer le résultat d'un calcul dynamique en variables généralisées au format RESULTAT",
            UIinfo={"groupes":("Impression","Dynamique",)},
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",into=("RESULTAT",) ),
         UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         GENE            =FACT(statut='o',max='**',
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_MODE','TOUT_INST','LIST_ORDRE'),
                   EXCLUS('TOUT_MODE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_ORDRE','TOUT_INST','LIST_ORDRE'),
                   EXCLUS('TOUT_INST','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_ORDRE','LIST_ORDRE'),
                   EXCLUS('TOUT_CMP_GENE','NUME_CMP_GENE'),
                   EXCLUS('TOUT_CHAM','NOM_CHAM'),
                   EXCLUS('TOUT_PARA','NOM_PARA'),),
#  faut-il faire des blocs selon le type de RESU_GENE                   
           RESU_GENE       =SIMP(statut='o',typ=(vect_asse_gene, tran_gene, mode_gene, harm_gene)),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           TOUT_MODE       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),
           TOUT_CMP_GENE   =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NUME_CMP_GENE   =SIMP(statut='f',typ='I',max='**'),
           TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(),),
           TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           INFO_CMP_GENE   =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           INFO_GENE       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
IMPR_JEVEUX=PROC(nom="IMPR_JEVEUX",op=16,
            UIinfo={"groupes":("Impression","Utilitaires",)},
                 fr="Imprimer le contenu des objets créés par JEVEUX (pour développeur)",
         ENTITE          =SIMP(fr="choix de l'observation",statut='o',typ='TXM',
                               into=("DISQUE","MEMOIRE","REPERTOIRE",    
                                     "OBJET","ATTRIBUT","SYSTEME","ENREGISTREMENT") ),
         b_objet      =BLOC(condition = "(ENTITE=='OBJET')",
            NOMOBJ          =SIMP(fr="nom d'objet",statut='f',typ='TXM' ),  
            NUMOC           =SIMP(fr="numéro d objet de collection",statut='f',typ='I' ),  
            NOMOC           =SIMP(fr="nom d'objet de collection",statut='f',typ='TXM' ),  
         ),
         b_attribut   =BLOC(condition = "(ENTITE=='ATTRIBUT')",
            NOMOBJ          =SIMP(fr="nom de collection",statut='f',typ='TXM' ),  
            NOMATR          =SIMP(fr="nom d attribut de collection",statut='f',typ='TXM',
                                  into=('$$DESO','$$IADD','$$IADM','$$NOM','$$LONG',
                                      '$$LONO','$$LUTI','$$NUM') ),
         ),
         b_systeme    =BLOC(condition = "(ENTITE=='SYSTEME')",
            CLASSE          =SIMP(statut='o',typ='TXM',into=('G','V') ),  
            NOMATR          =SIMP(fr="nom d attribut systeme",statut='f',typ='TXM',   
                                  into=('$$CARA','$$IADD','$$GENR','$$TYPE','$$MARQ',
                                      '$$DOCU','$$ORIG','$$RNOM','$$LTYP','$$LONG',
                                      '$$LONO','$$DATE','$$LUTI','$$HCOD','$$INDX',
                                      '$$TLEC','$$TECR','$$IADM','$$ACCE','$$USADI') ),
         ),
         b_repertoire =BLOC(condition = "(ENTITE=='REPERTOIRE')",
            CLASSE          =SIMP(statut='f',typ='TXM',into=('G','V',' '),defaut=' '),  
         ),
         b_disque     =BLOC(condition = "(ENTITE=='DISQUE')",
            CLASSE          =SIMP(statut='f',typ='TXM' ,into=('G','V',' '),defaut=' '),  
         ),
         b_enregist   =BLOC(condition = "(ENTITE=='ENREGISTREMENT')",
            CLASSE          =SIMP(statut='f',typ='TXM' ,into=('G','V'),defaut='G'),  
            NUMERO          =SIMP(statut='o',typ='I',val_min=1),  
            INFO            =SIMP(statut='f',typ='I',into=(1,2),defaut=1),  
         ),
         IMPRESSION      =FACT(statut='f',
           NOM             =SIMP(statut='f',typ='TXM' ),  
           UNITE           =SIMP(statut='f',typ='I'),  
         ),
         COMMENTAIRE     =SIMP(statut='f',typ='TXM' ),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr

IMPR_MACR_ELEM=PROC(nom="IMPR_MACR_ELEM",op= 160,
                    UIinfo={"groupes":("Impression","Outils-métier",)},
         fr="Impression d'une structure de données MACR_ELEM_DYNA au format IDEAS MISS3D",
         MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="IDEAS",
                               into=("MISS_3D","IDEAS") ),

         b_ideas         =BLOC(condition = "FORMAT == 'IDEAS'",
           UNITE           =SIMP(statut='f',typ='I',defaut=30),
           VERSION          =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,) ),
         ),             

         b_miss_3d       =BLOC(condition = "FORMAT == 'MISS_3D'",
           regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
           UNITE           =SIMP(statut='f',typ='I',defaut= 26 ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           AMOR_REDUIT     =SIMP(statut='f',typ='R'  ,max='**'),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           GROUP_MA_INTERF =SIMP(statut='o',typ=grma ,max='**'),
           GROUP_MA_FLU_STR=SIMP(statut='f',typ=grma,max='**'),
           GROUP_MA_FLU_SOL=SIMP(statut='f',typ=grma,max='**'),
           GROUP_MA_SOL_SOL=SIMP(statut='f',typ=grma,max='**'),
           GROUP_MA_CONTROL=SIMP(statut='f',typ=grma,max='**'),
           FORMAT_R        =SIMP(statut='f',typ='TXM',defaut="1PE12.5",into=("1PE12.5","1PE16.9") ),
           IMPR_MODE_MECA  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           IMPR_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),


)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
#
# RECUPERATION DES MAILLAGES IFS VENANT DE SATURNE VIA YACS
#
IMPR_MAIL_YACS=PROC(nom="IMPR_MAIL_YACS",op=43,
            UIinfo={"groupes":("Maillage",)},
               fr="Lecture d'un maillage via YACS lors du Couplage de Code_Aster et Saturne",
         UNITE_MAILLAGE = SIMP(statut='f',typ='I',defaut=30),
         TYPE_MAILLAGE = SIMP(statut='o',typ='TXM',into=("SOMMET","MILIEU")),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: isabelle.fournier at edf.fr
#
IMPR_OAR =MACRO(nom="IMPR_OAR",
                op=OPS('Macro.impr_oar_ops.impr_oar_ops'),
                sd_prod=None,
                fr="Impression au format OAR",
                UIinfo={"groupes":("Impression","Outils-métier",)},
   TYPE_CALC = SIMP(statut='o', typ='TXM',into=('COMPOSANT', 'MEF', 'TUYAUTERIE')),
   b_composant =BLOC(condition = "TYPE_CALC == 'COMPOSANT' ",
      regles = (AU_MOINS_UN('RESU_MECA','RESU_THER')),
      DIAMETRE = SIMP(statut='o', typ='R'),
      ORIGINE  = SIMP(statut='o', typ='TXM', defaut='INTERNE', into=('INTERNE', 'EXTERNE')),
      COEF_U   = SIMP(statut='f', typ='R',   defaut=1.0),
      ANGLE_C  = SIMP(statut='o', typ='R',   defaut=0.0),
      REVET    = SIMP(statut='f', typ='TXM', defaut='NON', into=('OUI', 'NON')),
      RESU_MECA = FACT(statut='f', max='**',
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TYPE      = SIMP(statut='o', typ='TXM', defaut='FX', into=('FX', 'FY', 'FZ', 'MX', 'MY', 'MZ', 'PRE')),
         TABLE     = SIMP(statut='o', typ=table_sdaster),
         TABLE_S   = SIMP(statut='f', typ=table_sdaster)),
      RESU_THER = FACT(statut='f', max='**',
         NUM_TRAN  = SIMP(statut='o', typ='I'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_TEMP= SIMP(statut='o', typ=table_sdaster),
         TABLE_S   = SIMP(statut='f', typ=table_sdaster),
         TABLE_ST  = SIMP(statut='f', typ=table_sdaster)),
         ),
   b_mef = BLOC(condition = "TYPE_CALC == 'MEF' ",
      regles = (AU_MOINS_UN('RESU_MECA','RESU_THER')),
      DIAMETRE = SIMP(statut='o', typ='R'),
      ORIGINE  = SIMP(statut='o', typ='TXM', defaut='INTERNE', into=('INTERNE', 'EXTERNE')),
      COEF_U   = SIMP(statut='f', typ='R',   defaut=1.0),
      RESU_MECA = FACT(statut='f', max='**',
         AZI       = SIMP(statut='o', typ='R'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_F   = SIMP(statut='o', typ=table_sdaster),
         TABLE_P   = SIMP(statut='o', typ=table_sdaster),
         TABLE_CA  = SIMP(statut='o', typ=table_sdaster)),
      RESU_THER=FACT(statut='f', max='**',
         AZI       = SIMP(statut='o', typ='R'),
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_TI  = SIMP(statut='o', typ=table_sdaster)),
      ),
   b_tuyauterie = BLOC(condition = "TYPE_CALC == 'TUYAUTERIE' ",
      RESU_MECA = FACT(statut='o', max='**',
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TABLE     = SIMP(statut='o', typ=table_sdaster),
         MAILLAGE  = SIMP(statut='o', typ=maillage_sdaster)),
         ),
   UNITE = SIMP(statut='f',typ='I',defaut=38),
   AJOUT = SIMP(statut='f', typ='TXM', defaut='NON', into=('OUI', 'NON')),
   );

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr
IMPR_RESU=PROC(nom="IMPR_RESU",op=39,
            UIinfo={"groupes":("Impression","Résultats et champs",)},
               fr="Imprimer un maillage et/ou les résultats d'un calcul (différents formats)",

         FORMAT          =SIMP(statut='f',typ='TXM',position='global',defaut="RESULTAT",
                                 into=("RESULTAT","IDEAS","ASTER","CASTEM","MED","GMSH") ),

         b_modele =BLOC(condition="FORMAT!='MED'",fr="Modèle",
           MODELE          =SIMP(statut='f',typ=modele_sdaster),
         ),

         b_format_resultat  =BLOC(condition="FORMAT=='RESULTAT'",fr="unité logique d'impression au format RESULTAT",
           UNITE           =SIMP(statut='f',typ='I',defaut=8),
         ),

         b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="unité logique d'impression et version IDEAS",
           UNITE           =SIMP(statut='f',typ='I',defaut=30),
           VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
         ),

         b_format_aster  =BLOC(condition="FORMAT=='ASTER'",fr="unité logique d'impression au format ASTER",
           UNITE           =SIMP(statut='f',typ='I',defaut=26),
         ),

         b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="unité logique d'impression et version CASTEM",
           UNITE           =SIMP(statut='f',typ='I',defaut=37),
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
         ),

         b_format_med  =BLOC(condition="FORMAT=='MED'",fr="unité logique d'impression au format MED",
           UNITE           =SIMP(statut='f',typ='I',defaut=80),
         ),

         b_format_gmsh  =BLOC(condition="FORMAT=='GMSH'",fr="unité logique d'impression et version GMSH",
           UNITE           =SIMP(statut='f',typ='I',defaut=37),
           VERSION         =SIMP(statut='f',typ='R',defaut=1.2,into=(1.0,1.2)),
         ),

         regles=(AU_MOINS_UN('CONCEPT','RESU',),),

         b_restreint  =BLOC(condition="FORMAT=='MED'",fr="Seulement pour les fichiers MED",
            RESTREINT   =FACT(statut='f', max=1,
            fr="Pour réduire une ou plusieurs sd_resultat sur un ensemble de mailles",
            regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
            TOUT_GROUP_MA   =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON'),),
            GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            TOUT_GROUP_NO   =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON'),),
            ),
         ),

         CONCEPT          =FACT(statut='f',max='**',
           fr='Pour imprimer les champs de "données" à des fins de visualisation (controle des affectations).',
           # (valide pour les format RESULTAT et MED)
           regles=(UN_PARMI('CHAM_MATER','CARA_ELEM','CHARGE'),),
           CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
           CHARGE          =SIMP(statut='f',typ=char_meca),

           b_cara_elem        =BLOC(condition="CARA_ELEM != None", fr="impression des reperes locaux.",
              REPERE_LOCAL    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
              b_reploc        =BLOC(condition="REPERE_LOCAL == 'OUI'", fr="impression des reperes locaux.",
                 MODELE          =SIMP(statut='o',typ=modele_sdaster),
              ),
           ),
         ),

         RESU            =FACT(statut='f',max='**',

           regles=(AU_MOINS_UN('CHAM_GD','RESULTAT','MAILLAGE',),
                   EXCLUS('CHAM_GD','RESULTAT'),),
           MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster,squelette)),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
           CHAM_GD         =SIMP(statut='f',typ=cham_gd_sdaster),
           RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),

           b_info_med  =BLOC(condition="FORMAT=='MED'",
             INFO_MAILLAGE   =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           ),


           b_partie        =BLOC(condition="""(AsType(RESULTAT) in (dyna_harmo, acou_harmo) or
                          AsType(CHAM_GD) != carte_sdaster) and FORMAT in ('CASTEM', 'GMSH', 'MED')""",
             PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
           ),

           b_vari_el       =BLOC(condition="FORMAT==('MED')",
             IMPR_NOM_VARI=SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",),
           ),

           b_extrac        =BLOC(condition="RESULTAT != None",
                                 fr="extraction d un champ de grandeur",
             regles=(EXCLUS('TOUT_CHAM','NOM_CHAM'),
                     EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP',
                            'LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS','ANGLE'),),
             TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO()),

             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             ANGLE           =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),

             b_acce_reel     =BLOC(condition="(ANGLE != None)or(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
                CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                     PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                     PRECISION       =SIMP(statut='o',typ='R',),),
             ),
           ),
###
           b_parametres    =BLOC(condition="""(RESULTAT != None)and(FORMAT == 'RESULTAT')""",
             regles=(EXCLUS('TOUT_PARA','NOM_PARA'),),
             TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI","NON",) ),
             NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
             FORM_TABL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON","EXCEL") ),
           ),
###
           b_cmp=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and\
           ((FORMAT == 'CASTEM')or(FORMAT == 'RESULTAT')or(FORMAT == 'IDEAS')or(FORMAT == 'MED'))""",
                                fr="sélection des composantes",
             regles=(EXCLUS('TOUT_CMP','NOM_CMP'),),
             TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           ),
###
           b_med=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and(FORMAT == 'MED')""",
                                fr="renommage du champ",
             regles=(EXCLUS('NOM_CHAM_MED','NOM_RESU_MED'),),
             NOM_CHAM_MED    =SIMP(statut='f',typ='TXM',
                                   validators=AndVal((LongStr(1,64), NoRepeat())), max='**'),
             NOM_RESU_MED    =SIMP(statut='f',typ='TXM'),
           ),
###
           b_gmsh=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and((FORMAT == 'GMSH'))""",
                                fr="sélection des composantes et des entités toplogiques",
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             TYPE_CHAM       =SIMP(statut='f',typ='TXM',defaut="SCALAIRE",
                                   into=("VECT_2D","VECT_3D","SCALAIRE","TENS_2D","TENS_3D"),),
             b_scal          =BLOC(condition = "TYPE_CHAM=='SCALAIRE'",
               NOM_CMP         =SIMP(statut='f',typ='TXM',max='**' ),),
             b_vect_2d       =BLOC(condition = "TYPE_CHAM=='VECT_2D'",
               NOM_CMP         =SIMP(statut='o',typ='TXM',min=2,max=2 ),),
             b_vect_3d       =BLOC(condition = "TYPE_CHAM=='VECT_3D'",
               NOM_CMP         =SIMP(statut='o',typ='TXM',min=3,max=3 ),),
             b_tens_2d       =BLOC(condition = "TYPE_CHAM=='TENS_2D'",
               NOM_CMP         =SIMP(statut='o',typ='TXM',min=4,max=4 ),),
             b_tens_3d       =BLOC(condition = "TYPE_CHAM=='TENS_3D'",
               NOM_CMP         =SIMP(statut='o',typ='TXM',min=6,max=6 ),),
           ),
###
           b_topologie=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and\
           ((FORMAT == 'RESULTAT')or(FORMAT == 'IDEAS')or(FORMAT == 'MED'))""",
                                fr="sélection des entités topologiques",
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ),
###
           b_valeurs=BLOC(condition="(FORMAT == 'RESULTAT')",
                               fr="sélection sur les valeurs",
             VALE_MAX        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             VALE_MIN        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             BORNE_SUP       =SIMP(statut='f',typ='R'),
             BORNE_INF       =SIMP(statut='f',typ='R'),
             IMPR_COOR       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           ),

           b_format_r=BLOC(condition="""((FORMAT == 'RESULTAT')or(FORMAT == 'ASTER'))""",
                           fr="Format des nombres réels",
             FORMAT_R        =SIMP(statut='f',typ='TXM',defaut="1PE21.14"),
           ),

           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
) ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

IMPR_TABLE=MACRO(nom="IMPR_TABLE",
                 op=OPS('Macro.impr_table_ops.impr_table_ops'),
                 sd_prod=None,
                 UIinfo={"groupes":("Impression","Tables",)},
                 fr="Impression du contenu d'une table dans un fichier",
   TABLE          =SIMP(statut='o',typ=table_sdaster),
   FORMAT         =SIMP(statut='f',typ='TXM',defaut="TABLEAU",
                         into=("TABLEAU","ASTER","TABLEAU_CROISE","AGRAF","XMGRACE",),),
   b_pilote       =BLOC(condition = "FORMAT == 'XMGRACE'",
                        fr="Mots-clés propres à XMGRACE",
      PILOTE         =SIMP(statut='f',typ='TXM',defaut='',
                           into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),
                      fr="Pilote de sortie, PNG/JPEG/PDF ne sont pas disponibles sur toutes les installations de xmgrace"),
      UNITE          =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                           fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
   ),
   b_unite        =BLOC(condition = "FORMAT != 'XMGRACE'",
      UNITE          =SIMP(statut='f',typ='I',defaut=8,
                           fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
   ),
   FILTRE         =FACT(statut='f',max='**',
      NOM_PARA       =SIMP(statut='o',typ='TXM'),
      CRIT_COMP      =SIMP(statut='f',typ='TXM',defaut="EQ",
                           into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                 "NON_VIDE","MAXI","MAXI_ABS","MINI","MINI_ABS"),),
      b_vale         =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
         regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
         VALE           =SIMP(statut='f',typ='R',max='**'),
         VALE_I         =SIMP(statut='f',typ='I',max='**'),
         VALE_C         =SIMP(statut='f',typ='C',max='**'),
         VALE_K         =SIMP(statut='f',typ='TXM',max='**'),
      ),
      b_crit         =BLOC(condition = "CRIT_COMP in ('EQ','NE')",
         CRITERE        =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         PRECISION      =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
      ),
   ),
   TRI            =FACT(statut='f',
      NOM_PARA       =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
      ORDRE          =SIMP(statut='f',typ='TXM',defaut="CROISSANT", # max='**',
                           into=("CROISSANT","DECROISSANT") ),
   ),
   PAGINATION     =SIMP(statut='f',typ='TXM',max='**'),
   FORMAT_R       =SIMP(statut='f',typ='TXM',defaut="E12.5"),
   NOM_PARA       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
   IMPR_FONCTION  =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),

   # Mise en page du tableau ou du graphique
   b_tableau = BLOC(condition = "FORMAT == 'TABLEAU'",
                    fr="Mots-clés propres au format Tableau",
      SEPARATEUR      =SIMP(statut='f',typ='TXM',defaut=' ',
                            fr="Séparateur des colonnes du tableau (ex : ' ', ';'...)"),
      COMMENTAIRE     =SIMP(statut='f',typ='TXM',defaut='#',
                            fr="Caractère indiquant au traceur de fonction que la ligne peut etre ignorée"),
      COMM_PARA       =SIMP(statut='f',typ='TXM',defaut='',
                            fr="Caractère utilisé pour commentariser la ligne des labels de colonnes"),
      DEBUT_LIGNE     =SIMP(statut='f',typ='TXM',defaut='',
                            fr="Caractère de debut de ligne"),
      FIN_LIGNE       =SIMP(statut='f',typ='TXM',defaut='\n',
                            fr="Caractère de fin de ligne"),
    ),

   # mise en forme pour les formats qui passent par Graph
   b_forme         =BLOC(condition = "FORMAT == 'XMGRACE'",
                         fr="Données de mise en forme du graphique",
      # pour la courbe
      LEGENDE         =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à la fonction" ),
      STYLE           =SIMP(statut='f',typ='I',val_min=0,
                            fr="Style de la ligne représentant la fonction",),
      COULEUR         =SIMP(statut='f',typ='I',val_min=0,
                            fr="Couleur associée à la fonction",),
      MARQUEUR        =SIMP(statut='f',typ='I',val_min=0,
                            fr="Type du marqueur associé à la fonction",),
      FREQ_MARQUEUR   =SIMP(statut='f',typ='I',defaut=0,
                            fr="Fréquence d impression du marqueur associé à la fonction", ),
      # format du graphique
      BORNE_X         =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Intervalles de variation des abscisses"),
      BORNE_Y         =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Intervalles de variation des ordonnées"),
      ECHELLE_X       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                            fr="Type d'échelle pour les abscisses" ),
      ECHELLE_Y       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                            fr="Type d'échelle pour les ordonnées" ),
      GRILLE_X        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                            fr="Pas du quadrillage vertical" ),
      GRILLE_Y        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                            fr="Pas du quadrillage horizontal" ),
      LEGENDE_X       =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à l'axe des abscisses" ),
      LEGENDE_Y       =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à l'axe des ordonnées" ),
   ),

   TITRE          =SIMP(statut='f',typ='TXM',max='**'),
   INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

INCLUDE=MACRO(nom="INCLUDE",
              op=OPS("Cata.ops.build_include"),
              UIinfo={"groupes":("Gestion du travail",)},
              fr="Débranchement vers un fichier de commandes secondaires",
              sd_prod=ops.INCLUDE,
              op_init=ops.INCLUDE_context,
              fichier_ini=1,
              regles=(UN_PARMI('UNITE', 'DONNEE')),
         UNITE = SIMP(statut='f', typ='I',
                      fr="Unité logique à inclure"),
         DONNEE = SIMP(statut='f', typ='Fichier',
                       fr="Nom du fichier de données à inclure"),
         INFO  = SIMP(statut='f', typ='I', defaut=1, into=(1, 2)),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

INCLUDE_MATERIAU = MACRO(nom="INCLUDE_MATERIAU",
                         op=OPS("Macro.include_materiau_ops.include_materiau_ops"),
                         sd_prod=mater_sdaster,
            UIinfo={"groupes":("Modélisation", "Gestion du travail", )},
            fr="Récupérer les caractéristiques d'un matériau dans le Catalogue Materiaux d'Aster ",

         NOM_AFNOR      = SIMP(statut='o', typ='TXM',),
         TYPE_MODELE    = SIMP(statut='o', typ='TXM', into=("REF", "PAR"),),
         VARIANTE       = SIMP(statut='o', typ='TXM',
                               into=("A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                                     "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
                                     "U", "V", "W", "X", "Y", "Z",),),
         TYPE_VALE      = SIMP(statut='o', typ='TXM', into=("NOMI", "MINI", "MAXI"),),
         #NOM_MATER      = SIMP(statut='o', typ='TXM',),
         #UNITE          = SIMP(statut='f', typ='I', defaut= 32,),
         EXTRACTION     = FACT(statut='f',
           COMPOR       = SIMP(statut='o', typ='TXM', max='**',),
           TEMP_EVAL    = SIMP(statut='o', typ='R',),
         ),
         UNITE_LONGUEUR = SIMP(statut='f', typ='TXM', into=("M", "MM"), defaut="M",),
         INFO           = SIMP(statut='f', typ='I', defaut= 1, into=(1, 2),),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
INFO_EXEC_ASTER=OPER(nom="INFO_EXEC_ASTER",op=35,sd_prod=table_sdaster,
                    fr="Récupère différentes informations propres à l'exécution en cours",
                    reentrant='n',
                    UIinfo={"groupes":("Gestion du travail",)},

         regles=(),
         LISTE_INFO     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=3,
                              into=("CPU_RESTANT","UNITE_LIBRE","ETAT_UNITE"),),
         b_etat_unite   =BLOC(condition = "au_moins_un(LISTE_INFO, 'ETAT_UNITE')",
            regles=(UN_PARMI('UNITE','FICHIER'),),
            UNITE          =SIMP(statut='f',typ='I',val_min=1,val_max=99,max=1,
                                 fr="Unité logique dont on veut obtenir l'état",),
            FICHIER        =SIMP(statut='f',typ='TXM',validators=LongStr(1,255),
                                 fr="Nom du fichier dont on veut obtenir l'état",),
         ),
         TITRE          =SIMP(statut='f',typ='TXM',max='**'),
         INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

def info_fonction_prod(self,ECART_TYPE,RMS,NOCI_SEISME,MAX,NORME, **args):
   if (RMS         != None): return table_sdaster
   if (MAX         != None): return table_sdaster
   if (NOCI_SEISME != None): return table_sdaster
   if (ECART_TYPE  != None): return table_sdaster
   if (NORME       != None): return table_sdaster
   raise AsException("type de concept resultat non prevu")

INFO_FONCTION=MACRO(nom="INFO_FONCTION",
                    op=OPS('Macro.info_fonction_ops.info_fonction_ops'),
                    sd_prod=info_fonction_prod,
                    fr="Opérations mathématiques sur des concepts de type fonction, " \
                       "fonction_c ou nappe",
                    reentrant='n',
                    UIinfo={"groupes":("Fonctions",)},
         regles=(UN_PARMI('MAX','RMS','NOCI_SEISME','NORME','ECART_TYPE',),),
         RMS             =FACT(statut='f',fr="Valeur RMS d'une fonction",max='**',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
           INST_INIT       =SIMP(statut='f',typ='R',fr="Instant initial définissant le début du signal" ),
           INST_FIN        =SIMP(statut='f',typ='R',fr="Instant final définissant la fin du signal" ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R'),),
         ),
         NOCI_SEISME     =FACT(statut='f',
           regles=(UN_PARMI('FONCTION','SPEC_OSCI',),),
           FONCTION        =SIMP(statut='f',typ=fonction_sdaster ),
           SPEC_OSCI       =SIMP(statut='f',typ=nappe_sdaster ),
           b_option_f      =BLOC(condition="""FONCTION != None""",
             OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",validators=NoRepeat(),
                                   into=("INTE_ARIAS","POUV_DEST","INTE_SPEC","VITE_ABSO_CUMU",
                                         "DUREE_PHAS_FORT","MAXI","ACCE_SUR_VITE","TOUT",), ),
             b_amor_red          =BLOC(condition="""au_moins_un(OPTION, ("TOUT", "INTE_SPEC")) """,
                AMOR_REDUIT     =SIMP(statut='o',typ='R'),),
             b_pesanteur         =BLOC(condition="""au_moins_un(OPTION, ("TOUT", "INTE_ARIAS", "POUV_DEST", "DUREE_PHAS_FORT")) """,
                PESANTEUR       =SIMP(statut='o',typ='R'),),
           ),
           b_option_n      =BLOC(condition="""SPEC_OSCI !=None""",
             OPTION          =SIMP(statut='f',typ='TXM',defaut="INTE_SPEC",into=("INTE_SPEC",), ),
             NATURE          =SIMP(statut='o',typ='TXM',into=("DEPL","VITE","ACCE") ),
             AMOR_REDUIT     =SIMP(statut='o',typ='R'), ),
           INST_INIT       =SIMP(statut='f',typ='R'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           COEF            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FREQ_INIT       =SIMP(statut='f',typ='R',defaut= 4.E-1 ),
           FREQ_FIN        =SIMP(statut='f',typ='R',defaut= 10.E+0 ),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',max='**'),
           NORME           =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
           BORNE_INF       =SIMP(statut='f',typ='R',defaut= 0.05E+0 ),
           BORNE_SUP       =SIMP(statut='f',typ='R',defaut= 0.95E+0 ),
           b_acce_reel     =BLOC(condition="(INST_INIT != None)or(INST_FIN != None)or(FREQ_INIT != None)or(FREQ_FIN != None)",
                  CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
                  b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                      PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0),),
                  b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                      PRECISION       =SIMP(statut='o',typ='R'),),
           ),
         ),
         MAX             =FACT(statut='f',fr="Extrémas locaux d'une fonction",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),max='**' ),
           INTERVALLE      =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="définition des bornes des intervalles sous forme de couples (xi_i1,xs_i1,xi_i2,xs_i2)"),
         ),
         NORME           =FACT(statut='f',fr="Norme L2 d'une fonction",
            FONCTION      =SIMP(statut='o', typ=nappe_sdaster),
         ),
         ECART_TYPE      =FACT(statut='f',fr="Ecart-type d'une fonction",
            METHODE       =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
            FONCTION      =SIMP(statut='o',typ=fonction_sdaster),
            INST_INIT     =SIMP(statut='f',typ='R',fr="Instant initial définissant le début du signal" ),
            INST_FIN      =SIMP(statut='f',typ='R',fr="Instant final définissant la fin du signal" ),
            CRITERE       =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
            b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0),),
            b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                PRECISION       =SIMP(statut='o',typ='R'),),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: olivier.boiteau at edf.fr
INFO_MODE=OPER(nom="INFO_MODE",op=32,sd_prod=table_sdaster,
                fr="Calculer, imprimer, et sauvegarder le nombre de valeurs propres dans un contour donné",
            UIinfo={"groupes":("Résolution","Dynamique",)},

         TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",into=("MODE_COMPLEXE","DYNAMIQUE",
                                                                             "MODE_FLAMB",   "GENERAL"),
                               fr="Type d analyse" ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),

         b_dynamique =BLOC(condition = "TYPE_MODE == 'DYNAMIQUE'",fr="Recherche du nombre de fréquences propres",
           MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r,
                                                 matr_asse_depl_c,matr_asse_gene_c) ),
           MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           FREQ            =SIMP(statut='o',typ='R',min=2,max='**',
                                 validators=AndVal((OrdList('croissant'), NoRepeat())),
                                 fr="Liste de frequences" ),
           COMPTAGE        =FACT(statut='d',
              METHODE          =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AUTO","STURM")),                
              SEUIL_FREQ       =SIMP(statut='f',typ='R',defaut= 1.E-2 ),  
              PREC_SHIFT       =SIMP(statut='f',typ='R',defaut= 5.E-2 ),
              NMAX_ITER_SHIFT  =SIMP(statut='f',typ='I',defaut= 3,val_min=0),
                                ),
         ),

         b_flambement =BLOC(condition = "TYPE_MODE == 'MODE_FLAMB'",fr="Recherche du nombre de charges critiques",
           MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r,
                                                 matr_asse_depl_c,matr_asse_gene_c) ),
           MATR_RIGI_GEOM  =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           CHAR_CRIT       =SIMP(statut='o',typ='R',min=2,max='**',
                                 validators=AndVal((OrdList('croissant'), NoRepeat())),
                                 fr="Liste de charges critiques" ),
           COMPTAGE        =FACT(statut='d',
              METHODE          =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AUTO","STURM")),                
              SEUIL_CHAR_CRIT  =SIMP(statut='f',typ='R',defaut= 1.E-2 ),  
              PREC_SHIFT       =SIMP(statut='f',typ='R',defaut= 5.E-2 ),
              NMAX_ITER_SHIFT  =SIMP(statut='f',typ='I',defaut= 3,val_min=0),
                                ),
         ),         

         b_complexe  =BLOC(condition = "TYPE_MODE == 'MODE_COMPLEXE'",fr="Recherche du nombre de fréquences propres",
           MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r,
                                                 matr_asse_depl_c,matr_asse_gene_c) ),
           MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           MATR_AMOR       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           TYPE_CONTOUR    =SIMP(statut='f',typ='TXM',defaut="CERCLE",into=("CERCLE","CERCLE") ),
           RAYOP_CONTOUR   =SIMP(statut='o',typ='R',val_min=1.E-2 ),
           CENTRE_CONTOUR  =SIMP(statut='f',typ='C',defaut= 0.0+0.0j),
           COMPTAGE        =FACT(statut='d',
              METHODE          =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AUTO","APM")),                
              NBPOINT_CONTOUR  =SIMP(statut='f',typ='I',defaut= 40,val_min=10,val_max=1000),
              NMAX_ITER_CONTOUR=SIMP(statut='f',typ='I',defaut= 3, val_min=1,val_max=5),
                               ),
         ),

         b_general  =BLOC(condition = "TYPE_MODE == 'GENERAL'",fr="Recherche du nombre de valeurs propres",
           MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r,
                                                 matr_asse_depl_c,matr_asse_gene_c) ),
           MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           MATR_C          =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r,matr_asse_gene_r) ),
           CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max='**',
                                 validators=AndVal((OrdList('croissant'), NoRepeat())),
                                 fr="Liste de charges critiques" ),
           b_contour  =BLOC(condition = "CHAR_CRIT == None",
             TYPE_CONTOUR    =SIMP(statut='f',typ='TXM',defaut="CERCLE",into=("CERCLE","CERCLE") ),        
             RAYOP_CONTOUR   =SIMP(statut='o',typ='R',val_min=1.E-2 ),
             CENTRE_CONTOUR  =SIMP(statut='f',typ='C',defaut= 0.0+0.0j),),
           COMPTAGE        =FACT(statut='d',
              METHODE          =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AUTO","STURM","APM")),                
              SEUIL_CHAR_CRIT  =SIMP(statut='f',typ='R',defaut= 1.E-2 ),  
              PREC_SHIFT       =SIMP(statut='f',typ='R',defaut= 5.E-2 ),
              NMAX_ITER_SHIFT  =SIMP(statut='f',typ='I',defaut= 3,val_min=0),                                 ),
              NBPOINT_CONTOUR  =SIMP(statut='f',typ='I',defaut= 40,val_min=10,val_max=1000),
              NMAX_ITER_CONTOUR=SIMP(statut='f',typ='I',defaut= 3, val_min=1,val_max=5),
                                ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
                        
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('INFO_MODE'),
#        Mot-cle pour piloter les niveaux de parallelismes de l'operateur (a ne pas confondre avec le mot-cle
#        cache PARALLELISME_MACRO)
         NIVEAU_PARALLELISME  =SIMP(statut='f',typ='TXM',defaut="COMPLET",into=("PARTIEL","COMPLET") ),  
#-------------------------------------------------------------------
#-------------------------------------------------------------------
#  Mot-cles caches pour activer le parallelisme au sein d'une macro-commande
         PARALLELISME_MACRO=FACT(statut='d',min=0,
           TYPE_COM   =SIMP(statut='c',typ='I',defaut=-999,into=(-999,1,2),fr="Type de communication"),
         ),
#-------------------------------------------------------------------

)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr
INFO_RESU=PROC(nom="INFO_RESU",op=40,
               UIinfo={"groupes":("Impression","Utilitaires",)},
               fr="Imprimer tous les champs présents dans une structure de données résultat",
               RESULTAT=SIMP(statut='f',typ=resultat_sdaster),
               UNITE=SIMP(statut='f',typ='I',defaut=6),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
INIT_COMPO=PROC(nom="INIT_COMPO",
                op=  117,
                UIinfo={"groupes":("Gestion du travail",)},
                fr="Initialiser adresse component YACS",
           COMPO           =SIMP(statut='o',typ='I',),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
INTE_MAIL_2D=OPER(nom="INTE_MAIL_2D",op=50,sd_prod=courbe_sdaster,
            UIinfo={"groupes":("Post-traitements",)},
                  fr="Définition d'une courbe dans un maillage 2D",reentrant='n',

         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster) ),

         regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                 AU_MOINS_UN('DEFI_SEGMENT','DEFI_ARC','DEFI_CHEMIN'),
                 PRESENT_ABSENT('DEFI_CHEMIN','DEFI_SEGMENT','DEFI_ARC'),
                 PRESENT_ABSENT('DEFI_SEGMENT','NOEUD_ORIG','GROUP_NO_ORIG'),
                 PRESENT_ABSENT('DEFI_ARC','NOEUD_ORIG','GROUP_NO_ORIG'),
                 EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                 EXCLUS('DEFI_CHEMIN','DEFI_SEGMENT'),
                 EXCLUS('DEFI_CHEMIN','DEFI_ARC'),),

         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

         DEFI_SEGMENT    =FACT(statut='f',max='**',
           regles=(UN_PARMI('ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),),
           ORIGINE         =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
         ),

         DEFI_ARC        =FACT(statut='f',max='**',
           regles=(UN_PARMI('CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                   UN_PARMI('RAYON','ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('RAYON','EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),               
                   PRESENT_PRESENT('RAYON','SECTEUR'),),
           CENTRE          =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_CENTRE    =SIMP(statut='f',typ=no,),
           GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,),
           RAYON           =SIMP(statut='f',typ='R',val_min=0.E+0),  
           SECTEUR         =SIMP(statut='f',typ='R',min=2,max=2,
                                 val_min=-180.E+0,val_max=180E+0),  
           ORIGINE         =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),  
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",    
                                 into=("RELATIF","ABSOLU",) ),
         ),

         DEFI_CHEMIN     =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),

         NOEUD_ORIG      =SIMP(statut='f',typ=no,),
         GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),  
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
INTE_MAIL_3D=OPER(nom="INTE_MAIL_3D",op=96,sd_prod=surface_sdaster,
            UIinfo={"groupes":("Post-traitements",)},
                  fr="Définir un chemin de type segment de droite dans un maillage 3D",reentrant='n',
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         DEFI_SEGMENT    =FACT(statut='o',max='**',
           regles=(UN_PARMI('ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),),
           ORIGINE         =SIMP(statut='f',typ='R',min=3,max=3),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=3,max=3),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
         ),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),  
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr
def lire_champ_prod(TYPE_CHAM=None,**args):
# Remarque : si cette liste évolue, il faut penser à mettre à jour son
#            homologue dans macr_adap_mail
  if TYPE_CHAM[0:5] == "NOEU_" : return cham_no_sdaster
  if TYPE_CHAM[0:5] == "CART_" : return carte_sdaster
  if TYPE_CHAM[0:2] == "EL"    : return cham_elem
  raise AsException("type de concept resultat non prevu")

LIRE_CHAMP=OPER(nom="LIRE_CHAMP",op= 192,sd_prod=lire_champ_prod,
                UIinfo={"groupes":("Lecture","Résultats et champs",)},
                fr="Lire un champ dans un fichier au format MED et le stocker dans un concept.",
                reentrant='n',
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster,),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="MED",into=("MED",),),
         UNITE           =SIMP(statut='f',typ='I',defaut= 81,),
         b_format =BLOC(condition = "FORMAT == 'MED'",
         regles=( UN_PARMI('NOM_CMP_IDEM','NOM_CMP'),
                  PRESENT_PRESENT('NOM_CMP','NOM_CMP_MED' ),
                  EXCLUS('NUME_ORDRE','INST'),
                  EXCLUS('NUME_PT','INST'),),
            NOM_MED      =SIMP(statut='o',typ='TXM', ),
            NOM_CMP_IDEM =SIMP(statut='f',typ='TXM',into=("OUI",), ),
            NOM_CMP      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',),
            NOM_CMP_MED  =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',),
            PROL_ZERO    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",),
               fr="Affecte des valeurs nulles la ou le champ n'est pas defini (sinon il y a NaN)"),
            NUME_PT      =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**',),
            NUME_ORDRE   =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**',
                           fr="Numero d ordre du champ à lire",ang="Rank of the field to be read" ),
            INST         =SIMP(statut='f',typ='R',fr="Instant associé",ang="Instant" ),
#
            b_precision     =BLOC(condition="(INST != None)",
                  CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                  fr="Critère de précision sur le choix de l'instant associé",
                  ang="Accuracy criterium over instant choice" ),
                  b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                      PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                      fr="Précision sur le choix de l'instant associé",ang="Accuracy over instant choice" ),),
                  b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                      PRECISION       =SIMP(statut='o',typ='R',
                      fr="Précision sur le choix de l'instant associé",ang="Accuracy over instant choice" ),),),
#
            NOM_MAIL_MED =SIMP(statut='f',typ='TXM',),
                  ),
#        Remarque : si cette liste évolue, il faut penser à mettre à jour son
#                   homologue dans macr_adap_mail
         TYPE_CHAM       =SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO()),
         b_modele =BLOC(condition = "TYPE_CHAM!=None and (TYPE_CHAM[0:2] == 'EL')",
            MODELE      =SIMP(statut='o',typ=modele_sdaster, ),
                  ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


def lire_fonction_prod(self,TYPE,**args):
  if   (TYPE == 'FONCTION')  : return fonction_sdaster
  elif (TYPE == 'FONCTION_C'): return fonction_c
  elif (TYPE == 'NAPPE'   )  : return nappe_sdaster
  raise AsException("type de concept resultat non prevu")

LIRE_FONCTION=MACRO(nom="LIRE_FONCTION",
                    op=OPS('Macro.lire_fonction_ops.lire_fonction_ops'),
                    sd_prod=lire_fonction_prod,
                    fr="Lit les valeurs réelles dans un fichier de données représentant une " \
                       "fonction et crée un concept de type fonction ou nappe",
                    reentrant='n',
                    UIinfo={"groupes":("Lecture","Fonctions",)},
         FORMAT          =SIMP(statut='f',typ='TXM',into=("LIBRE",),defaut="LIBRE"  ),
         TYPE            =SIMP(statut='f',typ='TXM',into=("FONCTION","FONCTION_C","NAPPE"),defaut="FONCTION"  ),
         SEPAR           =SIMP(statut='f',typ='TXM',into=("None",",",";","/"),defaut="None" ),
         INDIC_PARA      =SIMP(statut='f',typ='I',min=2,max=2,defaut=[1,1]),
         b_fonction      =BLOC(condition = "TYPE=='FONCTION' ",
           INDIC_RESU      =SIMP(statut='f',typ='I',min=2,max=2,defaut=[1,2]), ),
         b_fonction_c    =BLOC(condition = "TYPE=='FONCTION_C' ",
           FORMAT_C        =SIMP(statut='f',typ='TXM',defaut="REEL_IMAG",into=("REEL_IMAG","MODULE_PHASE") ),
           b_reel_imag     =BLOC(condition = "FORMAT_C=='REEL_IMAG' ",
             INDIC_REEL      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,2]),
             INDIC_IMAG      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,3]), ) ,
           b_modu_phas     =BLOC(condition = "FORMAT_C=='MODULE_PHASE' ",
             INDIC_MODU      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,2]),
             INDIC_PHAS      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,3]), ), ),
         b_nappe         =BLOC(condition = "TYPE=='NAPPE' ",
           NOM_PARA_FONC   =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
           INDIC_ABSCISSE  =SIMP(statut='o',typ='I',min=2,max=2,),
           INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG"),
                                 fr="Type d'interpolation pour les abscisses et les ordonnées de la fonction"),
           PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           DEFI_FONCTION   =FACT(statut='f',max='**',
             INDIC_RESU      =SIMP(statut='o',typ='I',min=2,max=2,),),  ),
         UNITE           =SIMP(statut='o',typ='I' ),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG"),
                               fr="Type d'interpolation pour les abscisses et les ordonnées de la " \
                                  "fonction ou bien pour le paramètre de la nappe."),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="CROISSANT",into=("CROISSANT","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr
LIRE_FORC_MISS=OPER(nom="LIRE_FORC_MISS",op= 179,sd_prod=vect_asse_gene,
                    fr="Création d'un vecteur assemblé à partir d'une base modale",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs","Outils-métier",)},           
         BASE            =SIMP(statut='o',typ=mode_meca),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         FREQ_EXTR       =SIMP(statut='o',typ='R',max=1),
         NOM_CMP         =SIMP(statut='f',typ='TXM',into=("DX","DY","DZ") ),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","VITE","ACCE"),defaut="DEPL"),
         NUME_CHAR       =SIMP(statut='f',typ='I' ),
         ISSF            =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","OUI") ),
         UNITE_RESU_FORC =SIMP(statut='f',typ='I',defaut=30),         
         NOM_RESU_FORC   =SIMP(statut='f',typ='TXM' ),         
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr
LIRE_IMPE_MISS=OPER(nom="LIRE_IMPE_MISS",op= 164,sd_prod=matr_asse_gene_c,
                    fr="Création d une matrice assemblée à partir de base modale",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs","Outils-métier",)},           
         BASE            =SIMP(statut='o',typ=mode_meca ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         FREQ_EXTR       =SIMP(statut='f',typ='R',max=1),
         INST_EXTR       =SIMP(statut='f',typ='R',max=1),
         UNITE_RESU_IMPE =SIMP(statut='f',typ='I',defaut=30),
         ISSF            =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","OUI") ),
         TYPE            =SIMP(statut='f',typ='TXM',defaut="ASCII",into=("BINAIRE","ASCII") ),         
         SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","OUI") ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr


LIRE_INTE_SPEC=MACRO(nom="LIRE_INTE_SPEC",
                     op=OPS('Macro.lire_inte_spec_ops.lire_inte_spec_ops'),
                     sd_prod=interspectre,
                     fr="Lecture sur un fichier externe de fonctions complexes pour " \
                        "créer une matrice interspectrale",
                     reentrant='n',
            UIinfo={"groupes":("Lecture","Fonctions",)},
         UNITE           =SIMP(statut='o',typ='I' ),
         FORMAT_C        =SIMP(statut='f',typ='TXM',defaut="MODULE_PHASE",into=("REEL_IMAG","MODULE_PHASE") ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","IDEAS") ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',defaut="FREQ",
                               into=("DX","DY","DZ","DRX","DRY","DRZ","TEMP",
                                     "INST","X","Y","Z","EPSI","FREQ","PULS","AMOR","ABSC",) ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="DSP" ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
LIRE_MAILLAGE=OPER(nom="LIRE_MAILLAGE",op=   1,sd_prod=maillage_sdaster,
                   fr="Crée un maillage par lecture d'un fichier au format Aster ou Med",
                   ang="Readings of a mesh file",
                   reentrant='n',
            UIinfo={"groupes":("Lecture","Maillage",)},

         UNITE           =SIMP(statut='f',typ='I',defaut= 20 ),

         FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","MED"),
                            fr="Format du fichier : ASTER ou MED.",
                            ang="Format of the file : ASTER or MED.",),

         ABSC_CURV       =FACT(statut='f',min=0,
               TOUT          =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         VERI_MAIL       =FACT(statut='d',
               VERIF         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
               APLAT         =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ),

         b_format_med =BLOC( condition = " ( FORMAT == 'MED' ) " ,
                             fr="Informations complémentaires pour la lecture MED.",
                             ang="Further information for MED readings.",

# Pour une lecture dans un fichier MED, on peut préciser le nom sous lequel
# le maillage y a été enregistré. Par défaut, on va le chercher sous le nom du concept à créer.
            NOM_MED    = SIMP(statut='f',typ='TXM',
                              fr="Nom du maillage dans le fichier MED.",
                              ang="Name of the mesh into the MED file.",),
            INFO_MED   = SIMP(statut='f',typ='I',defaut= 1,into=(1,2,3) ),

            RENOMME = FACT(statut='f', max='**',
                                 fr="Renommer un nom de groupe MED",
                 NOM_MED     = SIMP(statut='o', typ='TXM', validators=LongStr(1, 64),
                                    fr="Nom du groupe dans le fichier MED"),
                 NOM         = SIMP(statut='o', typ=grma,
                                    fr="Nom du groupe dans le maillage ASTER"),
            ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: serguei.potapov at edf.fr

LIRE_PLEXUS=OPER(nom="LIRE_PLEXUS",op= 184,sd_prod=evol_char,
                 fr="Lire le fichier de résultats au format IDEAS produit par le logiciel EUROPLEXUS",
                 reentrant='n',
            UIinfo={"groupes":("Lecture","Outils-métier",)},
         regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
         UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="IDEAS",into=("IDEAS",)),
         MAIL_PLEXUS     =SIMP(statut='o',typ=maillage_sdaster ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         b_prec_crit     =BLOC(condition = "LIST_INST != None or INST != None",
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr

def lire_resu_prod(TYPE_RESU,**args):
  if TYPE_RESU == "EVOL_CHAR" :  return evol_char
  if TYPE_RESU == "EVOL_THER" :  return evol_ther
  if TYPE_RESU == "EVOL_ELAS" :  return evol_elas
  if TYPE_RESU == "EVOL_NOLI" :  return evol_noli
  if TYPE_RESU == "DYNA_TRANS" : return dyna_trans
  if TYPE_RESU == "DYNA_HARMO" : return dyna_harmo
  if TYPE_RESU == "MODE_MECA" :  return mode_meca
  if TYPE_RESU == "MODE_MECA_C" : return mode_meca_c
  if TYPE_RESU == "EVOL_VARC" :  return evol_varc
  raise AsException("type de concept resultat non prevu")

# pour éviter d'écrire 3 fois cette liste :
def l_nom_cham_pas_elga() :
     return list(set(C_NOM_CHAM_INTO())-set(C_NOM_CHAM_INTO('ELGA',)))

LIRE_RESU=OPER(nom="LIRE_RESU",op=150,sd_prod=lire_resu_prod,reentrant='n',
            UIinfo={"groupes":("Lecture","Resultats et champs",)},
               fr="Lire dans un fichier, soit format IDEAS, soit au format ENSIGHT soit au format MED,"
                 +" des champs et les stocker dans une SD résultat",


# 0) mots cles generaux :
#----------------------
         TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("EVOL_THER","EVOL_ELAS","EVOL_NOLI","MODE_MECA",
                                                          "MODE_MECA_C","DYNA_TRANS","DYNA_HARMO",
                                                          "EVOL_CHAR","EVOL_VARC") ),

         FORMAT          =SIMP(statut='o',typ='TXM',into=("IDEAS","IDEAS_DS58","ENSIGHT","MED") ),

         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),

         regles=(UN_PARMI('MAILLAGE','MODELE'),),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),
         COMPORTEMENT       =C_COMPORTEMENT(),
         NB_VARI         =SIMP(statut='f',typ='I' ),

         CHAM_MATER      =SIMP(statut='f',typ=cham_mater,),

         CARA_ELEM       =SIMP(statut='f',typ=cara_elem,),

          b_evol_elas  = BLOC(condition="TYPE_RESU=='EVOL_ELAS'",
          EXCIT           =FACT(statut='f',max='**',
            CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
            FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),),
           ),

          b_evol_ther  = BLOC(condition="TYPE_RESU=='EVOL_THER'",
          EXCIT           =FACT(statut='f',max='**',
            CHARGE          =SIMP(statut='o',typ=(char_ther,char_cine_ther)),
            FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),),
           ),

          b_evol_noli  = BLOC(condition="TYPE_RESU=='EVOL_NOLI'",
          EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),),
         ),


# 1) blocs selon le format choisi :
#---------------------------------

# 1-1 ideas dataset-58 :
# ----------------------
         b_dataset_58 = BLOC(condition="FORMAT=='IDEAS_DS58'",
           UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
         ),
         b_dataset_58_b = BLOC(condition="(FORMAT=='IDEAS_DS58') and ((TYPE_RESU=='DYNA_TRANS') or\
                                        (TYPE_RESU=='DYNA_HARMO'))",
           NOM_CHAM=SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=("DEPL","VITE","ACCE","EPSI_NOEU","SIEF_NOEU",),max='**'),
           REDEFI_ORIENT=FACT(statut='f',max='**',
                              regles=(PRESENT_PRESENT('CODE_DIR','DIRECTION','NOEUD',),),
                              CODE_DIR =SIMP(statut='f',typ='I',into=(1,2,3,) ),
                              DIRECTION=SIMP(statut='f',typ='R',min=3,max=3,),
                              NOEUD    =SIMP(statut='f',typ=no,validators=NoRepeat(),max='**'),),
         ),

# 1-2 ideas  :
# ---------
         b_ideas         =BLOC(condition="FORMAT=='IDEAS'",
           UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
#           TEST            =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=l_nom_cham_pas_elga()),
           PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",),
             fr="Affecte des valeurs nulles la ou le champ n'est pas defini"),
           FORMAT_IDEAS    =FACT(statut='f',max='**',
             regles=(UN_PARMI('POSI_INST','POSI_FREQ'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=l_nom_cham_pas_elga()),
             NUME_DATASET    =SIMP(statut='f',typ='I',into=(55,57,2414) ),
             RECORD_3        =SIMP(statut='f',typ='I',max=10),
             RECORD_6        =SIMP(statut='f',typ='I',max=10),
             RECORD_9        =SIMP(statut='f',typ='I',max=10),
             POSI_ORDRE      =SIMP(statut='o',typ='I',min=2,max=2),
             POSI_NUME_MODE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_MASS_GENE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_AMOR_GENE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_INST       =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_FREQ       =SIMP(statut='f',typ='I',min=2,max=2),
             NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),),
         ),

# 1-3 ensight :
# -------------
         b_ensight       =BLOC(condition="FORMAT=='ENSIGHT'",
           NOM_FICHIER     =SIMP(statut='f',typ='TXM'),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=l_nom_cham_pas_elga()),
         ),

# 1-4 med :
# ---------
         b_med           =BLOC(condition = "FORMAT == 'MED'",fr="Nom du champ dans le fichier MED",
           UNITE           =SIMP(statut='f',typ='I',defaut= 81, fr="Le fichier est : fort.n.",),
           FORMAT_MED      =FACT(statut='o',max='**',
             regles=(ENSEMBLE('NOM_CMP','NOM_CMP_MED'),UN_PARMI('NOM_CHAM_MED','NOM_RESU'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),),
             NOM_CHAM_MED    =SIMP(statut='f',typ='TXM',               fr="Nom du champ dans le fichier MED.",  ),
             NOM_RESU        =SIMP(statut='f',typ='TXM',               fr="Prefixe du nom de champ dans le fichier MED.",  ),
             NOM_CMP         =SIMP(statut='f',typ='TXM',max='**',      fr="Nom des composantes dans ASTER.", ),
             NOM_CMP_MED     =SIMP(statut='f',typ='TXM',max='**',      fr="Nom des composantes dans MED.", ),
           ),
           PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",),
            fr="Affecte des valeurs nulles la ou le champ n'est pas defini (sinon il y a NaN)"),
         ),

# 2) blocs selon le type du resultat :
#---------------------------------
         b_mode_meca     =BLOC(condition="(TYPE_RESU=='MODE_MECA')or(TYPE_RESU=='MODE_MECA_C')",
           # Ces mots cles sont stockes dans l'objet .REFD des mode_meca
           # Ces mots cles sont aussi utilises  pour imposer la numerotation des cham_no de DEPL_R
           MATR_RIGI        =SIMP(statut='f',typ=matr_asse_depl_r,max=1),
           MATR_MASS        =SIMP(statut='f',typ=matr_asse_depl_r,max=1),
         ),


# 3) autres blocs :
#---------------------------------
         b_extrac        =BLOC(condition="1",fr="acces a un champ dans la structure de donnees resultat",
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST','FREQ','LIST_FREQ'),),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

           b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)or(FREQ != None)or(LIST_FREQ != None)",
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
           ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr


LIRE_TABLE=MACRO(nom="LIRE_TABLE",
                 op=OPS('Macro.lire_table_ops.lire_table_ops'),
                 sd_prod=table_sdaster,
                 fr="Lecture d'un fichier contenant une table",
                 UIinfo={"groupes":("Lecture","Tables",)},
         UNITE           = SIMP(statut='o', typ='I' ),
         FORMAT          = SIMP(statut='f', typ='TXM', into=("ASTER", "LIBRE", "TABLEAU"), defaut="TABLEAU"),
         NUME_TABLE      = SIMP(statut='f', typ='I', defaut=1),
         SEPARATEUR      = SIMP(statut='f', typ='TXM', defaut=' '),
         RENOMME_PARA    = SIMP(statut='f', typ='TXM', into=("UNIQUE",),),
         TITRE           = SIMP(statut='f', typ='TXM', max='**'),
         INFO            = SIMP(statut='f', typ='I', into=(1, 2), ),
         )  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr

MAC_MODES=OPER(nom="MAC_MODES",op=  141,sd_prod=table_sdaster,
               fr="Critere orthogonalite de modes propres",
               reentrant='n',
               UIinfo={"groupes":("Résolution","Dynamique",)},
               regles=(PRESENT_PRESENT('IERI','MATR_ASSE'),),
         BASE_1     =SIMP(statut='o',typ=(mode_meca,mode_meca_c,mode_flamb) ),
         BASE_2     =SIMP(statut='o',typ=(mode_meca,mode_meca_c,mode_flamb) ),
         MATR_ASSE  =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c) ),
         IERI       =SIMP(statut='f',typ='TXM',into=("OUI",),),
         TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         INFO       =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: gerald.nicolas at edf.fr
#
def macr_adap_mail_prod(self, MAJ_CHAM, ADD_CHAM, ADAPTATION, **args):
#
# 0. Typage des structures produites
#
  #print args
  if ( args.has_key('MAILLAGE_NP1') ) :
    if ( args['MAILLAGE_NP1'] is not None ) :
      maillage_np1=args['MAILLAGE_NP1']
      self.type_sdprod(maillage_np1, maillage_sdaster)
#
  if ( args.has_key('MAILLAGE_NP1_ANNEXE') ) :
    if ( args['MAILLAGE_NP1_ANNEXE'] is not None ) :
      maillage_np1_annexe=args['MAILLAGE_NP1_ANNEXE']
      self.type_sdprod(maillage_np1_annexe, maillage_sdaster)
#
  #print "MAJ_CHAM =", MAJ_CHAM
  if MAJ_CHAM is not None :
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
    for ch in MAJ_CHAM:
      t=ch['TYPE_CHAM']
      if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],cham_no_sdaster)
      if t[0:2] == "EL":   self.type_sdprod(ch['CHAM_MAJ'],cham_elem)
#
  #print "ADD_CHAM =", ADD_CHAM
  if ADD_CHAM is not None :
    for ch in ADD_CHAM:
      self.type_sdprod(ch['CHAM_GD'],carte_sdaster)
#
  return None

MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",
                     op=OPS('Macro.macr_adap_mail_ops.macr_adap_mail_ops'),
                     sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with the HOMARD software.",
                     UIinfo={"groupes":("Maillage",)},
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4)),
#
# 2. Les maillages
# 2.1. Quel que soit le type de traitement, il faut donner le concept du maillage initial (entree)
#
  MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),
#
# 2.2. Si ce n'est pas une simple lecture :
#
  b_maillage = BLOC( condition = " (ADAPTATION != 'LECTURE') " ,
                          fr="Lectures de champs aux points de Gauss ou aux noeuds par element.",
                          ang="Readings of the fields over the Gauss points.",
#
# 2.2.1. Le concept du maillage final (sortie)
#
    MAILLAGE_NP1 = SIMP(statut='o',typ=CO,
                        fr="Maillage après adaptation",
                        ang="Mesh after adaptation" ),
#
# 2.2.2. Eventuellement, on peut produire un maillage annexe
#      Actuellement, c'est le maillage n+1, mais de degré différent.
#
    MAILLAGE_NP1_ANNEXE = SIMP(statut='f',typ=CO,
                              fr="Maillage annexe après adaptation",
                              ang="Additional mesh after adaptation" ),
#
  ) ,
#
# 3. Le pilotage de l'adaptation, avec les variantes suivantes :
#  . Raffinement et deraffinement, selon un champ
#  . Raffinement seul, selon un champ
#  . Deraffinement seul, selon un champ
#  . Raffinement et deraffinement, selon des zones geometriques
#  . Raffinement uniforme : toutes les mailles sont divisées
#  . Deraffinement uniforme : toutes les mailles sont regroupées
#  . Modification : le maillage subit des transformations specifiques
#  . Rien : le maillage est le meme a la sortie et a l'entree
#
  ADAPTATION = SIMP(statut='o',typ='TXM',
                    into=("RAFF_DERA", "RAFFINEMENT", "DERAFFINEMENT", "RAFF_DERA_ZONE", \
                          "RAFFINEMENT_UNIFORME", "DERAFFINEMENT_UNIFORME", \
                          "MODIFICATION", "LECTURE", "RIEN"),
                    fr="Pilotage de l'adaptation : selon un champ ou uniforme.",
                    ang="Adaptation control: either among an field or uniform" ),
#
# 4. Pour de l'adaptation libre, il faut un champ d'indicateur
#
  b_champ = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                (ADAPTATION == 'RAFFINEMENT') or \
                                (ADAPTATION == 'DERAFFINEMENT') " ,
                  fr="Pour une adaptation libre, choix du champ définissant la région à raffiner/déraffiner",
                  ang="For a free adaptation, selection of the field that defines the area for refinment/unrefinement",
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT_N')),
#
# 4.1. Reperage de la région a raffiner a l'aide d'un champ
#
# 4.1.1. Sous forme de champ de grandeur
#
    CHAM_GD    = SIMP(statut='f',typ=cham_gd_sdaster,
                      fr="Champ de grandeur Code_Aster pilotant l'adaptation",
                      ang="Code_Aster 'champ de grandeur' governing the adapatation" ),
#
# 4.1.2. Sous forme de concept resultat_sdaster
#
    RESULTAT_N = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther) ,
                      fr="Concept résultat Code_Aster contenant le champ",
                      ang="The Code_Aster result with the field" ),
#
    b_champ_adaptation = BLOC(condition="(RESULTAT_N != None)",
      NOM_CHAM = SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),
                        fr="Champ dans le résultat",
                        ang="The field in the result structure" ),
    ),
#
# 4.1.4. La ou les composantes retenues
#
    NOM_CMP = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Liste des composante(s) retenue(s) pour le champ.",
                          ang="List of the selected component(s) for the field." ),
#
# 4.1.5. Le paramètre temporel pour le champ
#
    b_parametre_temporel = BLOC(condition="(RESULTAT_N != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 4.1.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numéro d ordre",
                        ang="Rank" ),
#
# 4.1.5.2. Soit l'instant
# 4.1.5.2.1. Sa valeur
#
      INST       = SIMP(statut='f',typ='R',
                        fr="Instant associé",
                        ang="Instant" ),
#
# 4.1.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Precision for the choice of the instant",
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF", "ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
      ),
#
    ),
#
# 4.1.6. Usage des composantes : maximum, maximum de la valeur absolue, ou de la norme L2, ou de la norme infinie
#
    USAGE_CMP = SIMP(statut='f',typ='TXM',defaut="NORME_L2",
                      into=("ABSOLU", "NORME_L2", "NORME_INFINIE", "RELATIF"),
                      fr="Valeur absolue de la composante, ou norme du champ, ou valeur relative de la composante",
                      ang="Absolute value of the component, or norm of the field, or relative value of the component" ),
#
# 4.1.7. Usage du champ : la valeur par maille ou le max du saut entre mailles
#
    USAGE_CHAMP = SIMP(statut='f',typ='TXM',defaut="MAILLE",into=("MAILLE", "SAUT"),
                        fr="Usage du champ : la valeur par maille ou le saut entre mailles voisines",
                        ang="Use of the field: value over every mesh or jump between the neighbours" ),
#
# 4.1.8. Initialisation de l'adaptation : raffinement ou déraffinement
#
    ADAP_INIT = SIMP(statut='f',typ='TXM',defaut="GARDER",into=("GARDER", "DERAFFINER"),
                        fr="Initialisation de l'adaptation dans les régions sans indicateur : garder ou déraffiner",
                        ang="Initialization of the adaptation in the areas without indicator: keep or unrefine" ),
#
  ) ,
#
# 5. Les criteres pour de l'adaptation libre avec un champ :
#        absolu, relatif, en proportion d'entite
# 5.1. Pour le raffinement :
#
  b_critere_de_raffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                 (ADAPTATION == 'RAFFINEMENT') " ,
                                fr="Critère de raffinement.",
                                ang="Refinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE', 'CRIT_RAFF_MS' ),),
#
    CRIT_RAFF_ABS = SIMP(statut='f',typ='R',
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_RAFF_REL = SIMP(statut='f',typ='R',val_min=0.0,val_max=1.0,
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),
    CRIT_RAFF_PE  = SIMP(statut='f',typ='R',val_min=0.0,val_max=1.0,
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes: ratio between 0. and 1." ),
    CRIT_RAFF_MS  = SIMP(statut='f',typ='R',
                         fr="Critère absolu valant moyenne + n*sigma, n étant > 0",
                         ang="Absolute threshold: mean + n*sigma, with n > 0" ),
  ) ,
#
# 5.2. Pour le deraffinement :
#
  b_critere_de_deraffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') " ,
                                     fr="Critère de déraffinement.",
                                     ang="Unrefinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE', 'CRIT_DERA_MS' ),),
#
    CRIT_DERA_ABS = SIMP(statut='f',typ='R' ,
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_DERA_REL = SIMP(statut='f',typ='R',val_min=0.0,val_max=1.0,
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold: ratio between 0. and 1." ),
    CRIT_DERA_PE  = SIMP(statut='f',typ='R',val_min=0.0,val_max=1.0,
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes: ratio between 0. and 1." ),
    CRIT_DERA_MS  = SIMP(statut='f',typ='R',
                         fr="Critère absolu valant moyenne - n*sigma, n étant > 0",
                         ang="Absolute threshold: mean - n*sigma, with n > 0" ),
  ) ,
#
# 6. Pour de l'adaptation par zone, définitions des zones
#
  b_zone = BLOC( condition = " (ADAPTATION == 'RAFF_DERA_ZONE') " ,
                 fr="Pour une adaptation selon une zone à raffiner",
                 ang="For adaptation among a zone",
#
    ZONE = FACT(statut='o',min=1,max='**',
                fr="Définition de zones à raffiner.",
                ang="Refined zone definition.",
#
# 6.1. Type de la zone
#
      TYPE = SIMP(statut='o',typ='TXM',into=("RECTANGLE", "BOITE", "DISQUE", "SPHERE", "CYLINDRE", "DISQUE_PERCE", "TUYAU"),
                  fr="Type de la zone",
                  ang="Type of the zone" ),
#
# 6.2. Usage de la zone
#
      USAGE = SIMP(statut='f',typ='TXM',into=("RAFFINEMENT","DERAFFINEMENT"),defaut="RAFFINEMENT",
                   fr="Zone pour raffiner",
                   ang="Zone: refinement" ),
#
# Ne sachant pas exploiter les blocs, je mets des regles
#
      regles=(AU_MOINS_UN('X_MINI','X_CENTRE','HAUTEUR'),
              EXCLUS('X_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','RAYON',),
              EXCLUS('Z_MINI','RAYON',),
              EXCLUS('RAYON','RAYON_INT',),),
#
# 6.3. Une boite rectangulaire ou parallelepipedique
# 6.3.1. Incontournables
#
##gn      b_z_boiteXY = BLOC( condition = " (TYPE == 'RECTANGLE') or (TYPE == 'BOITE') " ,
##gn                          fr="X et Y mini/maxi pour un rectangle ou un parallelepipede.",
##gn                          ang="X and Y min/max for a rectangle or a parallelepipedic box",
      X_MINI = SIMP(statut='f',typ='R',
                    fr="Abscisse minimum de la boite",
                    ang="Minimum X for the box"),
      X_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum X for the box"),
      Y_MINI = SIMP(statut='f',typ='R',
                    fr="Ordonnée minimum de la boite",
                    ang="Minimum Y for the box"),
      Y_MAXI = SIMP(statut='f',typ='R',
                      fr="Abscisse maximum de la boite",
                      ang="Maximum Y for the box"),
##gn      ) ,
#
# 6.3.2. Complement pour une boite parallelepipedique
#
##gn      b_z_boiteZ = BLOC( condition = " (TYPE == 'BOITE') " ,
##gn                         fr="Z mini/maxi pour un parallelepipede.",
##gn                         ang="Z min/max for a parallelepipedic box",
      Z_MINI = SIMP(statut='f',typ='R',
                    fr="Cote minimum de la boite",
                    ang="Minimum Z for the box"),
      Z_MAXI = SIMP(statut='f',typ='R',
                    fr="Cote maximum de la boite",
                    ang="Maximum Z for the box"),
##gn      ) ,
#
# 6.4. Rayon pour un disque, une sphere ou un cylindre
#
##gn      b_z_rayon = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
##gn                        fr="Le rayon d'un disque, d'une sphere ou d'un cylindre.",
##gn                        ang="The radius of a disk or of a sphere or of a cylinder.",
      RAYON = SIMP(statut='f',typ='R',
                   fr="Rayon",
                   ang="Radius"),
##gn      ) ,
#
# 6.5. Pour un disque plein ou perce, une sphere
# 6.5.1. Incontournables
#
##gn      b_z_di_sp_XY = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'DISQUE_PERCE') " ,
##gn                           fr="X et Y du centre d'un disque plein ou perce, d'une sphere.",
##gn                           ang="X and Y of the centre of a disk or of a sphere.",
      X_CENTRE = SIMP(statut='f',typ='R',
                      fr="Abscisse du centre du disque ou de la sphère",
                      ang="X for the center of the disk or of the sphere"),
      Y_CENTRE = SIMP(statut='f',typ='R',
                      fr="Ordonnée du centre du disque ou de la sphère",
                      ang="Y for the center of the disk or of the sphere"),
##gn      ) ,
#
# 6.5.2. Complement pour une sphere
#
##gn      b_z_sp_Z = BLOC( condition = " (TYPE == 'SPHERE') " ,
##gn                       fr="Cote du centre de la sphere.",
##gn                       ang="Z for the center of the sphere.",
       Z_CENTRE = SIMP(statut='f',typ='R',
                       fr="Cote du centre de la sphère",
                       ang="Z for the center of the sphere"),
##gn      ) ,
#
# 6.6. Rayons interieur et exterieur pour un disque perce ou un tuyau
#
##gn      b_z_rayon_int_ext = BLOC( condition = " (TYPE == 'DISQUE_PERCE') or (TYPE == 'TUYAU') " ,
##gn                                fr="Le rayon d'un disque perce ou d'un tuyau.",
##gn                                ang="The radius of a holed disk or of a pipe.",
      RAYON_INT = SIMP(statut='f',typ='R',
                       fr="Rayon intérieur",
                       ang="Internal radius"),
      RAYON_EXT = SIMP(statut='f',typ='R',
                       fr="Rayon extérieur",
                       ang="External radius"),
##gn      ) ,
#
# 6.7. Un cylindre ou un tuyau
#
##gn      b_z_cylindre_tuyau = BLOC( condition = " (TYPE == 'CYLINDRE') or (TYPE == 'TUYAU') " ,
##gn                                 fr="Pour un cylindre ou un tuyau.",
##gn                                 ang="For a cylinder or a pipe.",
      X_AXE = SIMP(statut='f',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='f',typ='R',
                   fr="Ordonnée du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='f',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
      X_BASE = SIMP(statut='f',typ='R',
                    fr="Abscisse d'un point de la base, sur l'axe",
                    ang="X for the basis, on the axis"),
      Y_BASE = SIMP(statut='f',typ='R',
                    fr="Ordonnée d'un point de la base, sur l'axe",
                    ang="Y for the basis, on the axis"),
      Z_BASE = SIMP(statut='f',typ='R',
                    fr="Cote d'un point de la base, sur l'axe",
                    ang="Z for the basis, on the axis"),
      HAUTEUR = SIMP(statut='f',typ='R',
                     fr="Hauteur",
                     ang="Height"),
##gn     ) ,
#
    ) ,
#
  ) ,
#
# 7. Les niveaux extremes pour le maillage adapte
# 7.1. Pour le raffinement :
#
  b_niveau_maximum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'RAFFINEMENT') or \
                                         (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                         (ADAPTATION == 'RAFF_DERA_ZONE') " ,
                           fr="Profondeur maximale de raffinement",
                           ang="Maximum depth for the refinement",
#
    NIVE_MAX = SIMP(statut='f',typ='I',
                    fr="Niveau maximum de profondeur de raffinement",
                    ang="Maximum level for the refinement"),
#
    DIAM_MIN = SIMP(statut='f',typ='R',
                    fr="Diamètre minimal des mailles",
                    ang="Minimal diameter for the meshes" ),
#
  ) ,
#
# 7.2. Pour le deraffinement :
#
  b_niveau_minimum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'DERAFFINEMENT') or \
                                         (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for the unrefinement",
    NIVE_MIN = SIMP(statut='f',typ='I',
                    fr="Niveau minimum de profondeur de déraffinement",
                    ang="Minimum level for the unrefinement"),
  ) ,
#
# 8. Filtrage de l'adaptation par des groupes
#
  b_filtrage_par_des_groupes = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'RAFFINEMENT') or \
                                                   (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                                   (ADAPTATION == 'RAFF_DERA_ZONE') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') or \
                                                   (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                                fr="Filtrage de l'adaptation par des groupes.",
                                ang="Filtering of adaptation by the groups.",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles pour le filtrage de l'adaptation.",
                    ang="List of the groups of meshes for filtering of the adaptation." ),
#
    GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de noeuds pour le filtrage de l'adaptation.",
                    ang="List of the groups of nodes for filtering of the adaptation." ),
  ) ,
#
# 9. Suivi d'une frontière
#
# 9.1. Definition d'une frontière par un maillage (valable seulement pour des frontières 1D)
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontière discrète à suivre",
                           ang="Discrete boundary mesh" ),
#
  b_FRONTIERE = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière discrète",
                      ang="Further information about discrete boundary",
#
    GROUP_MA_FRONT = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Liste des groupes de mailles définissant la frontière discrète",
                          ang="Mesh groups which define the discrete boundary" ),
#
  ) ,
#
# 9.2. Definition analytique d'une frontière
#
  FRONTIERE_ANALYTIQUE = FACT(statut='f',max='**',
                              fr="Definition analytique de frontières a suivre.",
                              ang="Analytical definition of a boundary.",
#
# 9.2.1. Nom de la frontière
#
    NOM = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
               fr="Nom de la frontière analytique",
               ang="Name of the analytic boundary" ),
#
# 9.2.2. Type de la frontière
#
    TYPE = SIMP(statut='o',typ='TXM',into=("SPHERE", "CYLINDRE"),
                fr="Type de la frontière analytique",
                ang="Type of the analytic boundary" ),
#
# 9.2.3. Pour une sphere, un cylindre par ses rayons : rayon et centre
#
    b_fr_rayon = BLOC( condition = " (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
                       fr="Le rayon et le centre d'une sphère ou d'un cylindre.",
                       ang="The radius and the centre of a sphere or of a cylinder.",
      RAYON = SIMP(statut='o',typ='R',
                   fr="Rayon",
                   ang="Radius"),
      X_CENTRE = SIMP(statut='o',typ='R',
                      fr="Abscisse du centre",
                      ang="X for the center"),
      Y_CENTRE = SIMP(statut='o',typ='R',
                      fr="Ordonnée du centre",
                      ang="Y for the center"),
      Z_CENTRE = SIMP(statut='o',typ='R',
                      fr="Cote du centre",
                      ang="Z for the center"),
    ) ,
#
# 9.2.4. Pour un cylindre defini par axe et angle : axe
#
    b_fr_cylindre = BLOC( condition = " (TYPE == 'CYLINDRE') " ,
                          fr="Pour un cylindre.",
                          ang="For a cylinder.",
      X_AXE = SIMP(statut='o',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='o',typ='R',
                   fr="Ordonnée du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='o',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
    ) ,
#
# 9.2.7. Groupe(s) lie(s) a la frontière
#
    GROUP_MA = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles placées sur la frontière",
                    ang="Groups of meshes which are located on the boundary" ),
#
  ) ,
#
# 10. mise à jour de champs sur le nouveau maillage
#
  MAJ_CHAM = FACT(statut='f',max='**',
                  fr="Mise à jour de champs sur le nouveau maillage.",
                  ang="Updating of the fields over the new mesh.",
#
# 10.1. Le nom du champ de grandeur qui contiendra le resultat de la mise a jour
#
    CHAM_MAJ = SIMP(statut='o',typ=CO,
                    fr="Nom du champ de grandeur qui contiendra le champ mis à jour",
                    ang="Name of the field for the updated field"),
#
# 10.2. Le type du champ qui contiendra le resultat de la mise a jour
#
    TYPE_CHAM = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO( ('NOEU', 'ELEM', 'ELNO', 'ELGA') ),
                     fr="Type du champ qui contiendra le champ mis à jour",
                     ang="Type of the field for the updated field" ),
#
# 10.3. Le champ a interpoler
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT')),
#
# 10.3.1. Sous forme de champ de grandeur
#
    CHAM_GD = SIMP(statut='f',typ=cham_gd_sdaster,
                   fr="Champ de grandeur Code_Aster contenant le champ à mettre à jour",
                   ang="Champ de grandeur with the field to be updated" ),
#
# 10.3.2. Sous forme de champ dans un resultat
#
    RESULTAT = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                    fr="Résultat contenant le champ à mettre à jour",
                    ang="Result with the field to be updated" ),
#
    b_nom_du_champ = BLOC(condition="(RESULTAT != None)",
                          fr="Choix éventuel du nom du champ à interpoler",
                          ang="Selection for the name of the field (option)",
#
      NOM_CHAM = SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),
                      fr="Nom du champ à mettre à jour",
                      ang="Name of the field to be updated" ),
#
    ),
#
# 10.4. Les composantes
#
    NOM_CMP = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                   fr="Liste des composante(s) retenue(s) pour le champ.",
                   ang="List of the selected component(s) for the field." ),
#
# 10.5. Le paramètre temporel pour le champ a interpoler
#
    b_parametre_temporel = BLOC(condition="(RESULTAT != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ à interpoler",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 10.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numéro d ordre du champ à mettre à jour",
                        ang="Rank of the field to be updated" ),
#
# 10.5.2. Soit l'instant
# 10.5.2.1. Sa valeur
#
      INST = SIMP(statut='f',typ='R',
                  fr="Instant associé",
                  ang="Instant" ),
#
# 10.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for the choice of the instant",
#
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF", "ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
#
      ),
#
    ),
#
# 10.6. Type d'interpolation
#
    TYPE_MAJ = SIMP(statut='f',typ='TXM',defaut="AUTO",
                    into=("AUTO", "ISOP2"),
                    fr="Type de mise à jour : automatique ou iso-P2",
                    ang="Type of the updating" ),
  ),
#
# 11. Les modifications
#
  b_modifications = BLOC( condition = " (ADAPTATION == 'MODIFICATION') " ,
                          fr="Modification de maillage.",
                          ang="Modification of the mesh.",
#
      #regles=(AU_MOINS_UN('DEGRE','JOINT'),),
#
# 11.1. Changement de degre
#
      DEGRE         = SIMP(statut='o',typ='TXM',into=("OUI",),
                          fr="Changement de degré du maillage",
                          ang="Modification of the degree of the mesh" ),
#
  ) ,
#
# 12. Le modele pour les lectures de champs aux points de Gauss ou aux noeuds par element
#
  b_lectures = BLOC( condition = " (ADAPTATION == 'LECTURE') " ,
                          fr="Lectures de champs aux points de Gauss.",
                          ang="Readings of the fields over the Gauss points.",
#
      MODELE        = SIMP(statut='o',typ=modele_sdaster,
                          fr="Modèle",
                          ang="Model" ),
#
  ) ,
#
# 13. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
#
  b_analyses = BLOC( condition = " (ADAPTATION != 'LECTURE') " ,
                     fr="Analyse du maillage.",
                     ang="Analysis of the mesh.",
#
# 13.1. Nombre de noeuds et mailles
#
    NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                          fr="Nombre de noeuds et de mailles du maillage",
                          ang="Number of nodes and meshes in the mesh" ),
#
# 13.2. Determination de la qualité des mailles du maillage
#
    QUALITE        = SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Qualité du maillage",
                          ang="Quality of the mesh" ),
#
# 13.3. Connexite du maillage
#
    CONNEXITE      = SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Connexité du maillage.",
                          ang="Connexity of the mesh." ),
#
# 13.4. Taille des sous-domaines du maillage
#
    TAILLE         = SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Tailles des sous-domaines du maillage.",
                          ang="Sizes of mesh sub-domains." ),
#
# 13.5. Controle de la non-interpenetration des mailles
#
    INTERPENETRATION=SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Controle de la non interpénétration des mailles.",
                          ang="Overlapping checking." ),
#
# 13.6. Propriétés du maillage de calcul
#
    PROP_CALCUL    = SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Propriétés du maillage de calcul.",
                          ang="Properties of the calculation mesh." ),
#
# 13.7. Determination des diametres des mailles du maillage
#
    DIAMETRE       = SIMP(statut='f',typ='TXM',into=("OUI",),
                          fr="Diamètre du maillage",
                          ang="Diameters of the mesh" ),
#
  ) ,
#
# 14. champs supplementaires sur le nouveau maillage
#
  ADD_CHAM = FACT(statut='f',max='**',
                  fr="Champs supplementaires sur le nouveau maillage.",
                  ang="Additional fields over the new mesh.",
#
# 14.1. Le nom du champ de grandeur qui contiendra le nouveau champ
#
    CHAM_GD = SIMP(statut='o',typ=CO,
                  fr="Nom du champ de grandeur qui contiendra le champ supplementaire",
                  ang="Name of the field for the additional field"),
#
# 14.2. La categorie du champ supplementaire
#
    CHAM_CAT = SIMP(statut='o',typ='TXM',into=("NIVEAU", "DIAMETRE"),
                    fr="Categorie du champ supplementaire : niveau ou diametre",
                    ang="Category of the additional field: level or diameter" ),
#
  ) ,
#
# 15. Les options avancées
# 15.1. Langue des messages issus de HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",
                into=("FRANCAIS", "FRENCH", "ANGLAIS", "ENGLISH",),
                fr="Langue des messages issus de HOMARD.",
                ang="Language for HOMARD messages." ),
#
# 15.2. Gestion des mailles acceptees dans le maillage initial
#       "HOMARD" : exclusivement les mailles pouvant etre decoupees (defaut)
#       "IGNORE_PYRA" : elles sont ignorées
#
  b_autres_mailles = BLOC( condition = " (ADAPTATION != 'LECTURE') " ,
                           fr="Gestion des pyramides.",
                           ang="Pyramids.",
#
    ELEMENTS_ACCEPTES = SIMP(statut='f',typ='TXM',defaut="HOMARD",into=("HOMARD", "IGNORE_PYRA"),
                             fr="Acceptation des mailles dans le maillage initial",
                             ang="Elements in the very first mesh" ),
#
  ) ,
#
# 15.3. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V10_6",
                        into=("V10_6", "V10_N", "V10_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 15.4. Exécutable pilotant HOMARD
#
  LOGICIEL = SIMP(statut='f',typ='TXM',
                  fr="Logiciel pilotant HOMARD",
                  ang="HOMARD software"),
#
# 15.5. Unite logique d'un fichier à ajouter a HOMARD.Configuration
#
  b_unite = BLOC( condition = " (VERSION_HOMARD == 'V10_N') or \
                                (VERSION_HOMARD == 'V10_N_PERSO') " ,
                                fr="Fichier supplementaire.",
                                ang="Additional file.",
#
  UNITE = SIMP(statut='f',typ='I',
               fr="Unite logique a ajouter a HOMARD.Configuration",
               ang="Additional file to HOMARD.Configuration" ),
#
  ) ,
#
) ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

def macr_ascouf_calc_prod(self,MODELE,CHAM_MATER,CARA_ELEM,FOND_FISS,RESU_THER,**args):
  self.type_sdprod(MODELE,modele_sdaster)
  if CHAM_MATER != None:self.type_sdprod(CHAM_MATER,cham_mater)
  if CARA_ELEM  != None:self.type_sdprod(CARA_ELEM,cara_elem)
  if FOND_FISS  != None:self.type_sdprod(FOND_FISS,fond_fiss)
  if RESU_THER  != None:self.type_sdprod(RESU_THER,evol_ther)
  return evol_noli

MACR_ASCOUF_CALC=MACRO(nom="MACR_ASCOUF_CALC",
                       op=OPS('Macro.macr_ascouf_calc_ops.macr_ascouf_calc_ops'),
                       sd_prod=macr_ascouf_calc_prod,
                       fr="Réalise l'analyse thermomécanique du coude dont le maillage a " \
                          "été concu par MACR_ASCOUF_MAIL",
                       reentrant='n',
                       UIinfo={"groupes":("Résolution","Outils-métier",)},

         TYPE_MAILLAGE   =SIMP(statut='o',typ='TXM',
                               into=("SAIN",
                                     "FISS_COUDE",
                                     "FISS_AXIS_DEB",
                                     "SOUS_EPAIS_COUDE"
                                     ) ),

         CL_BOL_P2_GV    =FACT(statut='f',
           ANGLE           =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),
         ),

         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
         MODELE          =SIMP(statut='o',typ=CO,),
         CHAM_MATER      =SIMP(statut='f',typ=CO,),
         CARA_ELEM       =SIMP(statut='f',typ=CO,),
         FOND_FISS       =SIMP(statut='f',typ=CO,),
         RESU_THER       =SIMP(statut='f',typ=CO,),

         AFFE_MATERIAU   =FACT(statut='o',max=3,
           regles=(UN_PARMI('TOUT','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,into=("COUDE","BOL") ),
           MATER           =SIMP(statut='o',typ=mater_sdaster ),
           TEMP_REF        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),

         PRES_REP        =FACT(statut='f',
           PRES            =SIMP(statut='o',typ='R' ),
           EFFE_FOND_P1    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRES_LEVRE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         ECHANGE         =FACT(statut='f',
           COEF_H          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         TORS_P1         =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           FX              =SIMP(statut='f',typ='R' ),
           FY              =SIMP(statut='f',typ='R' ),
           FZ              =SIMP(statut='f',typ='R' ),
           MX              =SIMP(statut='f',typ='R' ),
           MY              =SIMP(statut='f',typ='R' ),
           MZ              =SIMP(statut='f',typ='R' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),


         COMPORTEMENT       =C_COMPORTEMENT('MACR_ASCOUF_CALC'),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MACR_ASCOUF_CALC'),
#-------------------------------------------------------------------

         CONVERGENCE     =C_CONVERGENCE(),

         NEWTON          =C_NEWTON(),

         RECH_LINEAIRE   =C_RECH_LINEAIRE(),

         INCREMENT       =C_INCREMENT('MECANIQUE'),

         THETA_3D        =FACT(statut='f',max='**',
           R_INF           =SIMP(statut='o',typ='R' ),
           R_SUP           =SIMP(statut='o',typ='R' ),
         ),

         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),

         IMPR_TABLE      =FACT(statut='f',
           regles=(UN_PARMI('TOUT_PARA','NOM_PARA', ),
            PRESENT_PRESENT('TOUT_PARA','ANGLE',    ),
            PRESENT_PRESENT('TOUT_PARA','R_CINTR',  ),
                   UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL',),),
           NOM_PARA        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=4,
                                 into=("TRESCA_MEMBRANE",
                                       "TRESCA_MFLE",
                                       "TRESCA",
                                       "SI_LONG"
                                       "SI_RADI"
                                       "SI_CIRC"
                                       ) ),
           TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           ANGLE           =SIMP(statut='f',typ='R', ),
           R_CINTR         =SIMP(statut='f',typ='R', ),
           POSI_CURV_LONGI =SIMP(statut='f',typ='R', ),
           POSI_ANGUL      =SIMP(statut='f',typ='R', ),
           TRANSFORMEE     =SIMP(statut='f',typ='TXM',defaut="COUDE",into=("COUDE","TUBE") ),
         ),

         IMPRESSION      =FACT(statut='f',
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",
                                 into=("RESULTAT","ASTER","IDEAS","CASTEM") ),

           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),

         ),

         TITRE           =SIMP(statut='f',typ='TXM' ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

MACR_ASCOUF_MAIL=MACRO(nom="MACR_ASCOUF_MAIL",
                       op=OPS('Macro.macr_ascouf_mail_ops.macr_ascouf_mail_ops'),
                       sd_prod=maillage_sdaster,
                       fr="Engendre le maillage d'un coude sain ou comportant une fissure ou une (ou plusieurs) sous-épaisseur(s)",
                       UIinfo={"groupes":("Maillage","Outils-métier",)},
                       reentrant='n',

         regles=(EXCLUS('SOUS_EPAIS_COUDE','FISS_COUDE','SOUS_EPAIS_MULTI'),),

         EXEC_MAILLAGE   =FACT(statut='o',
           LOGICIEL        =SIMP(statut='o',typ='TXM',defaut="GIBI2000",into=("GIBI98","GIBI2000") ),
           UNITE_DATG      =SIMP(statut='f',typ='I',defaut=70),
           UNITE_MGIB      =SIMP(statut='f',typ='I',defaut=19),
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,4,5,6,7,8,9,10,11)),
         ),

         TYPE_ELEM       =SIMP(statut='f',typ='TXM',defaut="CU20",into=("CU20","CUB8") ),

         COUDE           =FACT(statut='o',
           ANGLE           =SIMP(statut='o',typ='R' ),
           R_CINTR         =SIMP(statut='o',typ='R' ),
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),
           L_TUBE_P2       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           NB_ELEM_EPAIS   =SIMP(statut='f',typ='I',defaut= 3 ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="ENTIER",into=("ENTIER","QUART","DEMI") ),
           TRANSFORMEE     =SIMP(statut='o',typ='TXM',defaut="COUDE",into=("COUDE","TUBE") ),
           b_transf_coude  =BLOC(condition = "TRANSFORMEE == 'COUDE' ",
              DEXT            =SIMP(statut='o',typ='R' ),
              EPAIS           =SIMP(statut='o',typ='R' ),
              SUR_EPAIS       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
              BOL_P2          =SIMP(statut='f',typ='TXM',into=("ASP_MPP","CUVE","GV") ),
           ),
           b_transf_tube   =BLOC(condition = "TRANSFORMEE == 'TUBE' ",
              TRAN_EPAIS      =SIMP(statut='o',typ='TXM',defaut="NON",into=("OUI","NON") ),
              b_trans_epais_oui    =BLOC(condition = "TRAN_EPAIS == 'OUI' ",
                      regles=(ENSEMBLE('ANGL_TETA2','EPAIS_TI'),
                              UN_PARMI('ABSC_CURV_TRAN','POSI_ANGU_TRAN'),),
                      DEXT_T1         =SIMP(statut='o',typ='R' ),
                      EPAIS_T1        =SIMP(statut='o',typ='R' ),
                      EPAIS_T2        =SIMP(statut='o',typ='R' ),
                      EPAIS_TI        =SIMP(statut='f',typ='R' ),
                      ANGL_TETA1      =SIMP(statut='o',typ='R' ),
                      ANGL_TETA2      =SIMP(statut='f',typ='R' ),
                      ABSC_CURV_TRAN  =SIMP(statut='f',typ='R' ),
                      POSI_ANGU_TRAN  =SIMP(statut='f',typ='R' ),
              ),
              b_trans_epais_non    =BLOC(condition = "TRAN_EPAIS == 'NON' ",
                      DEXT            =SIMP(statut='o',typ='R' ),
                      EPAIS           =SIMP(statut='o',typ='R' ),
                      SUR_EPAIS       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                      BOL_P2          =SIMP(statut='f',typ='TXM',into=("ASP_MPP","CUVE","GV") ),
              ),
           ),
         ),

         SOUS_EPAIS_COUDE=FACT(statut='f',
           regles=(UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL'),
                   UN_PARMI('POSI_CURV_CIRC','AZIMUT'),),
           TYPE            =SIMP(statut='o',typ='TXM',into=("AXIS","ELLI") ),
           AXE_CIRC        =SIMP(statut='f',typ='R' ),
           AXE_LONGI       =SIMP(statut='o',typ='R' ),
           PROFONDEUR      =SIMP(statut='o',typ='R' ),
           POSI_CURV_LONGI =SIMP(statut='f',typ='R' ),
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),
           POSI_CURV_CIRC  =SIMP(statut='f',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R' ),
           SOUS_EPAIS      =SIMP(statut='o',typ='TXM',into=("INTERNE","EXTERNE") ),
           NB_ELEM_LONGI   =SIMP(statut='o',typ='I' ),
           NB_ELEM_CIRC    =SIMP(statut='o',typ='I' ),
           NB_ELEM_RADI    =SIMP(statut='f',typ='I',defaut= 3 ),
           EMPREINTE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         SOUS_EPAIS_MULTI=FACT(statut='f',max='**',
           regles=(UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL'),
                   UN_PARMI('POSI_CURV_CIRC','AZIMUT'),),
           TYPE            =SIMP(statut='o',typ='TXM',into=("AXIS","ELLI") ),
           AXE_CIRC        =SIMP(statut='f',typ='R' ),
           AXE_LONGI       =SIMP(statut='o',typ='R' ),
           PROFONDEUR      =SIMP(statut='o',typ='R' ),
           POSI_CURV_LONGI =SIMP(statut='f',typ='R' ),
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),
           POSI_CURV_CIRC  =SIMP(statut='f',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R' ),
           SOUS_EPAIS      =SIMP(statut='o',typ='TXM',into=("INTERNE","EXTERNE") ),
           NB_ELEM_LONGI   =SIMP(statut='o',typ='I' ),
           NB_ELEM_CIRC    =SIMP(statut='o',typ='I' ),
           EMPREINTE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         FISS_COUDE      =FACT(statut='f',
           regles=(UN_PARMI('ABSC_CURV','POSI_ANGUL'),),
           AXIS            =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),
           b_axis_non    =BLOC(condition = "AXIS == 'NON' ",
                   LONGUEUR        =SIMP(statut='o',typ='R' ),
           ),
           b_axis_oui    =BLOC(condition = "AXIS == 'OUI' ",
                   LONGUEUR        =SIMP(statut='f',typ='R' ),
           ),
           PROFONDEUR      =SIMP(statut='o',typ='R' ),
           ABSC_CURV       =SIMP(statut='f',typ='R' ),
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),
           FISSURE         =SIMP(statut='o',typ='TXM',into=("DEB_INT","DEB_EXT") ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),
           ORIEN           =SIMP(statut='o',typ='R',
                                 into=(45.,-45.,90.,0.E+0) ),
           NB_TRANCHE      =SIMP(statut='o',typ='I' ),
           NB_SECTEUR      =SIMP(statut='o',typ='I' ),
           NB_COURONNE     =SIMP(statut='o',typ='I' ),
           RAYON_TORE      =SIMP(statut='f',typ='R' ),
           COEF_MULT_RC2   =SIMP(statut='f',typ='R',defaut= 1. ),
           COEF_MULT_RC3   =SIMP(statut='f',typ='R' ),
           ANGL_OUVERTURE  =SIMP(statut='f',typ='R',defaut= 0.5 ),
         ),

         IMPRESSION      =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('FICHIER','UNITE'),),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",
                                 into=("ASTER","IDEAS","CASTEM") ),
           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),
           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),
           FICHIER         =SIMP(statut='f',typ='TXM' ),
           UNITE           =SIMP(statut='f',typ='I' ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

def macr_aspic_calc_prod(self,MODELE,CHAM_MATER,CARA_ELEM,FOND_FISS_1,FOND_FISS_2,RESU_THER,**args):
  if MODELE      != None:self.type_sdprod(MODELE,modele_sdaster)
  if CHAM_MATER  != None:self.type_sdprod(CHAM_MATER,cham_mater)
  if CARA_ELEM   != None:self.type_sdprod(CARA_ELEM,cara_elem)
  if FOND_FISS_1 != None:self.type_sdprod(FOND_FISS_1,fond_fiss)
  if FOND_FISS_2 != None:self.type_sdprod(FOND_FISS_2,fond_fiss)
  if RESU_THER   != None:self.type_sdprod(RESU_THER,evol_ther)
  return evol_noli

MACR_ASPIC_CALC=MACRO(nom="MACR_ASPIC_CALC",
                      op=OPS('Macro.macr_aspic_calc_ops.macr_aspic_calc_ops'),
                      sd_prod=macr_aspic_calc_prod,
                      fr="Réalise un calcul prédéfini de piquages sains ou fissurés " \
                         "ainsi que les post-traitements associés ",
                      UIinfo={"groupes":("Résolution","Outils-métier",)},
                      reentrant='n',

         TYPE_MAILLAGE   =SIMP(statut='o',typ='TXM',
                               into=("SAIN_FIN","SAIN_GROS","FISS_COUR_DEB","FISS_COUR_NONDEB","FISS_LONG_DEB",
                                     "FISS_LONG_NONDEB","FISS_AXIS_DEB","FISS_AXIS_NONDEB") ),

         TUBULURE        =FACT(statut='o',
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2") ),
         ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=CO,),
         CHAM_MATER      =SIMP(statut='f',typ=CO,),
         CARA_ELEM       =SIMP(statut='f',typ=CO,),
         FOND_FISS_1     =SIMP(statut='f',typ=CO,),
         FOND_FISS_2     =SIMP(statut='f',typ=CO,),
         RESU_THER       =SIMP(statut='f',typ=CO,),

         AFFE_MATERIAU   =FACT(statut='o',max=3,
           regles=(UN_PARMI('TOUT','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           GROUP_MA        =SIMP(statut='f',typ=grma,into=("TUBU","CORP","SOUD","SOUDCORP","SOUDTUBU") ),
           MATER           =SIMP(statut='o',typ=mater_sdaster),
           TEMP_REF        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RCCM            =SIMP(statut='o',typ='TXM',into=("OUI","NON")),
         ),

         EQUILIBRE       =FACT(statut='o',
           NOEUD           =SIMP(statut='o',typ=no),
         ),

         PRES_REP        =FACT(statut='o',
           PRES            =SIMP(statut='o',typ='R'),
           NOEUD           =SIMP(statut='f',typ=no),
           EFFE_FOND       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           PRES_LEVRE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         ECHANGE         =FACT(statut='f',
           COEF_H_TUBU     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           COEF_H_CORP     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TEMP_EXT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         TORS_CORP       =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           NOEUD           =SIMP(statut='o',typ=no),
           FX              =SIMP(statut='f',typ='R'),
           FY              =SIMP(statut='f',typ='R'),
           FZ              =SIMP(statut='f',typ='R'),
           MX              =SIMP(statut='f',typ='R'),
           MY              =SIMP(statut='f',typ='R'),
           MZ              =SIMP(statut='f',typ='R'),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         TORS_TUBU       =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           FX              =SIMP(statut='f',typ='R'),
           FY              =SIMP(statut='f',typ='R'),
           FZ              =SIMP(statut='f',typ='R'),
           MX              =SIMP(statut='f',typ='R'),
           MY              =SIMP(statut='f',typ='R'),
           MZ              =SIMP(statut='f',typ='R'),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         COMPORTEMENT    =C_COMPORTEMENT('MACR_ASPIC_CALC'),

         THETA_3D        =FACT(statut='f',max='**',
           R_INF           =SIMP(statut='o',typ='R'),
           R_SUP           =SIMP(statut='o',typ='R'),
         ),

         OPTION          =SIMP(statut='f',typ='TXM',into=("CALC_G_MAX","CALC_G_MAX_LOCAL") ),
         BORNES          =FACT(statut='f',max='**',
           NUME_ORDRE      =SIMP(statut='o',typ='I'),
           VALE_MIN        =SIMP(statut='o',typ='R'),
           VALE_MAX        =SIMP(statut='o',typ='R'),
         ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MACR_ASPIC_CALC'),
#-------------------------------------------------------------------

         CONVERGENCE     =C_CONVERGENCE(),

         NEWTON          =C_NEWTON(),

         RECH_LINEAIRE   =C_RECH_LINEAIRE(),

         INCREMENT       =C_INCREMENT('MECANIQUE'),

         PAS_AZIMUT      =SIMP(statut='f',typ='I',defaut=1),

         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),

         IMPRESSION      =FACT(statut='f',
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",
                                 into=("RESULTAT","ASTER","CASTEM","IDEAS")),

           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),

           b_extrac        =BLOC(condition="((FORMAT=='IDEAS')or(FORMAT=='CASTEM'))",
                                 fr="extraction d un champ de grandeur",
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,into=("DEPL","SIEQ_ELNO","TEMP")),

             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),

         TITRE           =SIMP(statut='f',typ='TXM'),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr


MACR_ASPIC_MAIL=MACRO(nom="MACR_ASPIC_MAIL",
                      op=OPS('Macro.macr_aspic_mail_ops.macr_aspic_mail_ops'),
                      sd_prod=maillage_sdaster,
                      reentrant='n',
                      fr="Engendre le maillage d'un piquage sain ou avec fissure (longue ou courte)",
                      UIinfo={"groupes":("Maillage","Outils-métier",)},

         EXEC_MAILLAGE   =FACT(statut='o',
           LOGICIEL        =SIMP(statut='o',typ='TXM',defaut="GIBI2000",into=("GIBI98","GIBI2000")),
           UNITE_DATG      =SIMP(statut='f',typ='I',defaut=70),
           UNITE_MGIB      =SIMP(statut='f',typ='I',defaut=19),
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,4,5,6,7,8,9,10,11)),
         ),

         TYPE_ELEM       =SIMP(statut='f',typ='TXM',defaut="CU20",into=("CU20","CUB8")),

         RAFF_MAIL       =SIMP(statut='f',typ='TXM',defaut="GROS",into=("GROS","FIN")),

         TUBULURE        =FACT(statut='o',
           E_BASE          =SIMP(statut='o',typ='R'),
           DEXT_BASE       =SIMP(statut='o',typ='R'),
           L_BASE          =SIMP(statut='o',typ='R'),
           L_CHANF         =SIMP(statut='o',typ='R'),
           E_TUBU          =SIMP(statut='o',typ='R'),
           DEXT_TUBU       =SIMP(statut='o',typ='R'),
           Z_MAX           =SIMP(statut='o',typ='R'),
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2")),
           L_PENETR        =SIMP(statut='f',typ='R',defaut= 0.0E+0),
         ),

         SOUDURE         =FACT(statut='o',
           H_SOUD          =SIMP(statut='o',typ='R'),
           ANGL_SOUD       =SIMP(statut='o',typ='R'),
           JEU_SOUD        =SIMP(statut='o',typ='R'),
         ),

         CORPS           =FACT(statut='o',
           E_CORP          =SIMP(statut='o',typ='R'),
           DEXT_CORP       =SIMP(statut='o',typ='R'),
           X_MAX           =SIMP(statut='o',typ='R'),
         ),

         FISS_SOUDURE    =FACT(statut='f',
           TYPE            =SIMP(statut='o',typ='TXM',into=("LONGUE","COURTE")),
           AXIS            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
           PROFONDEUR      =SIMP(statut='o',typ='R'),
           LONGUEUR        =SIMP(statut='f',typ='R'),
           AZIMUT          =SIMP(statut='o',typ='R'),
           RAYON_TORE      =SIMP(statut='f',typ='R'),
           POSITION        =SIMP(statut='o',typ='TXM',into=("DROIT","INCLINE")),
           FISSURE         =SIMP(statut='o',typ='TXM',into=("DEB_INT","DEB_EXT","NON_DEB","TRAVERS")),
           LIGA_INT        =SIMP(statut='f',typ='R'),
           ANGL_OUVERTURE  =SIMP(statut='f',typ='R',defaut= 0.0E+0),
           COEF_MULT_RC1   =SIMP(statut='f',typ='R'),
           COEF_MULT_RC2   =SIMP(statut='f',typ='R'),
           COEF_MULT_RC3   =SIMP(statut='f',typ='R'),
           NB_TRANCHE      =SIMP(statut='f',typ='I'),
           NB_SECTEUR      =SIMP(statut='f',typ='I'),
           NB_COURONNE     =SIMP(statut='f',typ='I'),
         ),

         IMPRESSION      =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('FICHIER','UNITE'),),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","IDEAS","CASTEM")),

           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),
           FICHIER         =SIMP(statut='f',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I'),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-luc.flejou at edf.fr


MACR_CARA_POUTRE=MACRO(nom="MACR_CARA_POUTRE",
                       op=OPS('Macro.macr_cara_poutre_ops.macr_cara_poutre_ops'),
                       sd_prod=table_sdaster,
                       reentrant='n',
                       UIinfo={"groupes":("Modélisation",)},
                       fr="Calculer les caractéristiques d'une section transversale de " \
                          "poutre à partir d'un maillage 2D de la section",
         regles=(
            EXCLUS('SYME_Y','GROUP_MA_BORD'),
            EXCLUS('SYME_Z','GROUP_MA_BORD'),
         ),

         MAILLAGE    =SIMP(statut='f',typ=maillage_sdaster, fr="Nom du concept maillage"),
         b_maillage  =BLOC(
            condition = "MAILLAGE == None",
            regles=( PRESENT_PRESENT('FORMAT','UNITE') ),
            FORMAT   =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","MED"),
                           fr="Format du fichier"),
            UNITE    =SIMP(statut='f',typ='I',defaut= 20,
                           fr="Unite correspondant au format du fichier maillage"),
         ),

         ORIG_INER      =SIMP(statut='f',typ='R',max=3,defaut=(0.E+0,0.E+0),
                              fr="Point par rapport auquel sont calculées les inerties"),
         INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),

         TABLE_CARA     =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",),

         SYME_Y         =SIMP(statut='f',typ='TXM',into=("OUI",), fr="demi maillage par rapport a y=0"),
         SYME_Z         =SIMP(statut='f',typ='TXM',into=("OUI",), fr="demi maillage par rapport a z=0"),

         GROUP_MA       =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                              fr="Calcul des caractéristiques équivalentes à plusieurs sections disjointes"),

         GROUP_MA_BORD  =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                              fr="Groupe(s) de mailles linéiques, bord(s) de(s) section(s)"),

         b_nom =BLOC(
            condition = """(TABLE_CARA == 'OUI') and (GROUP_MA == None)""",
            NOM   =SIMP(statut='f',typ='TXM',max=1,validators=LongStr(1,8),
                        fr="Nom de la section, 8 caractères maximum.")
         ),

         b_gma_bord  =BLOC(
            condition = "GROUP_MA_BORD != None",
            fr=" calcul des carac. mecaniques",
            regles=(UN_PARMI('NOEUD','GROUP_NO')),
            NOEUD          =SIMP(statut='f',typ=no,max='**',
                                 fr="Simplement pour empecher des pivots nuls le cas echeant. "
                                    "Fournir un noeud quelconque"),
            GROUP_NO       =SIMP(statut='f',typ=grno,max='**',
                                 fr="Simplement pour empecher des pivots nuls le cas echeant. "
                                    "Fournir un noeud quelconque par GROUP_MA"),
            GROUP_MA_INTE  =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                                 fr="groupes de mailles linéiques bordant des trous dans la section"),
          ),

         b_reseau = BLOC(
            condition ="""(GROUP_MA_BORD != None) and (GROUP_MA != None)""",
            fr=" calcul des coef de cisaillement équivalents a un reseau de poutres",
            regles=(ENSEMBLE('LONGUEUR','LIAISON','MATERIAU') ,),
            LONGUEUR =SIMP(statut='f',typ='R',
                           fr="Longueur du réseau de poutres"),
            MATERIAU =SIMP(statut='f',typ=mater_sdaster,
                           fr="Materiau elastique lineaire du reseau"),
            LIAISON  =SIMP(statut='f',typ='TXM',into=("ROTULE","ENCASTREMENT"),
                           fr="type de conditions aux limites sur le plancher supérieur" ),
         ),
)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr


def macr_ecla_pg_prod(self,RESULTAT,MAILLAGE,RESU_INIT,**args):
  self.type_sdprod(RESULTAT,AsType(RESU_INIT))
  self.type_sdprod(MAILLAGE,maillage_sdaster)
  return None


MACR_ECLA_PG=MACRO(nom="MACR_ECLA_PG",
                   op=OPS('Macro.macr_ecla_pg_ops.macr_ecla_pg_ops'),
                   sd_prod=macr_ecla_pg_prod,
                   reentrant='n',
                   UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
                   fr="Permettre la visualisation des champs aux points de Gauss d'une " \
                      "SD_RESULTAT sans lissage ni interpolation",

             # SD résultat ,modèle et champs à "éclater" :
             RESU_INIT       =SIMP(statut='o',typ=resultat_sdaster,fr="RESULTAT à éclater",),
             MODELE_INIT     =SIMP(statut='o',typ=modele_sdaster,fr="MODELE à éclater"),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO('ELGA'),),

             # paramètres numériques de la commande :
             SHRINK          =SIMP(statut='f',typ='R',defaut= 0.9, fr="Facteur de réduction" ),
             TAILLE_MIN      =SIMP(statut='f',typ='R',defaut= 0.0, fr="Taille minimale d'un coté" ),

             # concepts produits par la commande :
             RESULTAT        =SIMP(statut='o',typ=CO,fr="SD_RESULTAT résultat de la commande"),
             MAILLAGE        =SIMP(statut='o',typ=CO,fr="MAILLAGE associé aux cham_no de la SD_RESULTAT"),

             # Sélection éventuelle d'un sous-ensemble des éléments à visualiser :
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),

             # Sélection des numéros d'ordre :
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
            )

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: marina.bottoni at edf.fr


def macr_ecre_calc_prod(self,TABLE,DEBIT,**args):

  self.type_sdprod(TABLE,table_sdaster)
  self.type_sdprod(DEBIT,table_sdaster)
  return None

MACR_ECRE_CALC=MACRO(nom="MACR_ECRE_CALC",
                     op=OPS('Macro.macr_ecre_calc_ops.macr_ecre_calc_ops'),
                     sd_prod=macr_ecre_calc_prod,
                     reentrant='n',
                     UIinfo={"groupes":("Résolution","Outils-métier",)},
                     fr="Procedure de couplage avec Ecrevisse",

                     regles = (UN_PARMI('LOGICIEL','VERSION'),),

#      CONCEPTS SORTANT : 2 TABLES POUR LE POST-TRAITEMENT
#      ********************************************
         TABLE              =SIMP(statut='o',typ=CO),
         DEBIT              =SIMP(statut='o',typ=CO),

#      DONNEES GEOMETRIQUES RELATIVES A LA FISSURE
#      *******************************************

         FISSURE            =FACT(statut='o',min=1,max=1,
           LONGUEUR            =SIMP(statut='o',typ='R',val_min=0.E+0,fr="Longueur de la fissure [zl]"),
           RUGOSITE            =SIMP(statut='o',typ='R',fr="Rugosite absolu (metres) [eps]"),
           ANGLE               =SIMP(statut='o',typ='R',fr="Angle par rapport a l'ascendante verticale (degres)"),
           ZETA                =SIMP(statut='o',typ='R',fr="Coefficient de la perte de charge singuliere a l'entree [zeta]"),
           SECTION             =SIMP(statut='o',typ='TXM',into=("ELLIPSE","RECTANGLE"),fr="Type de section [is]"),
           b_section_ellipse   =BLOC(condition="SECTION=='ELLIPSE'",fr="Fissure a section elliptique",
             LISTE_COTES_AH      =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des cotes des points definissant le grand axe de la section",
                                       validators=NoRepeat()),
             LISTE_VAL_AH        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant le grand axe de la section",),
             LISTE_COTES_BL      =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des cotes des points definissant le petit axe de la section",
                                       validators=NoRepeat()),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant le petit axe de la section",),
           ),
           b_section_rectangle =BLOC(condition="SECTION=='RECTANGLE'",fr="Fissure a section rectangulaire",
             LISTE_COTES_AH      =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des cotes des points definissant la hauteur de la section",
                                       validators=NoRepeat()),
             LISTE_VAL_AH        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant la hauteur de la section",),
             LISTE_COTES_BL      =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des cotes des points definissant la largeur de la section",
                                       validators=NoRepeat()),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant la largeur de la section",),
           ),
         ),


#      DONNEES RELATIVES A L"ECOULEMENT
#      ********************************

         ECOULEMENT         =FACT(statut='f',min=1,max=1,
           PRES_ENTREE         =SIMP(statut='o',typ='R',fr="Pression de stagnation a l'entree (Pa) [pe]" ),
           PRES_SORTIE         =SIMP(statut='o',typ='R',fr="Pression de stagnation a la sortie (Pa) [ps]" ),
           FLUIDE_ENTREE       =SIMP(statut='o',typ='I',into=(1,2,3,4,5,6),fr="Condition du fluide a l'entree [iflow]" ),
           b_condition_1       =BLOC(condition="FLUIDE_ENTREE==1",fr="Eau sous-refroidie ou saturee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_2       =BLOC(condition="FLUIDE_ENTREE==2",fr="Fluide diphasique",
             TITR_MASS           =SIMP(statut='o',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
           ),
           b_condition_3       =BLOC(condition="FLUIDE_ENTREE==3",fr="Vapeur saturee ou surchauffee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_4       =BLOC(condition="FLUIDE_ENTREE==4",fr="Air + vapeur surchauffee",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             PRES_PART           =SIMP(statut='o',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_5       =BLOC(condition="FLUIDE_ENTREE==5",fr="Air + vapeur saturee",
             TITR_MASS           =SIMP(statut='o',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
             PRES_PART           =SIMP(statut='o',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_6       =BLOC(condition="FLUIDE_ENTREE==6",fr="Air seul",
             TEMP_ENTREE         =SIMP(statut='o',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
           ),
         ),


#      DONNEES RELATIVES AU PROFIL DE TEMPERATURE A TRAVERS LA PAROI
#      *************************************************************

         TEMPERATURE        =FACT(statut='f',min=1,max=1,
           GRADIENT            =SIMP(statut='o',typ='TXM',into=("FOURNI","IMPOSE","CALCULE"),
                                     fr="Modele de calcul du gradient de temperature [imograd]" ),
           b_gradient_fourni   =BLOC(condition="GRADIENT=='FOURNI'",fr="Distribution de temperature fournie [imograd=-1]",
             LISTE_COTES_TEMP    =SIMP(statut='o',typ='R',max='**',fr="Liste des cotes pour les temperatures",
                                       validators=NoRepeat() ),
             LISTE_VAL_TEMP      =SIMP(statut='o',typ='R',max='**',fr="Liste des valeurs de temperature", ),
           ),
           b_gradient_impose   =BLOC(condition="GRADIENT=='IMPOSE'",fr="Distribution imposee de temperature [imograd=0]",
             TEMP1               =SIMP(statut='o',typ='R',
                                       fr="Gradient de temperature de la paroi le long de l'ecoulement (degC/m) [tm1]", ),
             TEMP2               =SIMP(statut='o',typ='R',fr="Temperature de la paroi a l'entree (degC) [tm2]", ),
           ),
           b_gradient_calcule  =BLOC(condition="GRADIENT=='CALCULE'",fr="Profil de temperature calcule [imograd=1]",
             EPAISSEUR_PAROI     =SIMP(statut='o',typ='R',fr="Epaisseur de la paroi (m) [epp]", ),
             CONVECTION_AMONT    =SIMP(statut='o',typ='R',
                                       fr="Coefficient de convection a la surface de la paroi cote amont (W/degC/m2) [alphe]", ),
             CONVECTION_AVAL     =SIMP(statut='o',typ='R',
                                       fr="Coefficient de convection a la surface de la paroi cote aval (W/degC/m2) [alphs]", ),
             LAMBDA              =SIMP(statut='o',typ='R',fr="Conduction thermique de la paroi (W/degC/m) [lambd]", ),
             TEMP_FLUIDE_AVAL    =SIMP(statut='o',typ='R',fr="Temperature du fluide cote aval (degC) [ts]", ),
           ),
         ),


#      CHOIX DES MODELES
#      *****************

         MODELE_ECRE        =FACT(statut='f',min=1,max=1,
           IVENAC              =SIMP(statut='f', typ='I', into=(0,1), defaut=0,
                                     fr="Calcul ECREVISSE avec prise en compte de la vena contracta"),
           ECOULEMENT          =SIMP(statut='o',typ='TXM',into=("SATURATION","GELE"),
                                     fr="Type de modele d'ecoulement diphasique [imod]" ),
           b_ecou_gele         =BLOC(condition="ECOULEMENT=='GELE'",fr="Modele d'ecoulement gele",
             PRESS_EBULLITION    =SIMP(statut='o',typ='R',fr="Pression d'ebullition [corrp*psat(t)]"),
           ),
           FROTTEMENT          =SIMP(statut='o',typ='I',into=(-4,-3,-2,-1,0,1,2,3,4,11,12,13,14),fr="Correlation de frottement [ifrot]"),
           b_frottement        =BLOC(condition="FROTTEMENT<0",fr="Modele d'ecoulement gele",
             REYNOLDS_LIM        =SIMP(statut='o',typ='R',fr="Coefficient de Reynolds limite [relim]"),
             FROTTEMENT_LIM      =SIMP(statut='o',typ='R',fr="Coefficient de frottement impose [frtlim]"),
           ),

           TRANSFERT_CHAL      =SIMP(statut='o',typ='I',into=(-12,-11,-2,-1,0,1,2,11,12),fr="Transfert de chaleur [ichal]"),
           b_transchal         =BLOC(condition="TRANSFERT_CHAL<0", fr="Cas diphasique",
             XMINCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux min [xminch]"),
             XMAXCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux max [xmaxch]"),
           ),
         ),


#      DONNEES RELATIVES A LA CONVERGENCE NUMERIQUE
#      ********************************************

         CONVERGENCE        =FACT(statut='f',min=1,max=1,
           KGTEST              =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 0.5E+0,
                                     fr="Parametre de l'algorithme iteratif [kgtest]" ),
           ITER_GLOB_MAXI      =SIMP(statut='f',typ='I',defaut= 400,
                                     fr="Nombre maximum d'iterations de la methode de Newton [itnmax]" ),
           CRIT_CONV_DEBI      =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 1.E-5,
                                     fr="Critere de convergence en debit [precdb]" ),
         ),


#      GENERAL
#      *******

         COURBES            =SIMP(statut='f',typ='TXM',into=("INTERACTIF","POSTSCRIPT","AUCUNE"),defaut="AUCUNE",
                                  fr="Generation eventuelle des courbes" ),
         LOGICIEL           =SIMP(statut='f',typ='TXM',validators=LongStr(1,255),),
         VERSION            =SIMP(statut='f',typ='TXM',into = ("3.2.1",) ),
         ENTETE             =SIMP(statut='f',typ='TXM',max='**',defaut="Titre du calcul Ecrevisse" ),
         IMPRESSION         =SIMP(statut='f',typ='TXM',defaut='NON',into=( 'OUI','NON') ),
         INFO               =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: marina.bottoni at edf.fr


def macr_ecrevisse_prod(self,TABLE,TEMPER,DEBIT,**args):
    # On definit ici les concepts produits
    self.type_sdprod(TABLE,table_sdaster)
    self.type_sdprod(TEMPER,evol_ther)
    self.type_sdprod(DEBIT,table_sdaster)
    # concept retourne
    return evol_noli


MACR_ECREVISSE=MACRO(nom="MACR_ECREVISSE",
                     op=OPS('Macro.macr_ecrevisse_ops.macr_ecrevisse_ops'),
                     sd_prod=macr_ecrevisse_prod,
                     reentrant='f',
                     UIinfo={"groupes":("Résolution","Outils-métier",)},
                     fr="Procedure de couplage avec Ecrevisse",

       reuse  = SIMP(statut='f',typ='evol_noli'),
       regles = (EXCLUS('TEMPER','ETAT_INIT'),
                 UN_PARMI('LOGICIEL','VERSION'),),

#      CONCEPT SORTANT
#      ********************************************
         TABLE              =SIMP(statut='f',typ=CO),
         DEBIT              =SIMP(statut='f',typ=CO),
         TEMPER             =SIMP(statut='f',typ=CO),

#      ETAT_INITIAL
#      ********************************************
         ETAT_INIT       =FACT(statut='f',
             EVOL_NOLI       =SIMP(statut='o',typ=evol_noli),
             EVOL_THER       =SIMP(statut='o',typ=evol_ther),
             NUME_ORDRE      =SIMP(statut='o',typ='I'),
         ),


#      MODELES MECANIQUES
#      ********************************************
         MODELE_MECA        =SIMP(statut='o',typ=modele_sdaster),
         MODELE_THER        =SIMP(statut='o',typ=modele_sdaster),


#      DONNEES GEOMETRIQUES RELATIVES A LA FISSURE
#      *******************************************
         FISSURE            =FACT(statut='o',min=1,max='**',
           PREFIXE_FICHIER     =SIMP(statut='f',typ='TXM',validators=LongStr(1,8)),
           GROUP_MA            =SIMP(statut='o',typ=grma,validators=NoRepeat(),min=2,max=2,
                                     fr="Groupe(s) des noeuds definissant les levres de la fissure"),
           GROUP_NO_ORIG       =SIMP(statut='o',typ=grno,validators=NoRepeat(),min=2,max=2),
           GROUP_NO_EXTR       =SIMP(statut='o',typ=grno,validators=NoRepeat(),min=2,max=2),
           ZETA                =SIMP(statut='o',typ='R',fr="Coefficient de la perte de charge singuliere a l'entree [zeta]" ),
           RUGOSITE            =SIMP(statut='o',typ='R',fr="Rugosite absolu (metres) [eps]" ),
           TORTUOSITE          =SIMP(statut='f',typ='R',defaut=1.0, val_min=0., val_max=1.0,
                                       fr="Coefficient de tortuosite de la fissure" ),
           OUVERT_REMANENTE    =SIMP(statut='o',typ='R',val_min=0.,fr="Ouverture remanente"),
           SECTION             =SIMP(statut='o',typ='TXM',into=("ELLIPSE","RECTANGLE"),fr="Type de section [is]" ),
           b_section_ellipse   =BLOC(condition="SECTION=='ELLIPSE'",fr="Fissure a section elliptique",
             LISTE_COTES_BL      =SIMP(statut='f',typ='R',max='**',
                                       fr="Liste des cotes des points definissant le petit axe de la section",
                                       validators=NoRepeat() ),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant le petit axe de la section", ),
           ),
           b_section_rectangle =BLOC(condition="SECTION=='RECTANGLE'",fr="Fissure a section rectangulaire",
             LISTE_COTES_BL      =SIMP(statut='f',typ='R',max='**',
                                       fr="Liste des cotes des points definissant la largeur de la section",validators=NoRepeat()),
             LISTE_VAL_BL        =SIMP(statut='o',typ='R',max='**',
                                       fr="Liste des valeurs des points definissant la largeur de la section", ),
           ),
         ),


#      DONNEES RELATIVES A L"ECOULEMENT
#      ********************************
         ECOULEMENT         =FACT(statut='o',min=1,max=1,
                                  regles=(UN_PARMI('PRES_ENTREE','PRES_ENTREE_FO'),
                                          UN_PARMI('PRES_SORTIE','PRES_SORTIE_FO'),
                                          ),
           PRES_ENTREE         =SIMP(statut='f',typ='R',fr="Pression de stagnation a l'entree (Pa) [pe]" ),
           PRES_ENTREE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                     fr="Evolution de la pression de stagnation a l'entree (Pa) [pe]" ),
           PRES_SORTIE         =SIMP(statut='f',typ='R',fr="Pression de stagnation a la sortie (Pa) [ps]" ),
           PRES_SORTIE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                     fr="Evolution de la pression de stagnation a la sortie (Pa) [ps]" ),
           FLUIDE_ENTREE       =SIMP(statut='o',typ='I',into=(1,2,3,4,5,6),fr="Condition du fluide a l'entree [iflow]" ),
           b_condition_1       =BLOC(condition="FLUIDE_ENTREE==1",
                                     regles=(UN_PARMI('TEMP_ENTREE', 'TEMP_ENTREE_FO')),
                                     fr="Eau sous-refroidie ou saturee",
             TEMP_ENTREE         =SIMP(statut='f',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             TEMP_ENTREE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_2       =BLOC(condition="FLUIDE_ENTREE==2",
                                     regles=(UN_PARMI('TITR_MASS', 'TITR_MASS_FO')),
                                     fr="Fluide diphasique",
             TITR_MASS           =SIMP(statut='f',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
             TITR_MASS_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution du titre massique eau vap/eau tot a l'entree [xe]" ),
           ),
           b_condition_3       =BLOC(condition="FLUIDE_ENTREE==3",
                                     regles=(UN_PARMI('TEMP_ENTREE', 'TEMP_ENTREE_FO')),
                                     fr="Vapeur saturee ou surchauffee",
             TEMP_ENTREE         =SIMP(statut='f',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             TEMP_ENTREE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la temperature a l'entree (degres C) [te]" ),
           ),
           b_condition_4       =BLOC(condition="FLUIDE_ENTREE==4",
                                     regles=(UN_PARMI('TEMP_ENTREE', 'TEMP_ENTREE_FO'),
                                             UN_PARMI('PRES_PART', 'PRES_PART_FO')),
                                     fr="Air + vapeur surchauffee",
             TEMP_ENTREE         =SIMP(statut='f',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             TEMP_ENTREE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la temperature a l'entree (degres C) [te]" ),
             PRES_PART           =SIMP(statut='f',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
             PRES_PART_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_5       =BLOC(condition="FLUIDE_ENTREE==5",
                                     regles=(UN_PARMI('TITR_MASS', 'TITR_MASS_FO'),
                                             UN_PARMI('PRES_PART', 'PRES_PART_FO')),
                                     fr="Air + vapeur saturee",
             TITR_MASS           =SIMP(statut='f',typ='R',fr="Titre massique eau vap/eau tot a l'entree [xe]" ),
             TITR_MASS_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution du titre massique eau vap/eau tot a l'entree [xe]" ),
             PRES_PART           =SIMP(statut='f',typ='R',fr="Pression partielle air en entree (Pa) [pae]" ),
             PRES_PART_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la pression partielle air en entree (Pa) [pae]" ),
           ),
           b_condition_6       =BLOC(condition="FLUIDE_ENTREE==6",
                                     regles=(UN_PARMI('TEMP_ENTREE', 'TEMP_ENTREE_FO')),
                                     fr="Air seul",
             TEMP_ENTREE         =SIMP(statut='f',typ='R',fr="Temperature a l'entree (degres C) [te]" ),
             TEMP_ENTREE_FO      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),
                                       fr="Evolution de la temperature a l'entree (degres C) [te]" ),
           ),
         ),

         LIST_INST =SIMP(statut='f',typ=(listr8_sdaster), fr="Liste des instants de calcul imposes" ),

#      CHOIX DES MODELES
#      *****************

         MODELE_ECRE        =FACT(statut='o',min=1,max=1,
           IVENAC              =SIMP(statut='f', typ='I', into=(0,1), defaut=0,
                                     fr="Calcul ECREVISSE avec prise en compte de la vena contracta"),
           ECOULEMENT          =SIMP(statut='o',typ='TXM',into=("SATURATION","GELE"),
                                     fr="Type de modele d'ecoulement diphasique [imod]" ),
           b_ecou_gele         =BLOC(condition="ECOULEMENT=='GELE'",fr="Modele d'ecoulement gele",
             PRESS_EBULLITION  =SIMP(statut='o',typ='R',fr="Pression d'ebullition [corrp*psat(t)]" ),
           ),
           FROTTEMENT          =SIMP(statut='o',typ='I',into=(-4,-3,-2,-1,0,1,2,3,4,11,12,13,14),fr="Correlation de frottement [ifrot]" ),
           b_frottement        =BLOC(condition="FROTTEMENT<0",fr="Modele d'ecoulement gele",
             REYNOLDS_LIM        =SIMP(statut='o',typ='R',fr="Coefficient de Reynolds limite [relim]" ),
             FROTTEMENT_LIM      =SIMP(statut='o',typ='R',fr="Coefficient de frottement impose [frtlim]" ),
           ),

           TRANSFERT_CHAL      =SIMP(statut='o',typ='I',into=(-12,-11,-2,-1,0,1,2,11,12),fr="Transfert de chaleur [ichal]" ),
           b_transchal         =BLOC(condition="TRANSFERT_CHAL<0", fr="Cas diphasique",
             XMINCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux min [xminch]"),
             XMAXCH              =SIMP(statut='o',typ='R',fr="Titre massique gazeux max [xmaxch]"),
           ),
         ),


#      CRITERE DE CONVERGENCE
#      **********************

         CONV_CRITERE       =FACT(statut='o',min=1,max=1,
           TEMP_REF            =SIMP(statut='o',typ='R',val_min=1.0E-5,fr="Temperature de reference pour le calcul du critere"),
           PRES_REF            =SIMP(statut='o',typ='R',val_min=1.0E-5,fr="Pression de reference pour le calcul du critere"),
           CRITERE             =SIMP(statut='o',typ='TXM',defaut="TEMP_PRESS",into=("TEMP_PRESS","EXPLICITE","TEMP","PRESS"),
                                     fr="La nature du critere pour la convergence"),
           b_critere_autre     =BLOC(condition="CRITERE=='TEMP_PRESS' or CRITERE=='TEMP' or CRITERE=='PRESS'",
                                     fr="Critere de convergence temp_press, temp, ou press",
             SUBD_NIVEAU         =SIMP(statut='f',typ='I',val_min=2,defaut=3,
                                       fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI       =SIMP(statut='f',typ='R',val_min=0.0, fr="Pas de temps en dessous duquel on ne subdivise plus"),
             NUME_ORDRE_MIN      =SIMP(statut='f',typ='I',val_min=-1,defaut=-1,
                                       fr="Numero d'ordre a partir duquel le critere est pris en compte"),
             PREC_CRIT           =SIMP(statut='f',typ='R',val_min=1.0E-2,defaut=1.0,
                                       fr="Valeur du critere pour l'erreur de convergence"),
           ),
         ),


#      DONNEES RELATIVES A LA CONVERGENCE NUMERIQUE
#      ********************************************

         CONVERGENCE_ECREVISSE =FACT(statut='f',min=1,max=1,
           KGTEST                 =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 0.5E+0,
                                        fr="Parametre de l'algorithme iteratif [kgtest]" ),
           ITER_GLOB_MAXI         =SIMP(statut='f',typ='I',defaut= 400,
                                        fr="Nombre maximum d'iterations de la methode de Newton [itnmax]" ),
           CRIT_CONV_DEBI         =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut= 1.E-5,
                                        fr="Critere de convergence en debit [precdb]" ),
         ),


#      GENERAL
#      *******

         COURBES            = SIMP(statut='f',typ='TXM',into=("INTERACTIF","POSTSCRIPT","AUCUNE"),defaut="AUCUNE",
                                  fr="Generation eventuelle des courbes" ),
         LOGICIEL           = SIMP(statut='f',typ='TXM',validators=LongStr(1,255),),
         VERSION            = SIMP(statut='f',typ='TXM',into = ("3.2.1",) ),
         ENTETE             = SIMP(statut='f',typ='TXM',max='**',defaut="Titre du calcul Ecrevisse" ),
         IMPRESSION         = SIMP(statut='f',typ='TXM',defaut='NON',into=( 'OUI','NON') ),
         INFO               = SIMP(statut='f',typ='I',defaut="1",into=(1,2) ),

#      DONNEES POUR STAT_NON_LINE ET THER_NON_LINE
#      *******************************************

         # copie de stat_non_line.capy des options des mots cles qui nous interessent

         # donnees communes

         CHAM_MATER         =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM          =SIMP(statut='f',typ=cara_elem),

         # donnees specifiques a stat_non_line

         EXCIT_MECA         =FACT(statut='o',max='**',
           CHARGE              =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE         =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                     into=("FIXE_CSTE","SUIV","DIDI")),
         ),

         CONTACT            = SIMP(statut='o',typ=char_contact),

         COMPORTEMENT          = C_COMPORTEMENT(),
         NEWTON             = FACT(statut='d',
           REAC_INCR           =SIMP(statut='f',typ='I',defaut= 1 ),
           PREDICTION          =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOL") ),
           MATRICE             =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           PAS_MINI_ELAS       =SIMP(statut='f',typ='R',defaut=0.0E+0),
           REAC_ITER           =SIMP(statut='f',typ='I',defaut=0),
           REAC_ITER_ELAS      =SIMP(statut='f',typ='I',defaut=0),
           EVOL_NOLI           =SIMP(statut='f',typ=evol_noli),
         ),
         CONVERGENCE        = FACT(statut='d',regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
           b_refe_rela         =BLOC(condition = "RESI_REFE_RELA != None",
                                     regles=(AU_MOINS_UN('SIGM_REFE','EPSI_REFE','FLUX_THER_REFE',
                                                         'FLUX_HYD1_REFE','FLUX_HYD2_REFE','VARI_REFE'),
                                            ),
             SIGM_REFE           =SIMP(statut='f',typ='R'),
             EPSI_REFE           =SIMP(statut='f',typ='R'),
             FLUX_THER_REFE      =SIMP(statut='f',typ='R'),
             FLUX_HYD1_REFE      =SIMP(statut='f',typ='R'),
             FLUX_HYD2_REFE      =SIMP(statut='f',typ='R'),
             VARI_REFE           =SIMP(statut='f',typ='R'),
           ),
           RESI_REFE_RELA   =SIMP(statut='f',typ='R'),
           RESI_GLOB_MAXI   =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA   =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI   =SIMP(statut='f',typ='I',defaut=10),
           ITER_GLOB_ELAS   =SIMP(statut='f',typ='I',defaut=25),
           ARRET            =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         ),

         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),

         # donnees specifiques a ther_lineaire

         EXCIT_THER         =FACT(statut='o',max='**',
           CHARGE              =SIMP(statut='o',typ=(char_ther,char_cine_ther)),
           FONC_MULT           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),
         PARM_THETA         =SIMP(statut='f',typ='R',defaut= 0.57),

)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr

MACR_ELEM_DYNA=OPER(nom="MACR_ELEM_DYNA",op=  81,sd_prod=macr_elem_dyna,
                    fr="Definition d'un macro element pour analyse modale ou harmonique par sous structuration dynamique",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs","Dynamique",)},
         regles=(
                 # AMOR_REDUIT et MATR_AMOR sont redondants
                 EXCLUS('MATR_AMOR','AMOR_REDUIT' ),
                 
                 # Si MODELE_MESURE, on ne rentre pas de donnees pour le calcul
                 EXCLUS('MODELE_MESURE','MATR_RIGI' ),
                 EXCLUS('MODELE_MESURE','MATR_MASS' ),
                 EXCLUS('MODELE_MESURE','MATR_AMOR' ),
                 EXCLUS('MODELE_MESURE','AMOR_REDUIT' ),
                 EXCLUS('MODELE_MESURE','MATR_IMPE' ),
                 EXCLUS('MODELE_MESURE','MATR_IMPE_RIGI' ),
                 EXCLUS('MODELE_MESURE','MATR_IMPE_MASS' ),
                 EXCLUS('MODELE_MESURE','MATR_IMPE_AMOR' ),
                 
                 PRESENT_ABSENT('MATR_IMPE','MATR_IMPE_RIGI'),
                 PRESENT_ABSENT('MATR_IMPE','MATR_IMPE_MASS'),
                 PRESENT_ABSENT('MATR_IMPE','MATR_IMPE_AMOR'),
                 PRESENT_ABSENT('MATR_IMPE','MATR_RIGI','MATR_MASS'),
                 PRESENT_ABSENT('MATR_IMPE_MASS','MATR_RIGI','MATR_MASS'),
                 PRESENT_ABSENT('MATR_IMPE_RIGI','MATR_RIGI','MATR_MASS'),
                 PRESENT_ABSENT('MATR_IMPE_AMOR','MATR_RIGI','MATR_MASS'),),
         BASE_MODALE     =SIMP(statut='o',typ=mode_meca ),
         MATR_RIGI       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c),),
         MATR_MASS       =SIMP(statut='f',typ=matr_asse_depl_r ),
         MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'), 
         SANS_GROUP_NO   =SIMP(statut='f',typ=grno ),
         MATR_IMPE       =SIMP(statut='f',typ=matr_asse_gene_c ),
         MATR_IMPE_RIGI  =SIMP(statut='f',typ=matr_asse_gene_c ),
         MATR_IMPE_MASS  =SIMP(statut='f',typ=matr_asse_gene_c ),
         MATR_IMPE_AMOR  =SIMP(statut='f',typ=matr_asse_gene_c ),
         MODELE_MESURE   =FACT(statut='f',
           FREQ            =SIMP(statut='o',typ='R',max='**' ),
           MASS_GENE       =SIMP(statut='o',typ='R',max='**' ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**' ),
                              ),
         b_matr_impe     =BLOC(condition = "MATR_IMPE != None",
             FREQ_EXTR       =SIMP(statut='o',typ='R' ),
             AMOR_SOL        =SIMP(statut='f',typ='R',defaut=0.E+0 ),
             MATR_IMPE_INIT  =SIMP(statut='f',typ=matr_asse_gene_c ),
           ),
         CAS_CHARGE      =FACT(statut='f',max='**',
           NOM_CAS         =SIMP(statut='o',typ='TXM'),
           VECT_ASSE_GENE  =SIMP(statut='o',typ=vect_asse_gene ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
MACR_ELEM_STAT=OPER(nom="MACR_ELEM_STAT",op=86,sd_prod=macr_elem_stat,reentrant='f',
            UIinfo={"groupes":("Matrices et vecteurs",)},
                    fr="Définition d'un macro-élément pour l'analyse statique par sous-structuration",
        regles=(AU_MOINS_UN('DEFINITION','RIGI_MECA','MASS_MECA','CAS_CHARGE'),
                ENSEMBLE('DEFINITION','EXTERIEUR'),),
         DEFINITION      =FACT(statut='f',
           regles=(PRESENT_PRESENT('PROJ_MESU','MODE_MESURE'),),
           MODELE          =SIMP(statut='o',typ=modele_sdaster),
           CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
           CHAR_MACR_ELEM  =SIMP(statut='f',typ=char_meca),
           INST            =SIMP(statut='f',typ='R',defaut=0.0E+0 ),
           NMAX_CAS        =SIMP(statut='f',typ='I',defaut=10),
           NMAX_CHAR       =SIMP(statut='f',typ='I',defaut=10),
           PROJ_MESU       =SIMP(statut='f',typ=(mode_gene,tran_gene,harm_gene),max=1),
#           MODE_MESURE     =SIMP(statut='f',typ=( mode_meca,base_modale) ),
           MODE_MESURE     =SIMP(statut='f',typ= mode_meca ), 
         ),
         EXTERIEUR       =FACT(statut='f',
           regles=(AU_MOINS_UN('NOEUD','GROUP_NO'),),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         RIGI_MECA       =FACT(statut='f',
         ),
         MASS_MECA       =FACT(statut='f',
         ),
         AMOR_MECA       =FACT(statut='f',
         ),
         CAS_CHARGE      =FACT(statut='f',max='**',
           NOM_CAS         =SIMP(statut='o',typ='TXM'),
           SUIV            =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           INST            =SIMP(statut='f',typ='R',defaut=0.E+0),
         ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: gerald.nicolas at edf.fr
#
MACR_INFO_MAIL=MACRO(nom="MACR_INFO_MAIL",
                     op=OPS('Macro.macr_adap_mail_ops.macr_adap_mail_ops'),
                     docu="U7.03.02",UIinfo={"groupes":("Maillage",)},
                     fr="Donner des informations sur un maillage.",
                     ang="To give information about a mesh.",
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4)),
#
# 2. Le nom du maillage a analyser
#
  MAILLAGE = SIMP(statut='o',typ=maillage_sdaster,
                  fr="Maillage à analyser.",
                  ang="Mesh to be checked." ),
#
# 3. Suivi d'une frontiere
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
  b_frontiere = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière",
                      ang="Further information about boundary",
#
    GROUP_MA_FRONT = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Groupes de mailles définissant la frontière",
                          ang="Mesh groups which define the boundary" ),
#
                    ) ,
#
# 4. Les options ; par defaut, on controle tout, sauf l'interpénétration
# 4.1. Nombre de noeuds et mailles
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Nombre de noeuds et de mailles du maillage",
                        ang="Number of nodes and meshes in the mesh" ),
#
# 4.2. Determination de la qualite des mailles du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Qualité du maillage",
                        ang="Quality of the mesh" ),
#
# 4.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Connexité du maillage.",
                        ang="Connexity of the mesh." ),
#
# 4.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Tailles des sous-domaines du maillage.",
                        ang="Sizes of mesh sub-domains." ),
#
# 4.5. Controle de la non-interpénétration des mailles
#
  INTERPENETRATION=SIMP(statut='f',typ='TXM',into=("OUI",),
                        fr="Controle de la non interpénétration des mailles.",
                        ang="Overlapping checking." ),
#
# 4.6. Propriétés du maillage de calcul
#
  PROP_CALCUL    = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Propriétés du maillage de calcul.",
                        ang="Properties of the calculation mesh." ),
#
# 4.7. Determination des diametres des mailles du maillage
#
  DIAMETRE       = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",),
                        fr="Diamètre du maillage",
                        ang="Diameters of the mesh" ),
#
# 5. Les options avancées
# 5.1. Langue des messages issus de HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages issus de HOMARD.",
                ang="Language for HOMARD messages." ),
#
# 5.2. Gestion des mailles acceptees dans le maillage initial
#       "HOMARD" : exclusivement les mailles pouvant etre decoupees (defaut)
#       "IGNORE_PYRA" : elles sont ignorées
#
  ELEMENTS_ACCEPTES = SIMP(statut='f',typ='TXM',defaut="HOMARD",into=("HOMARD", "IGNORE_PYRA"),
                            fr="Acceptation des mailles dans le maillage initial",
                            ang="Elements in the very first mesh" ),
#
# 5.3. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V10_6",
                        into=("V10_6", "V10_N", "V10_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 5.4. Exécutable pilotant HOMARD
#
  LOGICIEL = SIMP(statut='f',typ='TXM',
                  fr="Logiciel pilotant HOMARD",
                  ang="HOMARD software"),
#
# 5.5. Unite logique d'un fichier à ajouter a HOMARD.Configuration
#
  b_unite = BLOC( condition = " (VERSION_HOMARD == 'V10_N') or \
                                (VERSION_HOMARD == 'V10_N_PERSO') " ,
                                fr="Fichier supplementaire.",
                                ang="Additional file.",
#
  UNITE = SIMP(statut='f',typ='I',
               fr="Unite logique a ajouter a HOMARD.Configuration",
               ang="Additional file to HOMARD.Configuration" ),
#
  ) ,
#
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: josselin.delmas at edf.fr


MACR_LIGP_COUPE=MACRO(nom="MACR_LIGP_COUPE",
                      op=OPS('Macro.macr_lign_coupe_ops.macr_lign_coupe_ops'),
                      sd_prod=table_sdaster,
                      reentrant='n',
                      UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
                      fr="Extraction des valeurs d'un résultat dans une ou plusieurs tables sur " \
                         "des lignes de coupe définies par deux points et un intervalle",
            regles=(UN_PARMI("RESULTAT","CHAM_GD"),),

         RESULTAT        =SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther,mode_meca) ),
         CHAM_GD         =SIMP(statut='f',typ=(cham_gd_sdaster)),

         b_extrac        =BLOC(condition = "RESULTAT != None",fr="extraction des résultats",
                                 regles=(EXCLUS('NUME_ORDRE','NUME_MODE','LIST_ORDRE','INST','LIST_INST',), ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
           ),

# extraction des résultats
         b_meca        =BLOC(condition = "AsType(RESULTAT) in (evol_elas,evol_noli,mode_meca)",fr="résultat mécanique",
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),defaut='SIGM_NOEU',into=C_NOM_CHAM_INTO(),),
         ),
         b_ther        =BLOC(condition = "AsType(RESULTAT) in (evol_ther,)",fr="résultat thermique",
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),defaut='TEMP',into=("TEMP",
                                 "FLUX_ELGA","FLUX_ELNO","FLUX_NOEU",
                                 "META_ELNO","META_NOEU",
                                 "DURT_ELNO","DURT_NOEU",
                                 "HYDR_ELNO","HYDR_NOEU",
                                 "DETE_ELNO","DETE_NOEU",
                                 "SOUR_ELGA","COMPORTHER",
                                 "ERTH_ELEM","ERTH_ELNO","ERTH_NOEU",),),),
         b_cham       =BLOC(condition = "CHAM_GD!=None",
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),),),

         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=25),
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),

         VIS_A_VIS       =FACT(statut='f',max='**',
                             regles=(EXCLUS('GROUP_MA_1','MAILLE_1'),),
           GROUP_MA_1        =SIMP(statut='f',typ=grma),
           MAILLE_1          =SIMP(statut='f',typ=ma,max='**'),),

         LIGP_COUPE     =FACT(statut='o',max='**',
            regles=(EXCLUS("NOM_CMP","INVARIANT","ELEM_PRINCIPAUX","RESULTANTE"),
                    PRESENT_PRESENT("TRAC_DIR","DIRECTION"),
                    EXCLUS("TRAC_DIR","TRAC_NOR"),
                    PRESENT_PRESENT("TRAC_DIR","NOM_CMP"),
                    PRESENT_PRESENT("TRAC_NOR","NOM_CMP"),),

           INTITULE        =SIMP(statut='f',typ='TXM',),
           TYPE            =SIMP(statut='o',typ='TXM',max=1,
                                 into=("GROUP_NO","SEGMENT","ARC","GROUP_MA"),defaut="SEGMENT"),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL",
                                into=("GLOBAL","LOCAL","POLAIRE","UTILISATEUR","CYLINDRIQUE"),),
           OPERATION       =SIMP(statut='f',typ='TXM',into=("EXTRACTION","MOYENNE",),defaut="EXTRACTION",),

           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           INVARIANT       =SIMP(statut='f',typ='TXM',into=("OUI",),),
           ELEM_PRINCIPAUX =SIMP(statut='f',typ='TXM',into=("OUI",),),
           RESULTANTE      =SIMP(statut='f',typ='TXM',max='**'),
           TRAC_NOR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
           TRAC_DIR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),


           b_local        =BLOC(condition = "REPERE=='LOCAL' ",
             VECT_Y          =SIMP(statut='f',typ='R',min=2,max=3),),

           b_utili        =BLOC(condition = "REPERE=='UTILISATEUR'",
             ANGL_NAUT       =SIMP(statut='o',typ='R',min=3,max=3),),

           b_grno          =BLOC(condition = "TYPE=='GROUP_NO'",
             GROUP_NO        =SIMP(statut='o',typ=grno, max=1),),

           b_grma          =BLOC(condition = "TYPE=='GROUP_MA'",
                                 regles=(EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                                         EXCLUS('NOEUD_EXTR','GROUP_NO_EXTR'),),
             GROUP_MA        =SIMP(statut='o',typ=grma, max=1),
             MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
             # si le groupe de mailles forme une ligne ouverte, on peut choisir le sens de parcours en choissant l'origine:
             # si le groupe de mailles forme une ligne fermée, il FAUT choisir l'origine et l'extrémité (= origine):
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             NOEUD_EXTR      =SIMP(statut='f',typ=no),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno),
             # si le groupe de mailles forme une ligne fermée, on peut choisir le sens de parcours
             VECT_ORIE       =SIMP(statut='f',typ='R',max=3),  # utilisé seulement si NOEUD_ORIG=NOEUD_EXTR
             ),

           b_segment       =BLOC(condition = "TYPE=='SEGMENT'",
             NB_POINTS       =SIMP(statut='o',typ='I',max=1),
             COOR_ORIG       =SIMP(statut='o',typ='R',min=2,max=3),
             COOR_EXTR       =SIMP(statut='o',typ='R',min=2,max=3),),

           b_arc           =BLOC(condition = "TYPE=='ARC'",
             NB_POINTS       =SIMP(statut='o',typ='I',max=1),
             COOR_ORIG       =SIMP(statut='o',typ='R',min=2,max=3),
             CENTRE          =SIMP(statut='o',typ='R',min=2,max=3),
             ANGLE           =SIMP(statut='o',typ='R',max=1),
             DNOR            =SIMP(statut='f',typ='R',min=2,max=3),),

           b_cylind       =BLOC(condition = ("REPERE=='CYLINDRIQUE' and TYPE!='ARC'"),
             ORIGINE         =SIMP(statut='f',typ='R',min=2,max=3),
             AXE_Z           =SIMP(statut='f',typ='R',min=3,max=3),),

           DISTANCE_MAX    =SIMP(statut='f',typ='R',defaut=0.,
                fr="Si la distance entre un noeud de la ligne de coupe et le maillage coupé "
                +"est > DISTANCE_MAX, ce noeud sera ignoré."),

         ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr


def macr_recal_prod(self,**args ):
  return listr8_sdaster

MACR_RECAL = MACRO(nom="MACR_RECAL",
                   op=OPS('Macro.macr_recal_ops.macr_recal_ops'),
                   sd_prod=macr_recal_prod,
                   UIinfo={"groupes":("Résolution","Résultats et champs",)},
                   fr="Réalise le recalage des calculs Aster sur des résultats expérimentaux" \
                      " ou sur d'autres résultats de calculs",
            regles=(UN_PARMI('PARA_OPTI','LIST_PARA'),
                    PRESENT_PRESENT('PARA_OPTI','COURBE'),
                    PRESENT_PRESENT('LIST_PARA','RESU_EXP'),
                    PRESENT_PRESENT('LIST_PARA','RESU_CALC'),
                    EXCLUS('LIST_POIDS','COURBE'),),

         UNITE_ESCL      =SIMP(statut='o',typ='I'),
         RESU_EXP        =SIMP(statut='f',typ=not_checked,max='**'),
         COURBE          =FACT(statut='f',max='**',
              FONC_EXP        =SIMP(statut='o',typ=(fonction_sdaster),),
              NOM_FONC_CALC   =SIMP(statut='o',typ='TXM',),
              PARA_X          =SIMP(statut='o',typ='TXM',),
              PARA_Y          =SIMP(statut='o',typ='TXM',),
              POIDS           =SIMP(statut='f',typ='R',),
         ),
         RESU_CALC       =SIMP(statut='f',typ=not_checked,max='**'),
         LIST_PARA       =SIMP(statut='f',typ=not_checked,max='**'),
         PARA_OPTI       =FACT(statut='f',max='**',
             NOM_PARA = SIMP(statut='o',typ='TXM'),
             VALE_INI = SIMP(statut='o',typ='R'),
             VALE_MIN = SIMP(statut='o',typ='R'),
             VALE_MAX = SIMP(statut='o',typ='R'),
         ),
         LIST_POIDS      =SIMP(statut='f',typ=not_checked,max='**'),

         UNITE_RESU      =SIMP(statut='f',typ='I',defaut=91),
         PARA_DIFF_FINI  =SIMP(statut='f',typ='R',defaut=0.00001),

         GRAPHIQUE       =FACT(statut='f',
             FORMAT          =SIMP(statut='f',typ='TXM',defaut='XMGRACE',into=("XMGRACE","GNUPLOT"),),
             AFFICHAGE       =SIMP(statut='f',typ='TXM',defaut='TOUTE_ITERATION',into=("TOUTE_ITERATION","ITERATION_FINALE"),),

             UNITE           =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                            fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
             b_pilote = BLOC(condition = "FORMAT == 'XMGRACE'", fr="Mots-clés propres à XMGRACE",
                 PILOTE          =SIMP(statut='f',typ='TXM',defaut='',
                                       into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),
                            fr="Pilote de sortie, PNG/JPEG/PDF ne sont pas disponibles sur toutes les installations de xmgrace"),
             ),
         ),


         # Methodes d'optimisation
         # -----------------------
         METHODE         =SIMP(statut='f',typ='TXM',defaut='LEVENBERG',into=("LEVENBERG", "FMIN", "FMINBFGS", "FMINNCG",
                                                                             "GENETIQUE","HYBRIDE")),

         b_genetique_options=BLOC(condition = "METHODE == 'GENETIQUE' or METHODE == 'HYBRIDE'" ,
             NB_PARENTS       =SIMP(statut='f',typ='I',defaut=10),
             NB_FILS          =SIMP(statut='f',typ='I',defaut=5),
             ECART_TYPE       =SIMP(statut='f',typ='R',defaut=1.),
             GRAINE           =SIMP(statut='f',typ='I'),
             ITER_ALGO_GENE   =SIMP(statut='f',typ='I',defaut=10),
             RESI_ALGO_GENE   =SIMP(statut='f',typ='R',defaut=1.E-3),
         ),


         # Criteres d'arret globaux
         # -------------------------
         ITER_MAXI       =SIMP(statut='f',typ='I',defaut=10,    fr="Nombre maximum d'iterations d'optimisation"),
         ITER_FONC_MAXI  =SIMP(statut='f',typ='I',defaut=1000,  fr="Nombre maximum d'evaluations de la focntionnelle"),
         RESI_GLOB_RELA  =SIMP(statut='f',typ='R',defaut=1.E-3, fr="Critere d'arret sur la valeur du residu"),
         TOLE_PARA       =SIMP(statut='f',typ='R',defaut=1.E-8, fr="Critere d'arret sur la valeur des parametres"),
         TOLE_FONC       =SIMP(statut='f',typ='R',defaut=1.E-8, fr="Critere d'arret sur la valeur de la fonctionnelle"),


         # Calculs des gradients
         # ---------------------
         b_gradient =BLOC(condition = "METHODE == 'FMINBFGS' or METHODE == 'FMINNCG'" ,
             GRADIENT        =SIMP(statut='f',typ='TXM',defaut='NON_CALCULE', into=("NON_CALCULE", "NORMAL", "ADIMENSIONNE" )),
         ),

         b_gradient_levenberg =BLOC(condition = "METHODE == 'LEVENBERG'" ,
             GRADIENT        =SIMP(statut='f',typ='TXM',defaut='NORMAL', into=( "NORMAL", "ADIMENSIONNE" )),
         ),


         # Mode d'evaluation de l'esclave
         # ------------------------------
         CALCUL_ESCLAVE       =FACT(statut='d',
#            regles=(PRESENT_PRESENT('MPI_NBNOEUD','MPI_NBCPU'),),

            LANCEMENT         =SIMP(statut='f', typ='TXM', defaut='INCLUSION',into=("DISTRIBUTION","INCLUSION"),),

            b_eval_distrib =BLOC(condition = "LANCEMENT == 'DISTRIBUTION'",
                UNITE_SUIVI   =SIMP(statut='f', typ='I',val_min=10,val_max=99,defaut=29,
                                  fr="Affichage de l'output et/ou error des jobs esclaves dans ce fichier"),
                MODE          =SIMP(statut='f', typ='TXM',      into=("INTERACTIF","BATCH"),),
                MEMOIRE       =SIMP(statut='f', typ='I',            fr="Memoire demandee pour les calculs esclaves (Mo)"),
                TEMPS         =SIMP(statut='f', typ='I',            fr="Temps demandee pour les calculs esclaves (secondes)"),
                MPI_NBCPU     =SIMP(statut='f', typ='I', val_min=1, fr="Nombre de cpu pour les calculs MPI"),
                MPI_NBNOEUD   =SIMP(statut='f', typ='I',            fr="Nombre de noeuds pour les calculs MPI"),
                CLASSE        =SIMP(statut='f', typ='TXM',          fr="Classe demandee pour les calculs en batch"),
                NMAX_SIMULT   =SIMP(statut='f', typ='I',
                               fr="Nombre de calculs esclaves lances en parallele en mode distribution (non precise = automatique)"),
            ),
         ),

         DYNAMIQUE       =FACT(statut='f',
               MODE_EXP           =SIMP(statut='o',typ='TXM'),
               MODE_CALC          =SIMP(statut='o',typ='TXM'),
               APPARIEMENT_MANUEL =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON")),
                               ),

         INFO            =SIMP(statut='f',typ='I',defaut=1, into=( 1, 2 ) ),
);

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: francois.voldoire at edf.fr


MACR_SPECTRE=MACRO(nom="MACR_SPECTRE",
                   op=OPS('Macro.macr_spectre_ops.macr_spectre_ops'),
                   sd_prod=table_sdaster,
                   reentrant='n',
                   UIinfo={"groupes":("Post-traitements","Outils-métier",)},
                   fr="Calcul de spectre, post-traitement de séisme",
         MAILLAGE      =SIMP(statut='o',typ=maillage_sdaster,),
         PLANCHER      =FACT(statut='o',max='**',
            regles=(AU_MOINS_UN('NOEUD','GROUP_NO' ),),
            NOM           =SIMP(statut='o',typ='TXM',),
            GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'), ),
         NOM_CHAM      =SIMP(statut='o',typ='TXM' ,into=('ACCE','DEPL')),
         CALCUL        =SIMP(statut='o',typ='TXM' ,into=('ABSOLU','RELATIF'),position='global'),
         b_acce  =BLOC( condition = "NOM_CHAM=='ACCE'",
           regles=(UN_PARMI('LIST_FREQ','FREQ'),),
           AMOR_SPEC     =SIMP(statut='o',typ='R',max='**'),
           LIST_INST     =SIMP(statut='f',typ=listr8_sdaster ),
           LIST_FREQ     =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ          =SIMP(statut='f',typ='R',max='**'),
           NORME         =SIMP(statut='o',typ='R'),
           RESU          =FACT(statut='o',max='**',
                regles=(UN_PARMI('RESU_GENE','RESULTAT','TABLE'),),
                TABLE         =SIMP(statut='f',typ=table_sdaster),
                RESU_GENE     =SIMP(statut='f',typ=tran_gene),
                RESULTAT      =SIMP(statut='f',typ=(dyna_trans,evol_noli)),
                b_calc  =BLOC( condition = "CALCUL=='RELATIF'",
                   ACCE_X        =SIMP(statut='o',typ=fonction_sdaster),
                   ACCE_Y        =SIMP(statut='o',typ=fonction_sdaster),
                   ACCE_Z        =SIMP(statut='o',typ=fonction_sdaster),), ),
           IMPRESSION    =FACT(statut='f',
                TRI           =SIMP(statut='f',typ='TXM',defaut='AMOR_SPEC',into=("AMOR_SPEC","DIRECTION",),),
                FORMAT        =SIMP(statut='f',typ='TXM',defaut='TABLEAU',into=("TABLEAU","XMGRACE",),),
                UNITE         =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                                    fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
                b_pilote = BLOC(condition = "FORMAT == 'XMGRACE'",
                   PILOTE        =SIMP(statut='f',typ='TXM',defaut='',
                                 into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),),),
                TOUT          =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON",),),
                              ),
         ),
         b_depl  =BLOC( condition = "NOM_CHAM=='DEPL'",
           LIST_INST     =SIMP(statut='f',typ=listr8_sdaster),
           RESU          =FACT(statut='o',max=3,
                regles=(UN_PARMI('RESU_GENE','RESULTAT','TABLE'),),
                TABLE         =SIMP(statut='f',typ=table_sdaster),
                RESU_GENE     =SIMP(statut='f',typ=tran_gene),
                RESULTAT      =SIMP(statut='f',typ=(dyna_trans,evol_noli)),
                b_calc  =BLOC( condition = "CALCUL=='ABSOLU'",
                   DEPL_X        =SIMP(statut='o',typ=fonction_sdaster),
                   DEPL_Y        =SIMP(statut='o',typ=fonction_sdaster),
                   DEPL_Z        =SIMP(statut='o',typ=fonction_sdaster),),),
         ),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr


def macro_elas_mult_prod(self,NUME_DDL,CAS_CHARGE,**args ):
  if NUME_DDL is not None and NUME_DDL.is_typco():
    self.type_sdprod(NUME_DDL,nume_ddl_sdaster)
  if CAS_CHARGE[0]['NOM_CAS']      != None : return mult_elas
  if CAS_CHARGE[0]['MODE_FOURIER'] != None : return fourier_elas
  raise AsException("type de concept resultat non prevu")

MACRO_ELAS_MULT=MACRO(nom="MACRO_ELAS_MULT",
                      op=OPS('Macro.macro_elas_mult_ops.macro_elas_mult_ops'),
                      sd_prod=macro_elas_mult_prod,
                      reentrant='f',
                      UIinfo={"groupes":("Résolution",)},
                      fr="Calculer les réponses statiques linéaires pour différents cas " \
                         "de charges ou modes de Fourier",
         regles=(UN_PARMI('CHAR_MECA_GLOBAL','LIAISON_DISCRET', ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster,CO)),
         CHAR_MECA_GLOBAL=SIMP(statut='f',typ=(char_meca),validators=NoRepeat(),max='**'),
         LIAISON_DISCRET =SIMP(statut='f',typ='TXM',into=("OUI",)),
         CAS_CHARGE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('NOM_CAS','MODE_FOURIER'),
                   UN_PARMI('CHAR_MECA','VECT_ASSE'),),
           NOM_CAS         =SIMP(statut='f',typ='TXM' ),
           MODE_FOURIER    =SIMP(statut='f',typ='I' ),
           TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="SYME",into=("SYME","ANTI","TOUS") ),
           CHAR_MECA       =SIMP(statut='f',typ=(char_meca),validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',into=("SIEF_ELGA","SANS"),defaut="SIEF_ELGA",max=1,
                                 fr="Contraintes aux points de Gauss.",),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT") ),
           b_mult_front    = BLOC ( condition = "METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
            ),
           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: albert.alarcon at edf.fr


def macro_expans_prod(self, MODELE_MESURE, RESU_NX, RESU_EX, RESU_ET, RESU_RD, **args):
    RESU_EXP = MODELE_MESURE['MESURE']
    self.type_sdprod(RESU_NX, mode_meca)
    for res in (RESU_EX, RESU_ET, RESU_RD):
        if res is not None and res.is_typco():
            if AsType(RESU_EXP) == mode_meca:
                self.type_sdprod(res, mode_meca)
            else:
                self.type_sdprod(res, dyna_harmo)
    return None

MACRO_EXPANS=MACRO(nom="MACRO_EXPANS",
                   op=OPS('Macro.macro_expans_ops.macro_expans_ops'),
                   sd_prod=macro_expans_prod,
                   reentrant='n',
                   UIinfo={"groupes":("Outils-métier","Dynamique",)},
                   fr="Outil d'expansion de resultats exprimentaux sur une base definie sur un modele numerique",
                        MODELE_CALCUL   = FACT(statut='o',
                           MODELE          = SIMP(statut='o',typ=(modele_sdaster) ),
                           BASE            = SIMP(statut='o',typ=(mode_meca,) ), 
                           NUME_MODE       = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**',defaut=0),
                           NUME_ORDRE      = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**',defaut=0),

                                             ),
                        MODELE_MESURE   = FACT(statut='o',
                           MODELE          = SIMP(statut='o',typ=(modele_sdaster) ),
                           MESURE          = SIMP(statut='o',typ=(dyna_trans,dyna_harmo,mode_meca,mode_meca_c,) ),
                           NOM_CHAM        = SIMP(statut='f',typ='TXM',defaut="DEPL",
                                                  into=("DEPL","VITE","ACCE","SIEF_NOEU","EPSI_NOEU",) ),
                           NUME_MODE       = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**',defaut=0),
                           NUME_ORDRE      = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**',defaut=0),

                                             ),
                        NUME_DDL       = SIMP(statut='f',typ=(nume_ddl_sdaster)),
                        RESU_NX        = SIMP(statut='f',typ=(mode_meca,dyna_harmo, CO)),
                        RESU_EX        = SIMP(statut='f',typ=(mode_meca,dyna_harmo, CO)),
                        RESU_ET        = SIMP(statut='f',typ=(mode_meca,dyna_harmo, CO)),
                        RESU_RD        = SIMP(statut='f',typ=(mode_meca,dyna_harmo, CO)),
                        RESOLUTION     = FACT(statut='f',
                           METHODE =SIMP(statut='f',typ='TXM',defaut="LU",into=("LU","SVD",) ),
                           b_svd   =BLOC(condition="METHODE=='SVD'",
                                         EPS=SIMP(statut='f',typ='R',defaut=0. ),
                                        ),
                           REGUL   =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","NORM_MIN","TIK_RELA",) ),
                           b_regul =BLOC(condition="REGUL!='NON'",
                                         regles=(PRESENT_ABSENT('COEF_PONDER','COEF_PONDER_F', ),),
                                         COEF_PONDER   =SIMP(statut='f',typ='R',defaut=0.     ,max='**' ),
                                         COEF_PONDER_F =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
                                        ),
                                             ),
                   )

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr


def macro_matr_ajou_prod(self,MATR_AMOR_AJOU,MATR_MASS_AJOU,MATR_RIGI_AJOU,FORC_AJOU,**args):
  self.type_sdprod(MATR_AMOR_AJOU,matr_asse_gene_r)
  self.type_sdprod(MATR_MASS_AJOU,matr_asse_gene_r)
  self.type_sdprod(MATR_RIGI_AJOU,matr_asse_gene_r)
  if FORC_AJOU != None:
    for m in FORC_AJOU:
      self.type_sdprod(m['VECTEUR'],vect_asse_gene)

  return None

MACRO_MATR_AJOU=MACRO(nom="MACRO_MATR_AJOU",
                      op=OPS('Macro.macro_matr_ajou_ops.macro_matr_ajou_ops'),
                      sd_prod=macro_matr_ajou_prod,
                      UIinfo={"groupes":("Résolution","Matrices et vecteurs",)},
                      fr="Calculer de facon plus condensée qu'avec CALC_MATR_AJOU des " \
                         "matrices de masse, d'amortissement ou de rigidité ajoutés",
      regles=(AU_MOINS_UN('MODE_MECA','DEPL_IMPO','MODELE_GENE'),
              AU_MOINS_UN('MATR_MASS_AJOU','MATR_AMOR_AJOU','MATR_RIGI_AJOU'),
              EXCLUS('MODE_MECA','DEPL_IMPO','MODELE_GENE'),
              EXCLUS('MONO_APPUI','MODE_STAT',),
             ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         GROUP_MA_FLUIDE =SIMP(statut='o',typ=grma),
         GROUP_MA_INTERF =SIMP(statut='o',typ=grma),
         MODELISATION    =SIMP(statut='o',typ='TXM',into=("PLAN","AXIS","3D")),
         FLUIDE          =FACT(statut='o',max='**',
           RHO             =SIMP(statut='o',typ='R'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           MAILLE          =SIMP(statut='f',typ=ma),
         ),
         DDL_IMPO        =FACT(statut='o',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO'),
                   UN_PARMI('PRES_FLUIDE','PRES_SORTIE'),),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           PRES_FLUIDE     =SIMP(statut='f',typ='R'),
           PRES_SORTIE     =SIMP(statut='f',typ='R'),
         ),
         ECOULEMENT      =FACT(statut='f',
           GROUP_MA_1      =SIMP(statut='o',typ=grma),
           GROUP_MA_2      =SIMP(statut='o',typ=grma),
           VNOR_1          =SIMP(statut='o',typ='R'),
           VNOR_2          =SIMP(statut='f',typ='R'),
           POTENTIEL       =SIMP(statut='f',typ=evol_ther),
         ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca),
         DEPL_IMPO       =SIMP(statut='f',typ=cham_no_sdaster),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.0E-2),
         MATR_MASS_AJOU  =SIMP(statut='f',typ=CO,),
         MATR_RIGI_AJOU  =SIMP(statut='f',typ=CO,),
         MATR_AMOR_AJOU  =SIMP(statut='f',typ=CO,),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",),),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca,),
         FORC_AJOU       =FACT(statut='f',max='**',
           DIRECTION     =SIMP(statut='o',typ='R',max=3),
           NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           VECTEUR       =SIMP(statut='o',typ=CO),
         ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MACRO_MATR_AJOU'),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr

def macro_mode_meca_prod( self, MATR_RIGI,MATR_MASS, **args) :
   if ( AsType(MATR_RIGI) == matr_asse_gene_r ):
      if ( AsType(MATR_MASS) == matr_asse_gene_r ):
         return mode_gene
      else:
         raise AsException("Matrices d'entrée de types différents : physique / généralisée.")

   return mode_meca


MACRO_MODE_MECA=MACRO(nom="MACRO_MODE_MECA",
                     op=OPS('Macro.macro_mode_meca_ops.macro_mode_meca_ops'),
                     sd_prod=macro_mode_meca_prod,
                     reentrant='n',fr="Lancer une succession de calculs de modes propres réels",
            UIinfo={"groupes":("Résolution","Dynamique",)},
         MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r, matr_asse_gene_r) ),
         MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r, matr_asse_gene_r) ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
#  ce mot cle ne devrait il pas etre dans calc_freq
         METHODE         =SIMP(statut='f',typ='TXM',defaut="SORENSEN",
                               into=("TRI_DIAG","JACOBI","SORENSEN",) ),
         b_tri_diag =BLOC(condition = "METHODE == 'TRI_DIAG'",
           PREC_ORTHO      =SIMP(statut='f',typ='R',defaut= 1.E-12,val_min=0.E+0 ),
           NMAX_ITER_ORTHO =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
           PREC_LANCZOS    =SIMP(statut='f',typ='R',defaut= 1.E-8,val_min=0.E+0 ),
           NMAX_ITER_QR    =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ),
         ),
         b_jacobi =BLOC(condition = "METHODE == 'JACOBI'",
           PREC_BATHE      =SIMP(statut='f',typ='R',defaut= 1.E-10,val_min=0.E+0 ),
           NMAX_ITER_BATHE =SIMP(statut='f',typ='I',defaut= 40,val_min=0 ),
           PREC_JACOBI     =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           NMAX_ITER_JACOBI=SIMP(statut='f',typ='I',defaut= 12,val_min=0 ),
         ),
         b_sorensen =BLOC(condition = "METHODE == 'SORENSEN'",
           PREC_SOREN      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),
           NMAX_ITER_SOREN =SIMP(statut='f',typ='I',defaut= 20,val_min=0 ),
           PARA_ORTHO_SOREN=SIMP(statut='f',typ='R',defaut= 0.717),
         ),

         OPTION          =SIMP(statut='f',typ='TXM',defaut="SANS",into=("MODE_RIGIDE","SANS") ),

         CALC_FREQ       =FACT(statut='o',
           FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max='**', ),
           DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
           COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
           NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3 ),
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2 ),
           SEUIL_FREQ      =SIMP(statut='f',typ='R' ,defaut= 1.E-2 ),
           STOP_BANDE_VIDE  =SIMP(statut='f',typ='TXM',defaut="NON" ,into=("OUI","NON") ),
         ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR              =C_SOLVEUR('INFO_MODE'),
         NIVEAU_PARALLELISME  =SIMP(statut='f',typ='TXM',defaut="COMPLET",into=("PARTIEL","COMPLET") ),
#-------------------------------------------------------------------

         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3 ),
           STURM           =SIMP(statut='f',typ='TXM',defaut="GLOBAL",into=("GLOBAL","LOCAL","NON") ),
         ),

         b_matr_phys =BLOC( condition = "AsType(MATR_RIGI) == matr_asse_depl_r",
         NORM_MODE       =FACT(statut='d',max='**',
           NORME           =SIMP(statut='f',typ='TXM',defaut="TRAN_ROTA",
                                 into=("MASS_GENE","RIGI_GENE","EUCL",
                                       "EUCL_TRAN","TRAN","TRAN_ROTA") ),
           INFO            =SIMP(statut='f',typ='I',defaut= 1 ,into=(1,2) ),
         ),

         FILTRE_MODE     =FACT(statut='f',
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",
                                 into=("MASS_EFFE_UN","MASS_GENE") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         ),

         IMPRESSION      =FACT(statut='d',
           TOUT_PARA       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           CUMUL           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",
                                 into=("MASS_EFFE_UN","MASS_GENE",) ),
         ),
                          ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
#
MAJ_CATA=PROC(nom="MAJ_CATA",op=20,
              UIinfo={"groupes":("Gestion du travail",)},
              fr="Compilation des catalogues d'éléments et couverture des calculs élémentaires",
              regles=(UN_PARMI('ELEMENT','TYPE_ELEM', ),),

              ELEMENT     =FACT(statut='f',),

              UNITE       =SIMP(statut='f',typ='I',defaut=8),       
              TYPE_ELEM   =FACT(statut='f',),
);

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
MECA_STATIQUE=OPER(nom="MECA_STATIQUE",op=46,sd_prod=evol_elas,
                   fr="Résoudre un problème de mécanique statique linéaire",reentrant='f',
            UIinfo={"groupes":("Résolution","Mécanique",)},
         regles=(EXCLUS("INST","LIST_INST"),
                 AU_MOINS_UN('CHAM_MATER','CARA_ELEM',),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater,
         fr="le CHAM_MATER est nécessaire, sauf si le modèle ne contient que des éléments discrets (modélisations DIS_XXX)",
         ang="CHAM_MATER is compulsory, except if the model contains only discret elements (modelizations DIS_XXX)"),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem,
         fr="le CARA_ELEM est nécessaire dès que le modèle contient des éléments de structure : coques, poutres, ...",
         ang="CARA_ELEM is compulsory as soon as the model contains structural elements : plates, beams, ..."),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
         ),
         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         INST_FIN        =SIMP(statut='f',typ='R'),
         OPTION          =SIMP(statut='f',typ='TXM',into=("SIEF_ELGA","SANS"),defaut="SIEF_ELGA",max=1,
             fr="Seule option : contraintes aux points de Gauss. Utilisez CALC_CHAMP pour les autres options.",
                          ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MECA_STATIQUE'),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
MODE_ITER_CYCL=OPER(nom="MODE_ITER_CYCL",op=  80,sd_prod=mode_cycl,
                    fr="Calcul des modes propres d'une structure à répétitivité cyclique à partir"
                        +" d'une base de modes propres réels",
                    reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         BASE_MODALE     =SIMP(statut='o',typ=mode_meca ),
         NB_MODE         =SIMP(statut='f',typ='I',defaut= 999 ),
         NB_SECTEUR      =SIMP(statut='o',typ='I' ),
         LIAISON         =FACT(statut='o',
           DROITE          =SIMP(statut='o',typ='TXM' ),
           GAUCHE          =SIMP(statut='o',typ='TXM' ),
           AXE             =SIMP(statut='f',typ='TXM' ),
         ),
         VERI_CYCL       =FACT(statut='f',
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF",) ),
           DIST_REFE       =SIMP(statut='f',typ='R' ),
         ),
         CALCUL          =FACT(statut='o',
           regles=(UN_PARMI('TOUT_DIAM','NB_DIAM'),),
           TOUT_DIAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NB_DIAM         =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE"
                                ,into=("PLUS_PETITE","CENTRE","BANDE") ),
           b_centre      =BLOC(condition = "OPTION == 'CENTRE'",
             FREQ            =SIMP(statut='o',typ='R',),
           ),
           b_bande       =BLOC(condition = "OPTION == 'BANDE'",
             FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max=2),
           ),
#  NMAX_FREQ n a-t-il pas un sens qu avec OPTION CENTRE                                
           NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10 ),
           PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 100. ),
           PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 50 ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
#

def mode_iter_inv_prod(TYPE_RESU,**args ):
  if (TYPE_RESU not in ["DYNAMIQUE","MODE_FLAMB","GENERAL"]):
     # on retourne un type fictif pour que le plantage aie lieu dans la lecture du catalogue
     return ASSD
  if TYPE_RESU == "MODE_FLAMB" : return mode_flamb
  if TYPE_RESU == "GENERAL"    : return mode_flamb
  # sinon on est dans le cas 'DYNAMIQUE' donc **args doit contenir les mots-clés
  # MATR_RIGI et (faculativement) MATR_AMOR, et on peut y accéder
  vale_rigi = args['MATR_RIGI']
  if (vale_rigi== None) : # si MATR_RIGI non renseigné
     # on retourne un type fictif pour que le plantage aie lieu dans la lecture du catalogue
     return ASSD
  vale_amor = args['MATR_AMOR']
  if AsType(vale_amor) == matr_asse_depl_r : return mode_meca_c
  if AsType(vale_rigi) == matr_asse_depl_r : return mode_meca
  if AsType(vale_rigi) == matr_asse_pres_r : return mode_acou
  if AsType(vale_rigi) == matr_asse_gene_r : return mode_gene
  raise AsException("type de concept resultat non prevu")

MODE_ITER_INV=OPER(nom="MODE_ITER_INV",op=  44,sd_prod=mode_iter_inv_prod
                    ,fr="Calcul des modes propres par itérations inverses ; valeurs propres et modes réels ou complexes",
                     reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},

         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",
                               into=("MODE_FLAMB","DYNAMIQUE","GENERAL"),
                               fr="Type d analyse" ),

         b_dynam         =BLOC(condition = "TYPE_RESU == 'DYNAMIQUE'",
           MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),
           CALC_FREQ       =FACT(statut='o',fr="Choix des paramètres pour le calcul des valeurs propres",

             OPTION          =SIMP(statut='f',typ='TXM',defaut="AJUSTE",into=("SEPARE","AJUSTE","PROCHE"),
                                   fr="Choix de l option pour estimer les valeurs propres"  ),
             FREQ            =SIMP(statut='o',typ='R',max='**',
                                   validators=AndVal((OrdList('croissant'), NoRepeat())),),
             AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
             NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 0,val_min=0 ),
             NMAX_ITER_SEPARE=SIMP(statut='f',typ='I' ,defaut= 30,val_min=1 ),
             PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=1.E-70 ),
             NMAX_ITER_AJUSTE=SIMP(statut='f',typ='I',defaut= 15,val_min=1 ),
             PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=1.E-70 ),

             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0, ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0, ),
             ),
           ),
         b_flamb        =BLOC(condition = "TYPE_RESU == 'MODE_FLAMB'",
           MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_RIGI_GEOM  =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           ),

         b_general      =BLOC(condition = "TYPE_RESU == 'GENERAL'",
           MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           ),

         b_flamb_general =BLOC(condition = "(TYPE_RESU == 'MODE_FLAMB') or (TYPE_RESU == 'GENERAL')",
           CALC_CHAR_CRIT  =FACT(statut='o',fr="Choix des paramètres pour le calcul des valeurs propres",

             OPTION          =SIMP(statut='f',typ='TXM',defaut="AJUSTE",into=("SEPARE","AJUSTE","PROCHE"),
                                 fr="Choix de l option pour estimer les valeurs propres"  ),
             CHAR_CRIT       =SIMP(statut='o',typ='R',max='**',
                                   validators=AndVal((OrdList('croissant'), NoRepeat())),),
             NMAX_CHAR_CRIT  =SIMP(statut='f',typ='I',defaut= 0,val_min=0 ),
             NMAX_ITER_SEPARE=SIMP(statut='f',typ='I',defaut= 30,val_min=1 ),
             PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=1.E-70 ),
             NMAX_ITER_AJUSTE=SIMP(statut='f',typ='I',defaut= 15,val_min=1 ),
             PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=1.E-70 ),

             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0, ),
             SEUIL_CHAR_CRIT =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0, ),
             ),
           ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MODE_ITER_INV'),
#-------------------------------------------------------------------

         CALC_MODE       =FACT(statut='d',min=0,fr="Choix des paramètres pour le calcul des vecteurs propres",
           OPTION          =SIMP(statut='f',typ='TXM',defaut="DIRECT",into=("DIRECT","RAYLEIGH") ),
           PREC            =SIMP(statut='f',typ='R',defaut= 1.E-5,val_min=1.E-70,fr="Précision de convergence" ),
           NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 30,val_min=1 ),
         ),
         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0,
                                 fr="Valeur limite admise pour l ereur a posteriori des modes"  ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
#

def mode_iter_simult_prod(TYPE_RESU,**args ):
  if (TYPE_RESU not in ["DYNAMIQUE","MODE_FLAMB","GENERAL"]):
     # on retourne un type fictif pour que le plantage aie lieu dans la lecture du catalogue
     return ASSD
  if TYPE_RESU == "MODE_FLAMB" : return mode_flamb
  if TYPE_RESU == "GENERAL" :    return mode_flamb
  # sinon on est dans le cas 'DYNAMIQUE' donc **args doit contenir les mots-clés
  # MATR_RIGI et (faculativement) MATR_AMOR, et on peut y accéder
  vale_rigi = args['MATR_RIGI']
  if (vale_rigi== None) : # si MATR_RIGI non renseigné
     # on retourne un type fictif pour que le plantage aie lieu dans la lecture du catalogue
     return ASSD
  vale_amor = args['MATR_AMOR']
  if (AsType(vale_amor)== matr_asse_depl_r) : return mode_meca_c
  if (AsType(vale_rigi)== matr_asse_depl_r) : return mode_meca
  if (AsType(vale_rigi)== matr_asse_depl_c) : return mode_meca_c
  if (AsType(vale_rigi)== matr_asse_pres_r) : return mode_acou
  if (AsType(vale_rigi)== matr_asse_gene_r) : return mode_gene
  if (AsType(vale_rigi)== matr_asse_gene_c) : return mode_gene

  raise AsException("type de concept resultat non prevu")



MODE_ITER_SIMULT=OPER(nom="MODE_ITER_SIMULT",op=  45, sd_prod= mode_iter_simult_prod,
                      fr="Calcul des modes propres par itérations simultanées ; valeurs propres et"
                         +" modes propres réels ou complexes",
                      reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         METHODE         =SIMP(statut='f',typ='TXM',defaut="SORENSEN",
                               into=("TRI_DIAG","JACOBI","SORENSEN","QZ") ),
         b_tri_diag =BLOC(condition = "METHODE == 'TRI_DIAG'",
           PREC_ORTHO      =SIMP(statut='f',typ='R',defaut= 1.E-12,val_min=0.E+0 ),
           NMAX_ITER_ORTHO =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
           PREC_LANCZOS    =SIMP(statut='f',typ='R',defaut= 1.E-8,val_min=0.E+0 ),
           NMAX_ITER_QR    =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ),
         ),
         b_jacobi =BLOC(condition = "METHODE == 'JACOBI'",
           PREC_BATHE      =SIMP(statut='f',typ='R',defaut= 1.E-10,val_min=0.E+0 ),
           NMAX_ITER_BATHE =SIMP(statut='f',typ='I',defaut= 40,val_min=0 ),
           PREC_JACOBI     =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           NMAX_ITER_JACOBI=SIMP(statut='f',typ='I',defaut= 12,val_min=0 ),
         ),
         b_sorensen =BLOC(condition = "METHODE == 'SORENSEN'",
           PREC_SOREN      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),
           NMAX_ITER_SOREN =SIMP(statut='f',typ='I',defaut= 20,val_min=0 ),
           PARA_ORTHO_SOREN=SIMP(statut='f',typ='R',defaut= 0.717),
         ),
         b_qz =BLOC(condition = "METHODE == 'QZ'",
           TYPE_QZ      =SIMP(statut='f',typ='TXM',defaut="QZ_SIMPLE",into=("QZ_QR","QZ_SIMPLE","QZ_EQUI") ),
         ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",
                               into=("DYNAMIQUE","MODE_FLAMB","GENERAL"),
                               fr="Type d analyse" ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="SANS",into=("MODE_RIGIDE","SANS"),
                               fr="Calcul des modes de corps rigide, uniquement pour la méthode TRI_DIAG" ),


         b_dynam        =BLOC(condition = "TYPE_RESU == 'DYNAMIQUE'",
           MATR_RIGI          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,
                                                    matr_asse_gene_r,matr_asse_gene_c,matr_asse_pres_r ) ),
           MATR_MASS          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_AMOR          =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
           CALC_FREQ       =FACT(statut='d',min=0,
             OPTION      =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","PLUS_GRANDE","BANDE","CENTRE","TOUT"),
                                   fr="Choix de l option et par conséquent du shift du problème modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites fréquences propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut=10,val_min=0 ),
             ),
             b_plus_grande =BLOC(condition = "OPTION == 'PLUS_GRANDE'",fr="Recherche des plus grandes fréquences propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut=1,val_min=0 ),
             ),
             b_centre       =BLOC(condition = "OPTION == 'CENTRE'",
                                  fr="Recherche des fréquences propres les plus proches d'une valeur donnée",
               FREQ            =SIMP(statut='o',typ='R',
                                     fr="Fréquence autour de laquelle on cherche les fréquences propres"),
               AMOR_REDUIT     =SIMP(statut='f',typ='R',),
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande         =BLOC(condition = "(OPTION == 'BANDE')",
                                   fr="Recherche des fréquences propres dans une bande donnée",
               FREQ            =SIMP(statut='o',typ='R',min=2,max=2,
                                     validators=AndVal((OrdList('croissant'), NoRepeat())),
                                     fr="Valeur des deux fréquences délimitant la bande de recherche"),
               TABLE_FREQ      =SIMP(statut= 'f',typ=table_sdaster),
             ),
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG","COMPLEXE"),
                                   fr="Choix du pseudo-produit scalaire pour la résolution du problème quadratique" ),
             regles=(EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
             COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0 ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
             ),
           ),


         b_general        =BLOC(condition = "TYPE_RESU == 'GENERAL'",
           MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           ),


         b_flamb         =BLOC(condition = "TYPE_RESU == 'MODE_FLAMB'",
           MATR_RIGI          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
           MATR_RIGI_GEOM     =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
         ),


         b_flamb_general  =BLOC(condition = "(TYPE_RESU == 'MODE_FLAMB') or (TYPE_RESU == 'GENERAL')",
           CALC_CHAR_CRIT  =FACT(statut='d',min=0,
             OPTION       =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","BANDE","CENTRE","TOUT"),
                                   fr="Choix de l option et par conséquent du shift du problème modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites valeurs propres",
               NMAX_CHAR_CRIT  =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_centre      =BLOC(condition = "OPTION == 'CENTRE'",
                                 fr="Recherche des valeurs propres les plus proches d une valeur donnée",
               CHAR_CRIT       =SIMP(statut='o',typ='R',
                                     fr="Charge critique autour de laquelle on cherche les charges critiques propres"),
               NMAX_CHAR_CRIT  =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande       =BLOC(condition = "(OPTION == 'BANDE')",
                                 fr="Recherche des valeurs propres dans une bande donnée",
               CHAR_CRIT       =SIMP(statut='o',typ='R',min=2,max=2,
                                     validators=AndVal((OrdList('croissant'), NoRepeat())),
                                     fr="Valeur des deux charges critiques délimitant la bande de recherche"),
               TABLE_CHAR_CRIT =SIMP(statut= 'f',typ=table_sdaster),

             ),
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG"),
                                   fr="Choix du pseudo-produit scalaire pour la résolution du problème quadratique" ),
             regles=(EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
             COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 3,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0 ),
             SEUIL_CHAR_CRIT =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
             ),
           ),


#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MODE_ITER_SIMULT'),
#-------------------------------------------------------------------
#-------------------------------------------------------------------
#  Mot-cles caches pour activer le parallelisme au sein d'une macro-commande
         PARALLELISME_MACRO=FACT(statut='d',min=0,
           TYPE_COM   =SIMP(statut='c',typ='I',defaut=-999,into=(-999,1),fr="Type de communication"),
           IPARA1_COM  =SIMP(statut='c',typ='I',defaut=-999,fr="Parametre entier n 1 de la communication"),
           IPARA2_COM  =SIMP(statut='c',typ='I',defaut=-999,fr="Parametre entier n 2 de la communication"),
         ),
#-------------------------------------------------------------------
         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3,val_min=0.E+0 ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0,
                                 fr="Valeur limite admise pour l ereur a posteriori des modes" ),
           STURM           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         STOP_BANDE_VIDE =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
MODE_NON_LINE=OPER(nom="MODE_NON_LINE",op=  61,sd_prod=table_container,
                     fr="Calcul des modes non-linéaires",
                     reentrant='f',
           UIinfo={"groupes":("Résolution","Dynamique",)},

        reuse =SIMP(statut='f',typ='table_container'),

        ETAT_INIT       =FACT(statut='o',max=1,
                regles=( UN_PARMI('MODE_LINE','MODE_NON_LINE'),),
                       MODE_LINE = SIMP(statut='f',typ=mode_meca,max = 1),
                       MODE_NON_LINE = SIMP(statut='f',typ=table_container,max = 1),
                       NUME_ORDRE = SIMP(statut='o',typ='I' ),
                       DIR_EVOLUTION    = SIMP(statut='f',typ='I',defaut=-1, into=(-1,1)),
                       COEF_AMPL = SIMP(statut='f',typ='R',defaut=1,),
                  ),

        CHOC = FACT(statut='f',max='**',
                regles=( UN_PARMI('NOEUD','GROUP_NO'),),
                    OBSTACLE = SIMP(statut='f',typ='TXM', into=("PLAN","BI_PLAN","CERCLE",)),
                    b_cercle = BLOC(condition="OBSTACLE=='CERCLE'",
                                     NOM_CMP = SIMP(statut='o',typ='TXM',min=2,max=2,validators=NoRepeat(),
                                                    into=('DX','DY','DZ'),),
                                     ORIG_OBST = SIMP(statut='f',typ='R',defaut=(0.,0.,0.),min=3,max=3),
                                     ),
                    b_bi_plan = BLOC(condition="OBSTACLE=='BI_PLAN'",
                                   NOM_CMP = SIMP(statut='o',typ='TXM',min=1,max=1,into=('DX','DY','DZ'),),
                                   ),
                    b_plan = BLOC(condition="OBSTACLE=='PLAN'",
                                   NOM_CMP = SIMP(statut='o',typ='TXM',min=1,max=1,into=('DX','DY','DZ'),),
                                    ),
                    NOEUD = SIMP(statut='f', typ=no, max=1),
                    GROUP_NO = SIMP(statut='f', typ=grno, max=1),
                    JEU = SIMP(statut='o',typ='R',max=1 ),
                    RIGI_NOR = SIMP(statut='o',typ='R',max=1 ),
                    PARA_REGUL = SIMP(statut='f',typ='R',defaut=0.005 ),
                ),

        MATR_RIGI = SIMP(statut='o',typ=(matr_asse_depl_r,) ),
        MATR_MASS = SIMP(statut='o',typ=(matr_asse_depl_r,) ),

        RESOLUTION = FACT(statut='o',max=1,
                       METHODE = SIMP(statut='f',typ='TXM',defaut="EHMAN",into=("EHMAN",)),
                       b_ehman = BLOC(condition="METHODE=='EHMAN'",
                                    NB_HARM_LINE = SIMP(statut='o',typ='I',val_min=1,),
                                    NB_HARM_NONL = SIMP(statut='f',typ='I',defaut=201,val_min=1,),
                                    NB_BRANCHE = SIMP(statut='o',typ='I',val_min=0),
                                    NB_PAS_MAN = SIMP(statut='o',typ='I',val_min=1),
                                    NB_ORDRE_MAN = SIMP(statut='f',typ='I',defaut=20,val_min=2),
                                    PREC_MAN = SIMP(statut='f',typ='R',defaut=1.E-9,val_min=0.E+0),
                                    PREC_NEWTON = SIMP(statut='f',typ='R',defaut=1.E-8,val_min=0.E+0),
                                    ITER_NEWTON_MAXI = SIMP(statut='f',typ='I',defaut=15,val_min=1),
                                    CRIT_ORDR_BIFURCATION = SIMP(statut='f',typ='I',defaut=3,val_min=1),
                                    RESI_RELA_BIFURCATION = SIMP(statut='f',typ='R',defaut=1.E-4,val_min=0.E+0),
                                   ),
                       ),

        SOLVEUR = C_SOLVEUR('MODE_NON_LINE'),
        
        INFO = SIMP(statut='f',typ='I',defaut=1),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: georges-cc.devesa at edf.fr

MODE_STATIQUE=OPER(nom="MODE_STATIQUE",op= 93,sd_prod=mode_meca,
                   fr="Calcul de déformées statiques pour un déplacement, une force ou une accélération unitaire imposé",
                   reentrant='n',
            UIinfo={"groupes":("Résolution","Dynamique",)},

         regles=(UN_PARMI('MODE_STAT','FORCE_NODALE','PSEUDO_MODE','MODE_INTERF'),
                 PRESENT_PRESENT('MODE_INTERF','MATR_MASS'),
                 PRESENT_PRESENT('PSEUDO_MODE','MATR_MASS'),
                 ),


         MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_MASS       =SIMP(statut='f',typ=matr_asse_depl_r ),



         MODE_STAT       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO'),
                   UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ,),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ,),
           AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
         ),
         FORCE_NODALE    =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO'),
                   UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",), ),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",), ),
           AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
         ),
         PSEUDO_MODE       =FACT(statut='f',max='**',
           regles=(UN_PARMI('AXE','DIRECTION','TOUT','NOEUD','GROUP_NO' ),),
           AXE             =SIMP(statut='f',typ='TXM',into=("X","Y","Z"),max=3),
           DIRECTION       =SIMP(statut='f',typ='R',min=3,max=3),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           b_dir           =BLOC(condition = "DIRECTION != None",
             NOM_DIR         =SIMP(statut='f',typ='TXM' ),),
           b_cmp          =BLOC(condition="TOUT!= None or NOEUD!=None or GROUP_NO!=None",
             regles=(UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
             TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
             SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           ),
         ),
         MODE_INTERF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO'),
                   UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",), ),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           NBMOD           =SIMP(statut='o',typ='I',defaut= 1),
           SHIFT           =SIMP(statut='o',typ='R',defaut= 1.0),

         ),

#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('MODE_STATIQUE'),
#-------------------------------------------------------------------

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ,) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
MODI_BASE_MODALE=OPER(nom="MODI_BASE_MODALE",op= 149,sd_prod=mode_meca,
                      reentrant='f',
            fr="Définir la base modale d'une structure sous écoulement",
            UIinfo={"groupes":("Matrices et vecteurs",)},
#  la commande modi_base _modale : reentrant = f ou o                      
         regles=(EXCLUS('AMOR_UNIF','AMOR_REDUIT', ),),
         BASE            =SIMP(statut='o',typ=mode_meca ),
         BASE_ELAS_FLUI  =SIMP(statut='o',typ=melasflu_sdaster ),
         NUME_VITE_FLUI  =SIMP(statut='o',typ='I' ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         AMOR_UNIF       =SIMP(statut='f',typ='R' ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
#
#  RECUPERATION DES EFFORTS VIA YACS POUR COUPLAGE IFS
#
MODI_CHAR_YACS=OPER(nom            = "MODI_CHAR_YACS",
                   op              = 112,
                   sd_prod         = char_meca,
                   reentrant       = 'o',
                   UIinfo          = {"groupes":("Résultats et champs",)},
                   fr              = "Reception des forces nodales via YACS lors du couplage de  Code_Aster et Saturne",
                   CHAR_MECA       = SIMP(statut ='o', typ = char_meca),
                   MATR_PROJECTION = SIMP(statut ='o', typ = corresp_2_mailla,),
                   NOM_CMP_IFS     = SIMP(statut ='o', typ = 'TXM',validators = NoRepeat(), max = '**'),
                   VIS_A_VIS       = FACT(statut ='o', max = '**',
                                   GROUP_MA_1 = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
                                   GROUP_NO_2 = SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**'),),
                   INST            = SIMP(statut='o',typ='R', ),
                   PAS             = SIMP(statut='o',typ='R', ),
                   NUME_ORDRE_YACS = SIMP(statut='o', typ='I',),
                   INFO            = SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
);

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
MODI_MAILLAGE=OPER(nom="MODI_MAILLAGE",op= 154,sd_prod=maillage_sdaster,
                   fr="Effectuer des modifications sur un maillage existant: réorienter des mailles servant,"
                      +" à l'application d'une pression, à la modélisation du contact,...",
                   reentrant='o',
            UIinfo={"groupes":("Maillage",)},
      regles=(AU_MOINS_UN('ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'TRANSLATION','ROTATION','MODI_BASE','ECHELLE','ORIE_SHB','SYMETRIE',
                       'ORIE_LIGNE',),
              PRESENT_ABSENT('ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'ORIE_LIGNE'),
              PRESENT_ABSENT('DEFORME','ORIE_FISSURE','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'ORIE_LIGNE'),
              PRESENT_ABSENT('EQUE_PIQUA','ORIE_FISSURE','DEFORME','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'ORIE_LIGNE'),
              PRESENT_ABSENT('ORIE_PEAU_2D','ORIE_FISSURE','DEFORME','EQUE_PIQUA',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'ORIE_LIGNE'),
              PRESENT_ABSENT('ORIE_PEAU_3D','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('ORIE_NORM_COQUE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'PLAQ_TUBE','MODI_MAILLE','ORIE_LIGNE'),
              PRESENT_ABSENT('PLAQ_TUBE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','MODI_MAILLE','ORIE_LIGNE'),
              PRESENT_ABSENT('MODI_MAILLE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','ORIE_LIGNE'),
              EXCLUS('EQUE_PIQUA','PLAQ_TUBE'),
              EXCLUS('EQUE_PIQUA','TUBE_COUDE'),
              EXCLUS('ROTATION','MODI_BASE'),
              EXCLUS('SYMETRIE','ROTATION'),
              EXCLUS('SYMETRIE','TRANSLATION'),
              EXCLUS('SYMETRIE','MODI_BASE'),
              EXCLUS('SYMETRIE','ECHELLE'),
              ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),

         ORIE_FISSURE    =FACT(statut='f',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),

         DEFORME         =FACT(statut='f',
           OPTION          =SIMP(statut='o',typ='TXM',into=("TRAN","TRAN_APPUI") ),
           DEPL            =SIMP(statut='o',typ=cham_no_sdaster ),
        b_deform        =BLOC(condition = "OPTION=='TRAN_APPUI'",
           GROUP_NO_APPUI = SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**' ),
           GROUP_NO_STRU  = SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**' ),),
         ),

         EQUE_PIQUA      =FACT(statut='f',
           GROUP_NO        =SIMP(statut='o',typ=grno),
           E_BASE          =SIMP(statut='o',typ='R' ),
           DEXT_BASE       =SIMP(statut='o',typ='R' ),
           L_BASE          =SIMP(statut='o',typ='R' ),
           L_CHANF         =SIMP(statut='o',typ='R' ),
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2")),
           H_SOUD          =SIMP(statut='o',typ='R' ),
           ANGL_SOUD       =SIMP(statut='o',typ='R' ),
           JEU_SOUD        =SIMP(statut='o',typ='R' ),
           E_CORP          =SIMP(statut='o',typ='R' ),
           DEXT_CORP       =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='o',typ='R' ),
           RAFF_MAIL       =SIMP(statut='o',typ='TXM' ),
           X_MAX           =SIMP(statut='o',typ='R' ),
         ),
         ORIE_PEAU_2D    =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA_SURF   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_PEAU_3D    =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA_VOLU   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_SHB       =FACT(statut='f',max=1,
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_NORM_COQUE =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           VECT_NORM       =SIMP(statut='f',typ='R',max=3),
           b_vect_norm     =BLOC(condition = "VECT_NORM != None",
             regles=UN_PARMI('NOEUD','GROUP_NO'),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
           ),
         ),
         ORIE_LIGNE =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           VECT_TANG       =SIMP(statut='f',typ='R',max=3),
           b_vect_tang     =BLOC(condition = "VECT_TANG != None",
             regles=UN_PARMI('NOEUD','GROUP_NO'),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
           ),
         ),
         PLAQ_TUBE       =FACT(statut='f',
           DEXT            =SIMP(statut='o',typ='R' ),
           EPAIS           =SIMP(statut='o',typ='R' ),
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),
           COUTURE         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",)  ),
         ),
         TUBE_COUDE      =FACT(statut='f',
           ANGLE           =SIMP(statut='o',typ='R' ),
           R_CINTR         =SIMP(statut='o',typ='R' ),
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),
         ),
         MODI_MAILLE     =FACT(statut='f',max=1,
           regles=(AU_MOINS_UN('GROUP_MA_FOND','MAILLE_FOND','GROUP_NO_FOND','NOEUD_FOND'),),
           OPTION          =SIMP(statut='o',typ='TXM',into=("NOEUD_QUART",) ),
           GROUP_MA_FOND   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1),
           MAILLE_FOND     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max=1),
           GROUP_NO_FOND   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
           NOEUD_FOND      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
         ),
         MODI_BASE       =FACT(statut='f',
           VECT_X          =SIMP(statut='o',typ='R',min=2,max=3),
           VECT_Y          =SIMP(statut='f',typ='R',min=2,max=3),
         ),
         ECHELLE         =SIMP(statut='f',typ='R',),
         TRANSLATION     =SIMP(statut='f',typ='R',min=2,max=3),
         ROTATION        =FACT(statut='f',max='**',
           POIN_1           =SIMP(statut='o',typ='R',min=2,max=3),
           ANGLE            =SIMP(statut='o',typ='R',defaut= 0.E+0 ),
           regles=(EXCLUS('DIR','POIN_2'),),
           POIN_2           =SIMP(statut='f',typ='R',min=2,max=3),
           DIR              =SIMP(statut='f',typ='R',min=2,max=3),
         ),
         SYMETRIE        =FACT(statut='f',max='**',
                          fr = "Symétrie du maillage par rapport à un plan en 3D ou à une droite en 2D.",
           POINT           =SIMP(statut='o',typ='R',min=2,max=3,
                            fr="Point appartenant à la droite ou au plan."),
           AXE_1           =SIMP(statut='o',typ='R',min=2,max=3,
                            fr="Vecteur directeur de la droite ou 1er vecteur appartenant au plan."),
           AXE_2           =SIMP(statut='f',typ='R',min=3,max=3,
                            fr="2nd vecteur appartenant du plan."),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

MODI_MODELE=OPER(nom="MODI_MODELE",op= 103,sd_prod=modele_sdaster,reentrant='o',
         UIinfo={"groupes":("Modélisation",)},
         fr="Modifier la partition d'un modèle (parallélisme) ",

         MODELE          =SIMP(statut='o',typ=modele_sdaster,min=1,max=1,),

         PARTITION         =FACT(statut='d',
             PARALLELISME    =SIMP(statut='f',typ='TXM',defaut="GROUP_ELEM",
                                   into=("MAIL_CONTIGU","MAIL_DISPERSE","SOUS_DOMAINE","CENTRALISE","GROUP_ELEM")),
             b_dist_maille          =BLOC(condition = "PARALLELISME in ('MAIL_DISPERSE','MAIL_CONTIGU')",
                 CHARGE_PROC0_MA =SIMP(statut='f',typ='I',defaut=100,val_min=0),
             ),
             b_dist_sd          =BLOC(condition = "PARALLELISME == 'SOUS_DOMAINE'",
                 PARTITION       =SIMP(statut='o',typ=sd_partit),
                 CHARGE_PROC0_SD =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             ),
         ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

MODI_MODELE_XFEM=OPER(nom="MODI_MODELE_XFEM",op= 113,sd_prod=modele_sdaster,docu="U4.44.12-e",reentrant='f',
            UIinfo={"groupes":("Modélisation","Rupture",)},
                           fr="Engendrer ou enrichir une structure de donnees en affectant les cham_gd associes",
                           
    MODELE_IN       =SIMP(statut='o',typ=modele_sdaster,min=1,max=1,),
    FISSURE         =SIMP(statut='o',typ=fiss_xfem,min=1,max='**',),
    CRITERE         =SIMP(statut='f',typ='R',defaut=1.1E-9),
    INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,)),
    CONTACT        
     =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON"),min=1,max=1,),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
def modi_repere_prod(RESULTAT,**args):
  if AsType(RESULTAT) != None : return AsType(RESULTAT)

MODI_REPERE=OPER(nom="MODI_REPERE",op=191,sd_prod=modi_repere_prod,reentrant='f',
            UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
                    fr="Calcule des résultats dans le repère cylindrique",
         RESULTAT        =SIMP(statut='o',typ=resultat_sdaster),

         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                        'NOEUD_CMP','LIST_INST','LIST_FREQ','NOM_CAS'),),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         NOM_CAS         =SIMP(statut='f',typ='TXM' ),

         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
         b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
         b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION       =SIMP(statut='o',typ='R',),),

         MODI_CHAM       =FACT(statut='o',max='**',
           TYPE_CHAM       =SIMP(statut='o',typ='TXM',
              into=("VECT_2D","VECT_3D","TENS_2D","TENS_3D","COQUE_GENE"),),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
           b_vect_2d       =BLOC(condition = "TYPE_CHAM=='VECT_2D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=2,max=2 ),),
           b_vect_3d       =BLOC(condition = "TYPE_CHAM=='VECT_3D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=3,max=3 ),),
           b_tens_2d       =BLOC(condition = "TYPE_CHAM=='TENS_2D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=4,max=4 ),),
           b_tens_3d       =BLOC(condition = "TYPE_CHAM=='TENS_3D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=6,max=6 ),),
           b_coque_gene    =BLOC(condition = "TYPE_CHAM=='COQUE_GENE'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=8,max=8 ),),
         ),
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : COQUE_INTR_UTIL ou COQUE_UTIL_INTR autorise",
           REPERE          =SIMP(statut='o',typ='TXM',position='global',
                                 into=("COQUE_INTR_UTIL","COQUE_UTIL_INTR"),),
           AFFE     =FACT(statut='o',max='**',
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           ),
          ),

         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant ",
           REPERE          =SIMP(statut='f',typ='TXM',defaut="UTILISATEUR",position='global',
                                 into=("UTILISATEUR","CYLINDRIQUE","COQUE",
                                       "COQUE_INTR_UTIL","COQUE_UTIL_INTR"),),

           AFFE     =FACT(statut='o',max='**',
            b_cyl      =BLOC(condition = "REPERE == 'CYLINDRIQUE'",            
              ORIGINE         =SIMP(statut='f',typ='R',min=2,max=3),
              AXE_Z           =SIMP(statut='f',typ='R',min=3,max=3),),
            b_uti      =BLOC(condition = "REPERE == 'UTILISATEUR'",             
                            regles=(UN_PARMI('ANGL_NAUT','VECT_X'),
                            ENSEMBLE('VECT_X','VECT_Y')),
              ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
              VECT_X          =SIMP(statut='f',typ='R',min=3,max=3 ),
              VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3 ),),
            b_coq      =BLOC(condition = "REPERE == 'COQUE'",             
                            regles=(UN_PARMI('ANGL_REP','VECTEUR'),),
              ANGL_REP        =SIMP(statut='f',typ='R',min=2,max=2),
              VECTEUR         =SIMP(statut='f',typ='R',min=3,max=3),),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
          ),
         ),
          TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: nicolas.brie at edf.fr

def norm_mode_prod(MODE,**args ):
  if AsType(MODE) == mode_meca   : return mode_meca
  if AsType(MODE) == mode_meca_c : return mode_meca_c
  if AsType(MODE) == mode_flamb  : return mode_flamb
  raise AsException("type de concept resultat non prevu")

NORM_MODE=OPER(nom="NORM_MODE",op=  37,sd_prod=norm_mode_prod,
               fr="Normer des modes propres en fonction d'un critère choisi par l'utilisateur",
               reentrant='f',
            UIinfo={"groupes":("Résolution","Dynamique",)},
         regles=(UN_PARMI('NORME','GROUP_NO','NOEUD','AVEC_CMP','SANS_CMP'),),
         MODE       =SIMP(statut='o',typ=(mode_meca,mode_flamb) ),
         NORME      =SIMP(statut='f',typ='TXM',fr="Norme prédéfinie : masse généralisée, euclidienne,...",
                          into=("MASS_GENE","RIGI_GENE","EUCL","EUCL_TRAN","TRAN","TRAN_ROTA") ),
         NOEUD      =SIMP(statut='f',typ=no, fr="Composante donnée d'un noeud spécifié égale à 1"),
         GROUP_NO   =SIMP(statut='f',typ=grno,fr="Composante donnée d'un groupe contenant un seul noeud spécifié égale à 1"),
         b_noeud    =BLOC(condition = "NOEUD != None or GROUP_NO != None",
           NOM_CMP    =SIMP(statut='o',typ='TXM' ),
         ),
         AVEC_CMP   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         SANS_CMP   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         MODE_SIGNE =FACT(statut='f',fr="Imposer un signe sur une des composantes des modes",
                  regles=(UN_PARMI('GROUP_NO','NOEUD'),),
           NOEUD      =SIMP(statut='f',typ=no,fr="Noeud où sera imposé le signe"),
           GROUP_NO   =SIMP(statut='f',typ=grno,fr="Groupe d'un seul noeud où sera imposé le signe"),
           NOM_CMP    =SIMP(statut='o',typ='TXM',fr="Composante du noeud où sera imposé le signe" ),
           SIGNE      =SIMP(statut='f',typ='TXM',defaut="POSITIF",into=("NEGATIF","POSITIF"),
                            fr="Choix du signe" ),
         ),

         MASSE = SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ), ),
         RAIDE = SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ), ),
         AMOR  = SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
         TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         INFO       =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
NUME_DDL=OPER(nom="NUME_DDL",op=11,sd_prod=nume_ddl_sdaster,reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
              fr="Etablissement de la numérotation des ddl avec ou sans renumérotation et du stockage de la matrice",
                  regles=(UN_PARMI('MATR_RIGI','MODELE'),),
         MATR_RIGI       =SIMP(statut='f',validators=NoRepeat(),max=100,
                               typ=(matr_elem_depl_r ,matr_elem_depl_c,matr_elem_temp_r ,matr_elem_pres_c) ),
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         b_modele        =BLOC(condition = "MODELE != None",
           CHARGE     =SIMP(statut='f',validators=NoRepeat(),max='**',typ=(char_meca,char_ther,char_acou, ),),
         ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","PETSC","MUMPS") ),
         b_mult_front    =BLOC(condition="METHODE=='MULT_FRONT'",fr="paramètres associés à la méthode multifrontale",
           RENUM           =SIMP(statut='f',typ='TXM',into=("MD","MDA","METIS"),defaut="METIS" ),
         ),
         b_ldlt          =BLOC(condition="METHODE=='LDLT'",fr="paramètres associés à la méthode LDLT",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
           RENUM        =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","SCOTCH","AUTO")),
         ),
         b_gcpc          =BLOC(condition="METHODE=='GCPC' or METHODE=='PETSC'",fr="paramètres associés à la GCPC ou PETSc",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.corus at edf.fr
NUME_DDL_GENE=OPER(nom="NUME_DDL_GENE",op= 127,sd_prod=nume_ddl_gene,
                   fr="Etablissement de la numérotation des ddl d'un modèle etabli en coordonnées généralisees",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=UN_PARMI('MODELE_GENE','BASE'),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
             b_modele_gene     =BLOC(condition = "MODELE_GENE != None",
               STOCKAGE     =SIMP(statut='f',typ='TXM',defaut="LIGN_CIEL",into=("LIGN_CIEL","PLEIN") ),
               METHODE            =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("INITIAL","CLASSIQUE","ELIMINE") ),
                                    ),
         BASE     =SIMP(statut='f',typ=(mode_meca,mode_gene ) ),
             b_base     =BLOC(condition = "BASE != None",
               STOCKAGE     =SIMP(statut='f',typ='TXM',defaut="PLEIN",into=("DIAG","PLEIN") ),
               NB_VECT     =SIMP(statut='f',typ='I',defaut= 9999 ),
                             ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr

def observation_prod(self, RESULTAT, **args):
    if  AsType(RESULTAT) == mode_meca :
        return mode_meca
    elif AsType(RESULTAT) == evol_elas :
        return evol_elas
    elif AsType(RESULTAT) == dyna_harmo :
        return dyna_harmo
    elif AsType(RESULTAT) == dyna_trans :
        return dyna_trans
    else :
        return None

OBSERVATION=MACRO(nom="OBSERVATION",
                  op=OPS('Macro.observation_ops.observation_ops'),
                  UIinfo={"groupes":("Matrices et vecteurs",)},
                  sd_prod=observation_prod,
                  fr="Calcul de l'observabilite d'un champ aux noeuds ",
#
         MODELE_1        =SIMP(statut='o',typ=modele_sdaster),
         MODELE_2        =SIMP(statut='o',typ=modele_sdaster),
         RESULTAT        =SIMP(statut='o',typ=(mode_meca,evol_elas,dyna_harmo,dyna_trans,) ),
         NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(),),

#        ------------------------------------------------------------------

         regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','FREQ','LIST_FREQ','NUME_MODE','INST','LIST_INST' ),),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),

#        ------------------------------------------------------------------
#        OPTIONS DE PROJ_CHAMP (SANS MC FACTEUR PARTICULIER)
#        ------------------------------------------------------------------
         PROJECTION     =SIMP(statut='f',max=1,typ='TXM',into=("OUI","NON"),defaut="OUI"),
         CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
         DISTANCE_MAX    =SIMP(statut='f',typ='R',
                fr="Distance maximale entre le noeud et l'élément le plus proche, lorsque le noeud n'est dans aucun élément."),
         ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),

         TYPE_CHAM       =SIMP(statut='f',typ='TXM',into=("NOEU",),
                fr="Pour forcer le type des champs projetés. NOEU -> cham_no"),

#           PROL_ZERO       =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
#                fr="Si le résultat est un mode_xxx ou une base_xxx, on peut prolonger"
#                   +" les champs par zéro la ou la projection ne donne pas de valeurs."),

         MATR_RIGI       =SIMP(statut='f',typ=(matr_asse_depl_r) ),
         MATR_MASS       =SIMP(statut='f',typ=(matr_asse_depl_r) ),
         VIS_A_VIS       =FACT(statut='f',max='**',
             regles=(AU_MOINS_UN('TOUT_1','GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                     AU_MOINS_UN('TOUT_2','GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),),
             TOUT_1          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             TOUT_2          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
             ),

#        ------------------------------------------------------------------
#        MODI_REPERE
#        ------------------------------------------------------------------
         MODI_REPERE     =FACT(statut='f',max='**',
         regles=(UN_PARMI('REPERE'),
                 AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
#
           TYPE_CHAM       =SIMP(statut='f',typ='TXM',
                                 into=("VECT_2D","VECT_3D","TENS_2D","TENS_3D"),
                                       defaut="VECT_3D"),
           b_vect_2d       =BLOC(condition = "TYPE_CHAM=='VECT_2D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=2,max=2 ),),
           b_vect_3d       =BLOC(condition = "TYPE_CHAM=='VECT_3D'",
              NOM_CMP         =SIMP(statut='f',typ='TXM',min=3,max=3,defaut=('DX','DY','DZ') ),),
           b_tens_2d       =BLOC(condition = "TYPE_CHAM=='TENS_2D'",
              NOM_CMP         =SIMP(statut='f',typ='TXM',min=4,max=4,defaut=('EPXX','EPYY','EPZZ','EPXY',) ),),
           b_tens_3d       =BLOC(condition = "TYPE_CHAM=='TENS_3D'",
              NOM_CMP         =SIMP(statut='f',typ='TXM',min=6,max=6,defaut=('EPXX','EPYY','EPZZ','EPXY','EPXZ','EPYZ',),),),

           REPERE          =SIMP(statut='o',typ='TXM',
                                 into=("UTILISATEUR","CYLINDRIQUE","NORMALE","DIR_JAUGE"),),
           b_normale       =BLOC(condition = "REPERE=='NORMALE'",
             regles=(UN_PARMI('VECT_X','VECT_Y')),
             VECT_X          =SIMP(statut='f',typ='R',min=3,max=3),
             VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3), ),
           b_utilisateur   =BLOC(condition = "REPERE=='UTILISATEUR'",
             ANGL_NAUT       =SIMP(statut='o',typ='R',max=3)),
           b_cylindrique   =BLOC(condition = "REPERE=='CYLINDRIQUE'",
             ORIGINE         =SIMP(statut='o',typ='R',min=2,max=3),
             AXE_Z           =SIMP(statut='o',typ='R',min=3,max=3)),
           b_dir_jauge       =BLOC(condition = "REPERE=='DIR_JAUGE'",
             VECT_X          =SIMP(statut='f',typ='R',min=3,max=3),
             VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3), ),
         ),

#        ------------------------------------------------------------------
#        EPSI_MOYENNE
#        ------------------------------------------------------------------
         EPSI_MOYENNE     =FACT(statut='f',max='**',
                       regles=(AU_MOINS_UN('GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           NOEUD       = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO     = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SEUIL_VARI      =SIMP(statut='f',typ='R',validators=NoRepeat(),defaut=0.1,),
           MASQUE          =SIMP(statut='f',typ='TXM',max=6),
         ),

#        ------------------------------------------------------------------
#        FILTRE DES DDL
#        ------------------------------------------------------------------
         FILTRE     =FACT(statut='f',max='**',
           regles=(UN_PARMI('DDL_ACTIF'),
#                           'MASQUE'),
           AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),),

#
           DDL_ACTIF       =SIMP(statut='f',typ='TXM',max=6),
# TODO : mettre en place le systeme de masques
#           MASQUE          =SIMP(statut='f',typ='TXM',max=6),
         ),
#        ------------------------------------------------------------------

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
      )  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: romeo.fernandes at edf.fr

PERM_MAC3COEUR = MACRO(nom="PERM_MAC3COEUR",
                       op=OPS("Mac3coeur.perm_mac3coeur_ops.perm_mac3coeur_ops"),
                       sd_prod=evol_noli,

         TYPE_COEUR   = SIMP(statut='o',typ='TXM',into=("MONO","TEST","900","1300","N4","EPR") ),
         TABLE_N      = SIMP(statut='o',typ=table_sdaster),         # TABLE INITIALE DES DAMAC A L INSTANT N
         RESU_N       = SIMP(statut='o',typ=evol_noli),             # RESULTAT A L INSTANT N A PERMUTER
         TABLE_NP1    = SIMP(statut='o',typ=table_sdaster),         # TABLE INITIALE DES DAMAC A L INSTANT N+1
         MAILLAGE_NP1 = SIMP(statut='o',typ=maillage_sdaster),);    # MAILLAGE A L INSTANT N+1

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: renaud.bargellini at edf.fr

POST_BORDET =MACRO(nom="POST_BORDET",
                   op=OPS('Macro.post_bordet_ops.post_bordet_ops'),
                   sd_prod=table_sdaster,
                   UIinfo={"groupes":("Outils-métier","Rupture",)},
                   reentrant='n',
                   fr="calcul de la probabilite de clivage via le modele de Bordet",
         regles=(UN_PARMI('TOUT','GROUP_MA'),
                 UN_PARMI('INST','NUME_ORDRE'),
                 ),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                           fr="le calcul ne sera effectué que sur ces mailles"),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),),
         PRECISION =SIMP(statut='f',typ='R',validators=NoRepeat(),val_min=0.,val_max=1E-3,defaut=1E-6),
         CRITERE   =SIMP(statut='f',typ='TXM',defaut="ABSOLU",into=("RELATIF","ABSOLU") ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),),
         PROBA_NUCL      =SIMP(statut='f',typ='TXM',into=("NON","OUI"), defaut="NON",
                      fr="prise en compte du facteur exponentiel"),
         b_nucl          =BLOC( condition = "PROBA_NUCL=='OUI'",
                          PARAM =FACT(statut='o',
                                 M                =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SIGM_REFE         =SIMP(statut='o',typ=(fonction_sdaster),val_min=0.E+0),
                                 VOLU_REFE        =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SIG_CRIT         =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SEUIL_REFE       =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SEUIL_CALC       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster)),
                                 DEF_PLAS_REFE    =SIMP(statut='o',typ='R'),),),

         b_prop          =BLOC( condition = "PROBA_NUCL=='NON'",
                          PARAM =FACT(statut='o',
                                 M                =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SIGM_REFE         =SIMP(statut='o',typ=fonction_sdaster,val_min=0.E+0),
                                 VOLU_REFE        =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SIG_CRIT         =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SEUIL_REFE       =SIMP(statut='o',typ='R',val_min=0.E+0),
                                 SEUIL_CALC       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),),
                                 ),
                                 ),

         RESULTAT        =SIMP(statut='o',typ=resultat_sdaster,
                                      fr="Resultat d'une commande globale STAT_NON_LINE"),
         TEMP            =SIMP(statut='o',typ=(fonction_sdaster,'R')),
         COEF_MULT       =SIMP(statut='f',typ='R', defaut=1.),
           )

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr
def post_cham_xfem_prod(RESULTAT,**args ):
 
  if AsType(RESULTAT) == evol_noli  : return evol_noli
  if AsType(RESULTAT) == mode_meca  : return mode_meca
  if AsType(RESULTAT) == evol_elas  : return evol_elas
  if AsType(RESULTAT) == evol_ther  : return evol_ther

  raise AsException("type de concept resultat non prevu")

POST_CHAM_XFEM=OPER(nom="POST_CHAM_XFEM",op= 196,sd_prod=post_cham_xfem_prod,
                    reentrant='n',UIinfo={"groupes":("Post-traitements","Rupture",)},
            fr="Calcul des champs DEPL, SIEF_ELGA et VARI_ELGA sur le maillage de visualisation (fissuré)",
    RESULTAT      = SIMP(statut='o',typ=resultat_sdaster),
    MODELE_VISU   = SIMP(statut='o',typ=modele_sdaster,),
    INFO          = SIMP(statut='f',typ='I',defaut= 1,into=(1,2,) ),
);                     

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

def post_champ_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu")


# liste des options possibles pour les 4 mots clés EXTR_COQUE, EXTR_TUYAY, EXTR_PMF et MIN_MAX_SP :
liste_option_extr=("EPEQ_ELGA","EPEQ_ELNO","EPSI_ELGA","EPSI_ELNO",
                   "SIEF_ELGA","SIEF_ELNO",
                   "SIEQ_ELGA","SIEQ_ELNO","SIGM_ELGA","SIGM_ELNO",
                   "VARI_ELGA","VARI_ELNO",)


POST_CHAMP=OPER(nom="POST_CHAMP",op=155,sd_prod=post_champ_prod, reentrant='n',
            UIinfo={"groupes":("Post-traitements","Eléments de structure",)},
                 fr="extraction de champs sur un sous-point. ",

         regles=(UN_PARMI('EXTR_COQUE','EXTR_TUYAU','EXTR_PMF','MIN_MAX_SP','COQU_EXCENT'),
                 EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP',
                        'LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS',),
                 ),

         RESULTAT        =SIMP(statut='o',typ=resultat_sdaster,
                               fr="Resultat d'une commande globale"),


#====
# Sélection des numéros d'ordre pour lesquels on fait le calcul :
#====
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

         b_acce_reel     =BLOC(condition="(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
            CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
            b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
            b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),


#====
# Sélection de la zone géométrique:
#====
         TOUT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE     =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),



#====
# Extraction sur un sous-point d'une coque :
#====
         EXTR_COQUE  =FACT(statut='f', max=1, fr="extraction sur un sous-point d'une coque",
           NOM_CHAM     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                              into=liste_option_extr,),
           NUME_COUCHE  =SIMP(statut='o',typ='I',val_min=1,
                             fr="numero de couche dans l'épaisseur de la coque" ),
           NIVE_COUCHE  =SIMP(statut='o',typ='TXM',into=("SUP","INF","MOY"),
                             fr="position dans l'épaisseur de la couche" ),
           ),


#====
# Extraction sur un sous-point d'un tuyau :
#====
         EXTR_TUYAU  =FACT(statut='f', max=1, fr="extraction sur un sous-point d'un tuyau",
           NOM_CHAM     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                              into=liste_option_extr ,),
           NUME_COUCHE  =SIMP(statut='o',typ='I',val_min=1,
                             fr="numero de couche dans l'épaisseur du tuyau" ),
           NIVE_COUCHE  =SIMP(statut='o',typ='TXM',into=("SUP","INF","MOY"),
                             fr="position dans l'épaisseur de la couche" ),
           ANGLE        =SIMP(statut='o',typ='I',val_min=0,val_max=360,
                             fr="angle de dépouillement pour les tuyaux, en degrés à partir de la génératrice" ),
           ),


#====
# Extraction sur un sous-point d'une poutre multifibre :
#====
         EXTR_PMF  =FACT(statut='f', max=1, fr="extraction sur un sous-point d'une poutre multifibre",
           NOM_CHAM     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                              into=liste_option_extr,),
           NUME_FIBRE  =SIMP(statut='o',typ='I',val_min=1,
                             fr="numéro de la fibre dans la poutre multifibre" ),
           ),


#====
# Extraction des min / max sur les sous-points :
#====
         MIN_MAX_SP  =FACT(statut='f', max='**', fr="extraction du min/max d'une composante pour un champ",
           NOM_CHAM     =SIMP(statut='o',typ='TXM',
                              into=liste_option_extr,),
           NOM_CMP        =SIMP(statut='o',typ='TXM',fr="nom de la composante",  ),
           TYPE_MAXI      =SIMP(statut='o',typ='TXM',into=("MAXI","MINI","MAXI_ABS","MINI_ABS",) ),
           NUME_CHAM_RESU = SIMP(statut='o', typ='I', val_min=1, val_max=20,
                          fr="Numéro du champ produit. Exemple: 6 produit le champ UT06",),
           ),


#====
# Calcul des efforts des coques "excentrées" sur le feuillet moyen de la coque :
#====
         COQU_EXCENT  =FACT(statut='f', max=2, fr="Calcul des efforts d'une coque 'excentrée' sur le feuillet moyen de la coque",
           NOM_CHAM     =SIMP(statut='o',typ='TXM',into=("EFGE_ELNO","EFGE_ELGA",),),
           MODI_PLAN    =SIMP(statut='o',typ='TXM',into=("OUI",),),
           ),
      )

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr

POST_COQUE=MACRO(nom="POST_COQUE",
                 op=OPS('Macro.post_coque_ops.post_coque_ops'),
                 sd_prod=table_sdaster,
                 reentrant='n',
                 UIinfo={"groupes":("Post-traitements",)},
                 fr="Calcul des efforts et déformations en un point et une cote " \
                    "quelconque de la coque",

             regles=(EXCLUS('INST','NUME_ORDRE'),),

             # SD résultat et champ à posttraiter :
             RESULTAT        =SIMP(statut='o',typ=resultat_sdaster,fr="RESULTAT à posttraiter",),
             CHAM            =SIMP(statut='o',typ='TXM',into=("EFFORT","DEFORMATION",)),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),

             # points de post-traitement :
             COOR_POINT      =FACT(statut='o',max='**',fr="coordonnées et position dans l'épaisseur",
                                   COOR=SIMP(statut='o',typ='R',min=3,max=4),),

            )

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr


POST_DECOLLEMENT=MACRO(nom="POST_DECOLLEMENT",
                       op=OPS('Macro.post_decollement_ops.post_decollement_ops'),
                       sd_prod=table_sdaster,
                       fr="calcul du rapport de surfaces de contact radier/sol",
                       reentrant='n',
                       UIinfo={"groupes":("Post-traitements",)},
         RESULTAT   =SIMP(statut='o',typ=(evol_noli) ),
         NOM_CHAM   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),defaut='DEPL',into=C_NOM_CHAM_INTO(),max=1),
         NOM_CMP    =SIMP(statut='f',typ='TXM',defaut='DZ',max=1),
         GROUP_MA   =SIMP(statut='o',typ=grma,max=1),
         INFO       =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
POST_DYNA_ALEA=MACRO(nom="POST_DYNA_ALEA",
                     op=OPS('Macro.post_dyna_alea_ops.post_dyna_alea_ops'),
                     sd_prod=table_sdaster,
                     fr="Traitements statistiques de résultats de type interspectre " \
                        "et impression sur fichiers",
                     reentrant='n',
                     UIinfo={"groupes":("Post-traitements","Dynamique",)},
         regles=(UN_PARMI('FRAGILITE','INTERSPECTRE'),),
         FRAGILITE  =FACT(statut='f',fr="donnees pour courbe de fragilite",max=1,
                    TABL_RESU  =SIMP(statut='o',typ=table_sdaster),
                    regles=(UN_PARMI('VALE','LIST_PARA'),),
                    VALE       = SIMP(statut='f',typ='R', min=1,validators=NoRepeat(),max='**' ),
                    LIST_PARA  = SIMP(statut='f',typ=listr8_sdaster),
                    AM_INI     = SIMP(statut='f',typ='R',defaut= 0.4 ),
                    BETA_INI   = SIMP(statut='f',typ='R',defaut= 0.3 ),
                    FRACTILE   = SIMP(statut='f',typ='R', min=1,validators=NoRepeat(),max='**'),
                    b_inte_spec_f  = BLOC(condition="""FRACTILE !=None""",
                        NB_TIRAGE =SIMP(statut='f',typ='I' ),),
                 ),
         INTERSPECTRE  =FACT(statut='f',fr="donnees pour interspectre",max=1,
                  regles=(UN_PARMI('NOEUD_I','NUME_ORDRE_I','OPTION'),),
                   INTE_SPEC       =SIMP(statut='o',typ=interspectre),
                   NUME_ORDRE_I    =SIMP(statut='f',typ='I',max='**' ),
                   NOEUD_I         =SIMP(statut='f',typ=no,max='**'),
                   OPTION          =SIMP(statut='f',typ='TXM',into=("DIAG","TOUT",) ),
                   b_nume_ordre_i =BLOC(condition = "NUME_ORDRE_I != None",
                       NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**' ),
                                ),
                   b_noeud_i      =BLOC(condition = "NOEUD_I != None",
                       NOEUD_J         =SIMP(statut='o',typ=no,max='**'),
                       NOM_CMP_I       =SIMP(statut='o',typ='TXM',max='**' ),
                       NOM_CMP_J       =SIMP(statut='o',typ='TXM',max='**' ),
                                ),
                   MOMENT          =SIMP(statut='f',typ='I',max='**',fr="Moments spectraux "\
                                                         "en complément des cinq premiers" ),
                   DUREE           =SIMP(statut='f',typ='R',fr="durée de la phase forte "\
                                                              "pour facteur de peak" ),
                ),       
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
POST_DYNA_MODA_T=OPER(nom="POST_DYNA_MODA_T",op= 130,sd_prod=table_sdaster,
                      fr="Post-traiter les résultats en coordonnées généralisées produit par DYNA_TRAN_MODAL",
                      reentrant='n',
            UIinfo={"groupes":("Post-traitements","Dynamique",)},
        regles=(UN_PARMI('CHOC','RELA_EFFO_DEPL', ),),
         RESU_GENE       =SIMP(statut='o',typ=tran_gene ),
         CHOC            =FACT(statut='f',max='**',
                               fr="Analyse des non linéarités de choc",
           INST_INIT       =SIMP(statut='f',typ='R',defaut= -1. ),  
           INST_FIN        =SIMP(statut='f',typ='R',defaut= 999. ),  
           NB_BLOC         =SIMP(statut='f',typ='I',defaut= 1 ),  
           SEUIL_FORCE     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
           DUREE_REPOS     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
           OPTION          =SIMP(statut='f',typ='TXM',defaut="USURE",into=("IMPACT","USURE") ),
           NB_CLASSE       =SIMP(statut='f',typ='I',defaut= 10 ),  
         ),
         RELA_EFFO_DEPL  =FACT(statut='f',
                               fr="Analyse des relationsnon linéaires effort-déplacement",
           NOEUD           =SIMP(statut='o',typ=no),
           NOM_CMP         =SIMP(statut='o',typ='TXM' ),  
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: josselin.delmas at edf.fr

POST_ELEM=OPER(nom="POST_ELEM",op=107,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post-traitements","Résultats et champs",)},
               fr="Calcul de quantités globales (masse, inerties, énergie, ...) sur tout ou partie du modèle",

         regles=(UN_PARMI('MASS_INER', 'ENER_POT', 'ENER_CIN','TRAV_EXT','MINMAX',
                          'WEIBULL', 'RICE_TRACEY', 'CARA_GEOM','CHAR_LIMITE','NORME',
                          'CARA_POUTRE', 'INDIC_ENER', 'INDIC_SEUIL','VOLUMOGRAMME',
                          'AIRE_INTERNE','ENER_ELAS','ENER_TOTALE','ENER_DISS','INTEGRALE'),
                ),

         MASS_INER      = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               ORIG_INER    = SIMP(statut='f',typ='R',min=3,max=3 ),
                              ),
         b_mass_iner = BLOC(condition = "( MASS_INER != None )",
                       fr="calcul de la masse, les inerties et le centre de gravité",
                       regles=(EXCLUS('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                                        char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       GEOMETRIE      = SIMP(statut='f',typ='TXM',defaut="INITIALE",into=("INITIALE","DEFORMEE")),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_noli,mult_elas,
                                                             fourier_elas,dyna_trans) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I',),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',min=2,validators=NoRepeat(),max=2),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',),
         ),

         ENER_POT       = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_pot = BLOC(condition = "( ENER_POT  != None )",
                       fr="calcul de l'énergie potentielle de déformation",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       ANGLE          = SIMP(statut='f',typ='I',defaut=0),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_ther,evol_noli,dyna_trans,mult_elas) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**'),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         ),

         ENER_CIN       = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               OPTION       = SIMP(statut='f',typ='TXM',validators=NoRepeat(),
                                                   into=("MASS_MECA","MASS_MECA_DIAG"),
                                                   defaut="MASS_MECA" ),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_cin = BLOC(condition = "( ENER_CIN != None )",
                       fr="calcul de l'énergie cinétique",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       ANGLE          = SIMP(statut='f',typ='I',defaut=0),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_ther,evol_noli,dyna_trans) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         ),

         ENER_DISS      = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_diss = BLOC(condition = "( ENER_DISS != None )",
                       fr="calcul de l'énergie dissipée",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),


         ENER_ELAS      = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_elas = BLOC(condition = "( ENER_ELAS != None )",
                       fr="calcul de l'énergie de déformation élastique",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli,evol_elas) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         ENER_TOTALE    = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_totale = BLOC(condition = "( ENER_TOTALE != None )",
                       fr="calcul de l'énergie de déformation totale",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INTEGRALE  = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               NOM_CHAM     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
                               NOM_CMP      = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
                               DEJA_INTEGRE = SIMP(statut='f',typ='TXM',into=("OUI","NON",),),
                              ),
         b_integrale = BLOC(condition = "( INTEGRALE != None )",
                       fr="calcul de la moyenne d'une composante",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_ORDRE','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli,evol_ther,evol_elas,evol_char) ),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         VOLUMOGRAMME  = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA'),
                                       UN_PARMI('NB_INTERV','SEUIL'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               GROUP_MA     = SIMP(statut='f',typ=grma,max=1),
                               TYPE_MAILLE  = SIMP(statut='f',typ='TXM',into=('2D','3D',)),
                               NOM_CHAM     = SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
                               NOM_CMP      = SIMP(statut='o',typ='TXM'),
                               NB_INTERV    = SIMP(statut='f',typ='I'),
                               SEUIL        = SIMP(statut='f',typ='R'),
                               BORNES       = SIMP(statut='f',typ='R',validators=NoRepeat(),min=2,max=2),
                               NORME        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                              ),
         b_volumogramme = BLOC(condition = "( VOLUMOGRAMME != None )",
                       fr="calcul de la distribution du volume d'une structure vis-à-vis d'une composante",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_ORDRE','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli,evol_ther,evol_elas,evol_char) ),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         NORME  = FACT(statut='f',max=1,
                       fr="calcul des extrema en espace d'une CMP d'un champ, pour tous les instants spécifiés",
                       regles=(UN_PARMI('TOUT','GROUP_MA'),
                               UN_PARMI('CHAM_GD','RESULTAT'),
                               PRESENT_PRESENT('CHAM_GD','MODELE'),
                               PRESENT_PRESENT('RESULTAT','NOM_CHAM'),),
                       TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                       TYPE_MAILLE  = SIMP(statut='f',typ='TXM',into=('2D','3D',)),
                       TYPE_NORM    = SIMP(statut='f',typ='TXM',into=('L2','FROBENIUS')),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli,evol_ther,evol_elas) ),
                       NOM_CHAM       = SIMP(statut='f',typ='TXM',validators=NoRepeat(),
                                             into=("DEPL","TEMP","NEUT_R",
                                                   "FLUX_ELGA","FLUX_ELNO","FLUX_NOEU",
                                                   "EPSI_ELGA","EPSI_ELNO","EPSI_NOEU",
                                                   "SIEF_ELGA","SIEF_ELNO","SIEF_NOEU")),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),

                       b_norme_GD = BLOC(condition = "( CHAM_GD != None )",
                              COEF_MULT      = SIMP(statut='f',typ='R',max=30),
                              ),

                       b_norme = BLOC(condition = "( RESULTAT != None )",
                               regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                                  PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                                  PRECISION       =SIMP(statut='o',typ='R',),),
                              TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                              NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                              LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                              INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                              LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                              ),
                       ),


         MINMAX  = FACT(statut='f',max=1,
                       fr="calcul des extrema en espace d'une CMP d'un champ, pour tous les instants spécifiés",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               PRESENT_PRESENT('CHAM_GD','MODELE'),
                               PRESENT_PRESENT('RESULTAT','NOM_CHAM'),
                               UN_PARMI('TOUT','GROUP_MA'),),
                       TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli,evol_ther,evol_elas) ),
                       NOM_CHAM       = SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       NOM_CMP        = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
              b_minmax = BLOC(condition = "( RESULTAT != None )",
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                                  PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                                  PRECISION       =SIMP(statut='o',typ='R',),),
                              TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                              NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                              LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                              INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                              LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                              ),
         ),

         WEIBULL        = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               OPTION       = SIMP(statut='f',typ='TXM',validators=NoRepeat(),
                                                   into=("SIGM_ELGA","SIGM_ELMOY"),
                                                   defaut="SIGM_ELGA"),
                               CORR_PLAST   = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                               COEF_MULT    = SIMP(statut='f',typ='R',defaut=1.),
                              ),
         b_weibull = BLOC(condition = "( WEIBULL != None )",
                       fr="calcul du champ élémentaire de la puissance m-ième de la contrainte de Weibull",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         RICE_TRACEY    = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               OPTION       = SIMP(statut='f',typ='TXM',validators=NoRepeat(),
                                                   into=("SIGM_ELGA","SIGM_ELMOY"),
                                                   defaut="SIGM_ELGA"),
                               LOCAL        = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                              ),
         b_rice_tracey = BLOC(condition = "( RICE_TRACEY != None )",
                       fr="calcul du taux de croissance d'une cavité sphérique par rapport à un domaine",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INDIC_ENER     = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_indic_ener = BLOC(condition = "( INDIC_ENER != None )",
                       fr="calcul un indicateur global de perte de proportionnalité du chargement",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                           PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INDIC_SEUIL    = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_indic_seuil = BLOC(condition = "( INDIC_SEUIL != None )",
                       fr="calcul un indicateur global de perte de proportionnalité du chargement",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         CHAR_LIMITE    = FACT(statut='f',min=0,
                               CHAR_CSTE = SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON")
                              ),
         b_char_limite = BLOC(condition = "( CHAR_LIMITE != None )",
                       fr="post-traitement du calcul de la charge limite",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                          PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                          PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         CARA_GEOM      = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               SYME_X       = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                               SYME_Y       = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                               ORIG_INER    = SIMP(statut='f',typ='R',min=2,max=2),
                              ),
         b_cara_geom = BLOC(condition = "( CARA_GEOM != None )",
                       fr="calcul des caractéristiques géométriques d'un section de poutre",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
         ),

         CARA_POUTRE    = FACT(statut='f',max='**',
                               regles=(UN_PARMI('TOUT','GROUP_MA'),
                                       ENSEMBLE('LONGUEUR','LIAISON','MATERIAU'),),
                               TOUT          = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               GROUP_MA      = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_MA_INTE = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               CARA_GEOM     = SIMP(statut='o',typ=table_sdaster),
                               RT            = SIMP(statut='f',typ='R'),
                               LAPL_PHI      = SIMP(statut='f',typ=evol_ther),
                               LAPL_PHI_Y    = SIMP(statut='f',typ=evol_ther),
                               LAPL_PHI_Z    = SIMP(statut='f',typ=evol_ther),
                               LIAISON       = SIMP(statut='f',typ='TXM',into=("ROTULE","ENCASTREMENT")),
                               LONGUEUR      = SIMP(statut='f',typ='R'),
                               MATERIAU      = SIMP(statut='f',typ=mater_sdaster),
                               OPTION        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),
                                                    into=("CARA_TORSION","CARA_CISAILLEMENT","CARA_GAUCHI") ),
                             ),
         b_cara_poutre = BLOC(condition = "( CARA_POUTRE != None )",
                       fr="calcul des caractéristiques mécaniques d'un section de poutre",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_cine_meca,
                       char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
         ),

          AIRE_INTERNE   = FACT(statut='f',max='**',
                                GROUP_MA_BORD  = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
                               ),
         b_aire_interne = BLOC(condition = "( AIRE_INTERNE != None )",
                       fr="calcul de l'aire d'un trou dans un maillage 2D",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
         ),

         TRAV_EXT       = FACT(statut='f',),
         b_trav_ext = BLOC(condition = "( TRAV_EXT != None )",
                       fr="calcul du travail des efforts extérieurs",
                       RESULTAT       = SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans) ),
                       CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
                       b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
                       b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                           PRECISION       =SIMP(statut='o',typ='R',),),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),

 )  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: marina.bottoni at edf.fr

# ---------------------------------------------------------------------------
#                  POST_ENDO_FISS
# RECHERCHE DU TRAJET DE FISSURATION SUR UN
#  CHAMP SCALAIRE 2D


def post_endo_fiss_prod(self,TABLE,**args) :
    self.type_sdprod(TABLE,table_sdaster)
    return maillage_sdaster

POST_ENDO_FISS=MACRO(nom="POST_ENDO_FISS",
                     op=OPS('Macro.post_endo_fiss_ops.post_endo_fiss_ops'),
                     sd_prod=post_endo_fiss_prod,
                     reentrant='n',
                     UIinfo={"groupes":("Post-traitements","Outils-métier",)},
                     fr="Individuation du trace d'une fissure a partir d'un champ scalaire pertinant",

            TABLE  = SIMP(statut = 'o', typ = CO,),

            regles = (UN_PARMI("RESULTAT","CHAM_GD"),
                      ),
            OUVERTURE  = SIMP(statut = 'f', typ = 'TXM', into=('OUI','NON',), defaut = 'NON' ),
            b_resultat = BLOC(condition  = "RESULTAT != None",
                              regles     = (UN_PARMI('NUME_ORDRE','INST'),),
                              NUME_ORDRE = SIMP(statut = 'f', typ = 'I', validators = NoRepeat(), ),
                              INST       = SIMP(statut = 'f', typ = 'R', validators = NoRepeat(), ),
                              ),

            #b_champ    = BLOC(condition = "CHAM_GD != None",),

            CHAM_GD         = SIMP(statut = 'f',typ = (cham_gd_sdaster)),
            RESULTAT        = SIMP(statut = 'f',typ = (evol_noli)),
            NOM_CMP         = SIMP(statut = 'o',typ='TXM',),
            NOM_CHAM        = SIMP(statut = 'o', typ = 'TXM',
                                   fr = "nom du champ a post-traiter",),

            RECHERCHE = FACT(statut = 'o',min=1,max='**',
                             regles = (
                                       PRESENT_ABSENT('TOUT','GROUP_MA',),
                                    ),
                              LONG_ORTH  = SIMP(statut='o', typ='R'),
                              NB_POINT   = SIMP(statut='f', typ='I', defaut = 500),
                              PAS        = SIMP(statut='o', typ='R', ),
                              LONG_REG   = SIMP(statut='o', typ='R'),
                              BORNE_MIN  = SIMP(statut='f', typ='R', defaut=0.5),
                              ANGL_MAX   = SIMP(statut='f', typ='R', defaut=120.),
                              TOUT       = SIMP(statut='f', typ='TXM', into=('OUI',) ),
                              GROUP_MA   = SIMP(statut='f', typ=grma,  validators=NoRepeat(), ),
                              BORNE_MAX  = SIMP(statut='f', typ='R'),
                              ),
                   )

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
POST_FATI_ALEA=OPER(nom="POST_FATI_ALEA",op=170,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post-traitements","Rupture",)},
                    fr="Calculer le dommage de fatigue subi par une structure soumise à une sollicitation de type aléatoire",
         regles=(ENSEMBLE('MOMENT_SPEC_0','MOMENT_SPEC_2'),
                 PRESENT_PRESENT( 'MOMENT_SPEC_4','MOMENT_SPEC_0'),
                 UN_PARMI('TABL_POST_ALEA','MOMENT_SPEC_0'), ),
         MOMENT_SPEC_0   =SIMP(statut='f',typ='R'),  
         MOMENT_SPEC_2   =SIMP(statut='f',typ='R'),  
         MOMENT_SPEC_4   =SIMP(statut='f',typ='R'),  
         TABL_POST_ALEA  =SIMP(statut='f',typ=table_sdaster),
         COMPTAGE        =SIMP(statut='o',typ='TXM',into=("PIC","NIVEAU")),
         DUREE           =SIMP(statut='f',typ='R',defaut= 1.),  
         CORR_KE         =SIMP(statut='f',typ='TXM',into=("RCCM",)),
         DOMMAGE         =SIMP(statut='o',typ='TXM',into=("WOHLER",)),
         MATER           =SIMP(statut='o',typ=mater_sdaster),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: van-xuan.tran at edf.fr
POST_FATIGUE=OPER(nom="POST_FATIGUE",op=136,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post-traitements","Rupture",)},
                  fr="Calculer en un point, le dommage de fatigue subi par une structure soumise à une histoire de chargement",

         CHARGEMENT = SIMP(statut='o',typ='TXM',into=("UNIAXIAL","MULTIAXIAL","QUELCONQUE")),

         b_uniaxial = BLOC( condition = "CHARGEMENT=='UNIAXIAL'",
                      regles=(PRESENT_PRESENT('CORR_KE','MATER'),
                              PRESENT_PRESENT('CORR_SIGM_MOYE','MATER'),
                              PRESENT_PRESENT('DOMMAGE','MATER'),),
             HISTOIRE       = FACT(statut='o',
                                 regles=(UN_PARMI('SIGM','EPSI'),),
                                 SIGM  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSI  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),),
             COMPTAGE       = SIMP(statut='o',typ='TXM',into=("RAINFLOW","RAINFLOW_MAX","RCCM","NATUREL")),
             DELTA_OSCI     = SIMP(statut='f',typ='R',defaut= 0.0E+0),
             COEF_MULT      = FACT(statut='f',
                                 KT    = SIMP(statut='o',typ='R'),),
             CORR_KE        = SIMP(statut='f',typ='TXM',into=("RCCM",)),
             DOMMAGE        = SIMP(statut='f',typ='TXM',into=("WOHLER","MANSOP_COFFIN",
                                                              "TAHERI_MANSON","TAHERI_MIXTE")),
             MATER          = SIMP(statut='f',typ=mater_sdaster),
             CORR_SIGM_MOYE = SIMP(statut='f',typ='TXM',into=("GOODMAN","GERBER")),
             TAHERI_NAPPE   = SIMP(statut='f',typ=(nappe_sdaster,formule)),
             TAHERI_FONC    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CUMUL          = SIMP(statut='f',typ='TXM',into=("LINEAIRE",)),
         ),

         b_multiaxial = BLOC( condition = "CHARGEMENT=='MULTIAXIAL'",
             HISTOIRE       = FACT(statut='o',
                                 regles=(PRESENT_PRESENT('SIGM_XX','SIGM_YY','SIGM_ZZ','SIGM_XY','SIGM_XZ','SIGM_YZ'),
                                         PRESENT_PRESENT('EPS_XX','EPS_YY','EPS_ZZ','EPS_XY','EPS_XZ','EPS_YZ'),
                                         PRESENT_PRESENT('EPSP_XX','EPSP_YY','EPSP_ZZ','EPSP_XY','EPSP_XZ','EPSP_YZ'),
                                         AU_MOINS_UN('SIGM_XX','SIGM_YY','SIGM_ZZ','SIGM_XY','SIGM_XZ','SIGM_YZ',
                                                     'EPS_XX','EPS_YY','EPS_ZZ','EPS_XY','EPS_XZ','EPS_YZ',
                                                     'EPSP_XX','EPSP_YY','EPSP_ZZ','EPSP_XY','EPSP_XZ','EPSP_YZ'), 
                                                   ),
                                 SIGM_XX  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_ZZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 
                                 EPS_XX  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPS_YY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPS_ZZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPS_XY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPS_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPS_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 
                                 EPSP_XX  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP_YY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP_ZZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP_XY  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                               ),
                               
             TYPE_CHARGE    = SIMP(statut='o',typ='TXM',into=("PERIODIQUE","NON_PERIODIQUE")),                            
             DOMMAGE         = SIMP(statut='f',typ='TXM',into=("WOHLER","MANSON_C","FORM_VIE") ), 
             
             b_fati_pfvie  = BLOC(condition = "(DOMMAGE == 'FORM_VIE')",
                                    FORMULE_VIE   =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                                 ),
                                 
             MATER          = SIMP(statut='f',typ=mater_sdaster),
             COEF_CORR      = SIMP(statut='f',typ='R'),
             COEF_PREECROU =SIMP(statut='f',typ='R',defaut= 1.0E+0),

         
             b_period       =BLOC(condition = "TYPE_CHARGE == 'PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',into=("MATAKE_MODI_AC","DANG_VAN_MODI_AC","CROSSLAND",
                                                               "PAPADOPOULOS","FORMULE_CRITERE") ),
 
               METHODE       =SIMP(statut='f',typ='TXM',into=("CERCLE_EXACT",) ),                
               b_fati_pf  =BLOC(condition = "(CRITERE == 'FORMULE_CRITERE')",
                   FORMULE_GRDEQ   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                   FORMULE_CRITIQUE = SIMP(statut='f',typ=(fonction_sdaster,formule) ),  
               ),
             ),
           
            b_non_period   =BLOC(condition = "TYPE_CHARGE == 'NON_PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',
                                   into=("MATAKE_MODI_AV","DANG_VAN_MODI_AV","FATESOCI_MODI_AV","FORMULE_CRITERE") ),
               PROJECTION    =SIMP(statut='o',typ='TXM',into=("UN_AXE", "DEUX_AXES") ),
               DELTA_OSCI    =SIMP(statut='f',typ='R',defaut= 0.0E+0),
                   
               b_fati_npf  =BLOC(condition = "(CRITERE == 'FORMULE_CRITERE')",
                   FORMULE_GRDEQ   =SIMP(statut='o',typ=(fonction_sdaster,formule) ),
               ),
            ),

         ),

         b_quelconque = BLOC( condition = "CHARGEMENT=='QUELCONQUE'",
             HISTOIRE       = FACT(statut='o',
                                 SIGM_XX  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_ZZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 TEMP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),),
             DOMMAGE        = SIMP(statut='f',typ='TXM',into=("LEMAITRE",),),
             MATER          = SIMP(statut='o',typ=mater_sdaster),
             CUMUL          = SIMP(statut='f',typ='TXM',into=("LINEAIRE",)),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

POST_K1_K2_K3=MACRO(nom="POST_K1_K2_K3",
                    op=OPS('Macro.post_k1_k2_k3_ops.post_k1_k2_k3_ops'),
                    sd_prod=table_sdaster,
                    fr="Calcul des facteurs d'intensité de contraintes en 2D et en 3D par "\
                       "extrapolation des sauts de déplacements sur les lèvres de la fissure",
                    reentrant='n',
                    UIinfo={"groupes":("Post-traitements","Rupture",)},

           regles=(UN_PARMI('FISSURE','FOND_FISS'),),

         MODELISATION  =SIMP(statut='o',typ='TXM',
                             into=("3D","AXIS","D_PLAN","C_PLAN"),position='global',
                             fr="Modélisation cohérente avec celle utilisée pour le calcul des déplacements"),
         FOND_FISS     =SIMP(statut='f',typ=fond_fiss),
         FISSURE       =SIMP(statut='f',typ=fiss_xfem),
         RESULTAT      =SIMP(statut='o',typ=(evol_elas,evol_noli,mode_meca),position='global',
                             fr="Déplacement des noeuds de la lèvre supérieure et inférieure"),
         NB_NOEUD_COUPE=SIMP(statut='f',typ='I',defaut=5,val_min = 3),

#        bloc correspondant a la donnee du fond de fissure pour les fissures maillees
         b_fond_fiss   =BLOC (condition="FOND_FISS!= None",

              b_no_mod =BLOC (condition="AsType(RESULTAT)!= mode_meca",
                        
                        EVOL_THER   = SIMP(statut='f',typ=(evol_ther),fr="Température sur le fond de fissure"),
                        b_ref_3D    = BLOC (condition="MODELISATION=='3D' ",
                                  TYPE_MAILLAGE = SIMP(statut='f',typ='TXM',into=("LIBRE","REGLE"),defaut="REGLE"),
                                  ),  
                             ),
              b_mod    =BLOC (condition="AsType(RESULTAT)== mode_meca and MODELISATION=='3D'",
                                  TYPE_MAILLAGE = SIMP(statut='f',typ='TXM',into=("REGLE",),defaut="REGLE"),
                             ),

                         NOEUD         = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                         GROUP_NO      = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                         SANS_NOEUD    = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                         SANS_GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                         TOUT          = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                         ABSC_CURV_MAXI=SIMP(statut='f',typ='R',
                             fr="Distance maximum à partir du fond de fissure à utiliser pour le calcul"),
                         ),

#        bloc correspondant a la donnee de la fissure pour les fissures X-FEM
         b_fissure     =BLOC (condition="FISSURE!= None",
                         NB_POINT_FOND = SIMP(statut='f',typ='I' ,),
                         NUME_FOND     = SIMP(statut='f',typ='I',defaut=1),
                         ABSC_CURV_MAXI=SIMP(statut='f',typ='R',
                             fr="Distance maximum à partir du fond de fissure à utiliser pour le calcul"),
                         ),

         MATER         =SIMP(statut='o',typ=mater_sdaster,
                             fr="Matériau homogène et isotrope cohérent avec celui utilisé pour le calcul des déplacements"),

         
         PREC_VIS_A_VIS=SIMP(statut='f',typ='R',defaut=0.1),

         b_mod_meca  =BLOC (condition="AsType(RESULTAT)== mode_meca ",      
         TOUT_ORDRE    =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE    =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE    =SIMP(statut='f',typ=listis_sdaster),
         TOUT_MODE       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_MODE       =SIMP(statut='f',typ=listis_sdaster),
         FREQ          =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ     =SIMP(statut='f',typ=listr8_sdaster),
             b_acce_reel     =BLOC(condition="(FREQ!=None) or (LIST_FREQ!=None)",
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
             ),
             ),
         b_no_mod_meca  =BLOC (condition="AsType(RESULTAT)!= mode_meca ",
         TOUT_ORDRE    =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE    =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE    =SIMP(statut='f',typ=listis_sdaster),   
         INST          =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST     =SIMP(statut='f',typ=listr8_sdaster),
             b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)",
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
             ),
             ),
         INFO          =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE         =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: aurore.parrot at edf.fr
#
POST_K_BETA=OPER(nom="POST_K_BETA",op=198,sd_prod=table_sdaster,
                   fr="Calcul des facteurs d'intensité de contraintes par la méthode K_BETA",
                   reentrant='n',
            UIinfo={"groupes":("Post-traitements","Rupture",)},
         MAILLAGE      = SIMP(statut='o',typ=maillage_sdaster),
         MATER_REV     = SIMP(statut='o',typ=mater_sdaster),
         EPAIS_REV     = SIMP(statut='o',typ='R'),
         FISSURE       = FACT(statut='o',
            DECALAGE       = SIMP(statut='f',typ='R',defaut=-2.e-04),
            PROFONDEUR     = SIMP(statut='o',typ='R'),
            LONGUEUR       = SIMP(statut='o',typ='R'),
            ORIENTATION    = SIMP(statut='o',typ='TXM',
                                 into=("CIRC","LONGI"),),
         ),
         K1D           = FACT(statut='o',max='**',
            TABL_MECA_REV  = SIMP(statut='o',typ=(table_sdaster)),
            TABL_MECA_MDB  = SIMP(statut='o',typ=(table_sdaster)),
            TABL_THER      = SIMP(statut='o',typ=(table_sdaster)),
            INTITULE       = SIMP(statut='o',typ='TXM' ), 
         ),
         TITRE         = SIMP(statut='f',typ='TXM',max='**'),  
);

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr


POST_K_TRANS=MACRO(nom="POST_K_TRANS",
                   op=OPS('Macro.post_k_trans_ops.post_k_trans_ops'),
                   sd_prod=table_sdaster,
                   fr="Calcul des facteurs d intensite des contrainte par recombinaison modale",
                   reentrant='n',
                   UIinfo={"groupes":("Post-traitements","Rupture",)},
        RESU_TRANS      =SIMP(statut='o',typ=tran_gene),
        K_MODAL         =FACT(statut='o',
           TABL_K_MODA     =SIMP(statut='o',typ=table_sdaster,),
           FOND_FISS       =SIMP(statut='f',typ=fond_fiss,),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,),
           regles=( UN_PARMI('FISSURE','FOND_FISS'), ),
           ),
           
        regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
        TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
        NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
        LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
        INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
        LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
           PRECISION       =SIMP(statut='o',typ='R'),),
        INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
        TITRE           =SIMP(statut='f',typ='TXM'),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: romeo.fernandes at edf.fr

POST_MAC3COEUR = MACRO(nom="POST_MAC3COEUR",
                       op=OPS("Mac3coeur.post_mac3coeur_ops.post_mac3coeur_ops"),

           TYPE_COEUR   = SIMP(statut='o',typ='TXM',into=("MONO","TEST","900","1300","N4","EPR") ),
           RESULTAT     = SIMP(statut='o',typ=evol_noli),                             # SD_RESULTAT
           INST         = SIMP(statut='o',typ='R', max=1),                            # INSTANT
           
           LAME    = FACT(statut='f',max='**',
                          fr="Post-traitement des lames d'eau, par grille ou valeurs min/max",
                          regles = UN_PARMI('NUME_GRILLE','TYPE_RESU',),
                 NUME_GRILLE  = SIMP(statut='f',typ='I', max=1),                      # NUMERO DE LA GRILLE A POST-TRAITER
                 TYPE_RESU    = SIMP(statut='f',typ='TXM',into=("MINI","MAXI")),      # EXTREMA POUR LE POST
                 FORMAT       = SIMP(statut='o',typ='TXM',into=("GRACE","TABLE")),
                 UNITE        = SIMP(statut='o',typ='I', max=1),                   # NUMERO DE L'UNITE LOGIQUE POUR LE POST
           ),

           DEFORMATION = FACT(statut='f',max='**',
                              fr="Post-traitement des deformations, par grille ou valeurs min/max",
       
                 UNITE        = SIMP(statut='o',typ='I', max=1),   
                 FORMAT       = SIMP(statut='o',typ='TXM',into=("GRACE","TABLE")),
                 
                 b_def_grace  = BLOC(condition = "FORMAT == 'GRACE' ",fr="Paramètres pour le format GRACE",
                       regles=UN_PARMI('NUME_GRILLE','TYPE_RESU','POSITION'),
                       TYPE_VISU    = SIMP(statut='o',typ='TXM',into=("AMPLITUDE","MODULE","VECTEUR","DEFORME")),
                       TYPE_RESU    = SIMP(statut='f',typ='TXM',into=("MINI","MAXI")),
                       NUME_GRILLE  = SIMP(statut='f',typ='I', max=1), # NUMERO DE LA GRILLE A POST-TRAITER
                       POSITION     = SIMP(statut='f',typ='TXM', max=1),  
                       CONCEPTION   = SIMP(statut='f',typ='TXM', max=1),
                                   ),
                 
                 b_def_table  = BLOC(condition = "FORMAT == 'TABLE' ",fr="Paramètres pour le format TABLE",
                       NOM_CMP      = SIMP(statut='o',typ='TXM',into=("DY","DZ","NORME")),
                                   ),
                 

           ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr
POST_MAIL_XFEM=OPER(nom="POST_MAIL_XFEM",op= 187,sd_prod=maillage_sdaster,
                    reentrant='n',UIinfo={"groupes":("Maillage","Rupture",)},
            fr="Crée un maillage se conformant à la fissure pour le post-traitement des éléments XFEM",
    MODELE        = SIMP(statut='o',typ=modele_sdaster),
    PREF_NOEUD_X   =SIMP(statut='f',typ='TXM',defaut="NX",validators=LongStr(1,2),),
    PREF_NOEUD_M   =SIMP(statut='f',typ='TXM',defaut="NM",validators=LongStr(1,2),),
    PREF_NOEUD_P   =SIMP(statut='f',typ='TXM',defaut="NP",validators=LongStr(1,2),),
    PREF_MAILLE_X  =SIMP(statut='f',typ='TXM',defaut="MX",validators=LongStr(1,2),),
    PREF_GROUP_CO  =SIMP(statut='f',typ=grno ,defaut="NFISSU",),
    TITRE         = SIMP(statut='f',typ='TXM',max='**'),
    INFO           =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,) ),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

POST_RCCM=OPER(nom="POST_RCCM",op= 165,sd_prod=table_sdaster,
               fr="Vérification des critères de niveau 0 et certains critères de niveau A du RCC-M-B3200 (Edition 1991)",
               reentrant='n',
            UIinfo={"groupes":("Post-traitements","Rupture",)},
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="VALE_MAX",into=("VALE_MAX","DETAILS") ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         TYPE_RESU_MECA  =SIMP(statut='o',typ='TXM',into=("EVOLUTION","UNITAIRE","TUYAUTERIE") ),

# ======================================================================
     b_evolution  =BLOC(condition="(TYPE_RESU_MECA == 'EVOLUTION')",

         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                               into=("PM_PB","SN","FATIGUE_ZH210","AMORCAGE") ),
         MATER           =SIMP(statut='o',typ=mater_sdaster ),
         SY_MAX          =SIMP(statut='f',typ='R',
                               fr="limite élastique utilisée pour le calcul du rochet thermique" ),
         TYPE_KE         =SIMP(statut='f',typ='TXM',defaut="KE_MECA",into=("KE_MECA","KE_MIXTE"),
                               fr="Ke meca seul ou partition mecanique + thermique" ),
                               
         TRANSITOIRE     =FACT(statut='o',max='**',fr="transitoire à dépouiller",
           regles=(EXCLUS('TOUT_ORDRE','INST','LIST_INST'),
                   UN_PARMI('TABL_RESU_MECA','TABL_SIGM_THETA'),),
           NB_OCCUR        =SIMP(statut='f',typ='I',defaut= 1,
                                 fr="nombre d occurences réelles de ce transitoire" ),
           TABL_RESU_MECA  =SIMP(statut='f',typ=table_sdaster,
                                 fr="relevé des contraintes sur le chemin"),
           TABL_SIGM_THER  =SIMP(statut='f',typ=table_sdaster,
                                 fr="résultat sous chargement thermique seul" ),
           TABL_RESU_PRES  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes sous chargement de pression" ),
           TABL_SIGM_THETA =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes a la distance d de la singularité pour chacun des angles THETA" ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           b_inst          =BLOC(condition = "(INST != None) or (LIST_INST != None)" ,
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),),
           ),
         ),

# ======================================================================
     b_unitaire  =BLOC(condition="(TYPE_RESU_MECA == 'UNITAIRE')",

         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                               into=("PM_PB","SN","FATIGUE") ),
         MATER           =SIMP(statut='o',typ=mater_sdaster ),
         SY_MAX          =SIMP(statut='f',typ='R',
                               fr="limite élastique utilisée pourle calcul du rochet thermique" ),
         TYPE_KE         =SIMP(statut='f',typ='TXM',defaut="KE_MECA",into=("KE_MECA","KE_MIXTE"),
                               fr="Ke meca seul ou partition mecanique + thermique" ),
         CHAR_MECA   =FACT(statut='o',max='**',fr="Chargements mécaniques",
                           regles=(UN_PARMI('MX','MX_TUBU'),),
           NUME_CHAR     =SIMP(statut='o',typ='I',fr="numéro du chargement" ),
           NOM_CHAR      =SIMP(statut='f',typ='TXM',fr="nom du chargement" ),
           MX            =SIMP(statut='f',typ='R',fr="moment suivant x", ),
           MX_TUBU       =SIMP(statut='f',typ='R',fr="moment suivant x, tubulure", ),
           b_1_tenseur     =BLOC( condition = "MX != None",
             FX            =SIMP(statut='f',typ='R',fr="effort suivant x", ),
             FY            =SIMP(statut='f',typ='R',fr="effort suivant y", ),
             FZ            =SIMP(statut='f',typ='R',fr="effort suivant z", ),
             MY            =SIMP(statut='o',typ='R',fr="moment suivant y", ),
             MZ            =SIMP(statut='o',typ='R',fr="moment suivant z", ),
           ),
           b_2_tenseurs    =BLOC( condition = "MX_TUBU != None",
             FX_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant x, tubulure", ),
             FY_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant y, tubulure", ),
             FZ_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant z, tubulure", ),
             MY_TUBU       =SIMP(statut='o',typ='R',fr="moment suivant y, tubulure", ),
             MZ_TUBU       =SIMP(statut='o',typ='R',fr="moment suivant z, tubulure", ),
             FX_CORP       =SIMP(statut='f',typ='R',fr="effort suivant x, corps du piquage", ),
             FY_CORP       =SIMP(statut='f',typ='R',fr="effort suivant y, corps du piquage", ),
             FZ_CORP       =SIMP(statut='f',typ='R',fr="effort suivant z, corps du piquage", ),
             MX_CORP       =SIMP(statut='o',typ='R',fr="moment suivant x, corps du piquage", ),
             MY_CORP       =SIMP(statut='o',typ='R',fr="moment suivant y, corps du piquage", ),
             MZ_CORP       =SIMP(statut='o',typ='R',fr="moment suivant z, corps du piquage", ),
           ),

                         ),
         RESU_MECA_UNIT =FACT(statut='o',fr="resultats mécaniques unitaires",
                              regles=(UN_PARMI('TABL_MX','TABL_MX_TUBU'),),
           TABL_MX       =SIMP(statut='f',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire MX"),
           TABL_MX_TUBU  =SIMP(statut='f',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire MX_TUBU"),
           b_1_tenseur     =BLOC( condition = "TABL_MX != None",
             TABL_FX       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX"),
             TABL_FY       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY"),
             TABL_FZ       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ"),
             TABL_MY       =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY"),
             TABL_MZ       =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ"),
           ),
           b_2_tenseurs    =BLOC( condition = "TABL_MX_TUBU != None",
             TABL_FX_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX_TUBU"),
             TABL_FY_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY_TUBU"),
             TABL_FZ_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ_TUBU"),
             TABL_MY_TUBU  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY_TUBU"),
             TABL_MZ_TUBU  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ_TUBU"),
             TABL_FX_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX_CORP"),
             TABL_FY_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY_CORP"),
             TABL_FZ_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ_CORP"),
             TABL_MX_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MX_CORP"),
             TABL_MY_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY_CORP"),
             TABL_MZ_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ_CORP"),
           ),
           TABL_PRES     =SIMP(statut='o',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire de pression"),
                         ),

          RESU_THER   =FACT(statut='f',max='**',fr="resultats thermiques",
           NUME_RESU_THER =SIMP(statut='o',typ='I',fr="numéro de la table de résultat thermique" ),
           TABL_RESU_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des contraintes sous chargement thermique seul" ),
                           ),
         SEISME         =FACT(statut='f',max='**',fr="Situation séisme",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NB_CYCL_SEISME   =SIMP(statut='o',typ='I',fr="nombre de cycles associé au séisme" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',fr="numéros du groupe de la situation" ),
              CHAR_ETAT        =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
                               ),
         SITUATION         =FACT(statut='o',max='**',fr="Situation",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              COMBINABLE       =SIMP(statut='f',typ='TXM',defaut= "OUI",into=("OUI","NON"),fr="non = sous-cycle" ),
              NUME_PASSAGE     =SIMP(statut='f',typ='I',min=2,max=2,
                                     fr="numéro des situations de passage" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',
                                        fr="numéros des groupes de la situation" ),
              NUME_RESU_THER   =SIMP(statut='f',typ='I',max=1,fr="numeros de transitoires thermiques" ),
              CHAR_ETAT_A      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
              CHAR_ETAT_B      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat B" ),
              PRES_A           =SIMP(statut='o',typ='R',fr="pression etat A"),
              PRES_B           =SIMP(statut='o',typ='R',fr="pression etat B"),
              TEMP_REF_A       =SIMP(statut='f',typ='R',fr="temperature référence etat A"),
              TEMP_REF_B       =SIMP(statut='f',typ='R',fr="temperature référence etat B"),
                               ),

                      ),
# ======================================================================
     b_tuyauterie  =BLOC(condition="(TYPE_RESU_MECA == 'TUYAUTERIE')",

         OPTION          =SIMP(statut='o',typ='TXM',into=("FATIGUE",) ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         TYPE_KE         =SIMP(statut='f',typ='TXM',defaut="KE_MECA",into=("KE_MECA","KE_MIXTE"),
                               fr="Ke meca seul ou partition mecanique + thermique" ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem),
         ZONE_ANALYSE =FACT(statut='o',fr="liste des mailles ou des noeuds analysés",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            ),
         RESU_MECA   =FACT(statut='o',max='**',fr="Chargements mécaniques",
           regles=(UN_PARMI('CHAM_GD','RESULTAT'),),
           NUME_CHAR     =SIMP(statut='o',typ='I',fr="numéro du chargement" ),
           NOM_CHAR      =SIMP(statut='f',typ='TXM',fr="nom du chargement" ),
           CHAM_GD         =SIMP(statut='f',typ=cham_gd_sdaster),
           RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),
           b_extrac        =BLOC(condition="RESULTAT != None",
                                 fr="extraction d un champ de grandeur",
             regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','INST','NOEUD_CMP'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',into=("EFGE_ELNO","SIEF_ELNO"),),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',),
             INST            =SIMP(statut='f',typ='R',),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             b_acce_reel     =BLOC(condition="(INST != None)",
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
               b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
               b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
             ),
           ),
                          ),
         INDI_SIGM =FACT(statut='o',max='**',fr="indices de contraintes",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            C1              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes C1 du RCCM"),
            K1              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K1 du RCCM"),
            C2              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes C2 du RCCM"),
            K2              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K2 du RCCM"),
            C3              =SIMP(statut='f',typ='R',defaut=0.5,fr="indice de contraintes C3 du RCCM"),
            K3              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K3 du RCCM"),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                             fr="groupe(s) de mailles ou sont affectés les indices de contraintes"),
            MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',
                             fr="liste des mailles ou sont affectés les indices de contraintes"),
            b_grma     =BLOC(condition="(GROUP_MA != None)or(MAILLE != None)",
               GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            ),
            TYPE_ELEM_STANDARD =SIMP(statut='f',typ='TXM',into=("DRO","COU","TRN","TEE"),
                              fr="type d'élément de tuyauterie ou sont affectés les indices de contraintes"),
                         ),
          RESU_THER   =FACT(statut='f',max='**',fr="resultats thermiques",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            NUME_RESU_THER =SIMP(statut='o',typ='I',fr="numéro de la table de résultat thermique" ),
            TABL_RESU_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des températures sur la section"),
            TABL_MOYE_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des moyennes sur la section"),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            b_grma     =BLOC(condition="(GROUP_MA != None)or(MAILLE != None)",
               GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            ),
                           ),
         SEISME         =FACT(statut='f',max='**',fr="Situation séisme",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NB_CYCL_SEISME   =SIMP(statut='o',typ='I',fr="nombre de cycles associé au séisme" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',fr="numéros du groupe de la situation" ),
              CHAR_ETAT        =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
              TEMP_REF         =SIMP(statut='f',typ='R',fr="temperature référence"),
                               ),
         SITUATION         =FACT(statut='o',max='**',fr="Situation",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              COMBINABLE       =SIMP(statut='f',typ='TXM',defaut= "OUI",into=("OUI","NON"),fr="non = sous-cycle" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',
                                     fr="numéros des groupes de la situation" ),
              NUME_PASSAGE     =SIMP(statut='f',typ='I',min=2,max=2,
                                     fr="numéro des situations de passage" ),
              NUME_RESU_THER   =SIMP(statut='f',typ='I',max='**',fr="numeros de transitoires thermiques" ),
              CHAR_ETAT_A      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
              CHAR_ETAT_B      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat B" ),
              PRES_A           =SIMP(statut='o',typ='R',fr="pression etat A"),
              PRES_B           =SIMP(statut='o',typ='R',fr="pression etat B"),
              TEMP_REF_A       =SIMP(statut='f',typ='R',fr="temperature référence etat A"),
              TEMP_REF_B       =SIMP(statut='f',typ='R',fr="temperature référence etat B"),
                               ),
               ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: xavier.desroches at edf.fr
POST_RELEVE_T=OPER(nom="POST_RELEVE_T",op=51,sd_prod=table_sdaster,reentrant='f',
            fr="Extraire des valeurs de composantes de champs de grandeurs pour y effectuer des calculs (moyenne,invariants,..)"
               +" ou pour les exprimer dans d'autres repères",
            docu="U4.81.21",UIinfo={"groupes":("Post-traitements","Résultats et champs",)},

         ACTION          =FACT(statut='o',max='**',
                               regles=(UN_PARMI('RESULTAT','CHAM_GD'),),

           OPERATION       =SIMP(statut='o',typ='TXM',into=("EXTRACTION","MOYENNE","MOYENNE_ARITH","EXTREMA"),
                                 validators=NoRepeat(), max=2),
           INTITULE        =SIMP(statut='o',typ='TXM'),

           CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,
                                                 cham_elem,),),
           RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),

           b_extrac        =BLOC(condition = "RESULTAT != None",fr="extraction des résultats",
                                 regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','NUME_MODE','LIST_MODE',
                                                'INST','LIST_INST','FREQ','LIST_FREQ','NOEUD_CMP','NOM_CAS'), ),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO(),),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_MODE       =SIMP(statut='f',typ=listis_sdaster),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
           ),

           b_extrema   =BLOC(condition="au_moins_un(OPERATION, 'EXTREMA')",
                             fr="recherche de MIN MAX",
                             regles=(EXCLUS('TOUT_CMP','NOM_CMP'),),
              TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           ),

           b_MOYENNE_ARITH   =BLOC(condition="au_moins_un(OPERATION, 'MOYENNE_ARITH')",
                             fr="moyenne sur des groupes",
                             regles=(EXCLUS('TOUT_CMP','NOM_CMP'),),
              TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           ),

           b_autre   =BLOC(condition="aucun(OPERATION, ('EXTREMA', 'MOYENNE_ARITH'))",
                           fr="extraction et moyenne",
                           regles=(AU_MOINS_UN('CHEMIN','GROUP_NO','NOEUD'),
                                   EXCLUS('CHEMIN','GROUP_NO'),
                                   EXCLUS('CHEMIN','NOEUD'),
                                   PRESENT_ABSENT('CHEMIN','GROUP_MA','MAILLE'),
                                   UN_PARMI('TOUT_CMP','NOM_CMP','INVARIANT','ELEM_PRINCIPAUX','RESULTANTE'),
                                   PRESENT_PRESENT('TRAC_DIR','DIRECTION'),
                                   ENSEMBLE('MOMENT','POINT'),
                                   PRESENT_PRESENT('MOMENT','RESULTANTE'),
                                   PRESENT_ABSENT('TOUT_CMP','TRAC_DIR','TRAC_NOR'),
                                   EXCLUS('TRAC_DIR','TRAC_NOR'),
                                   PRESENT_PRESENT('ORIGINE','AXE_Z'),),

              CHEMIN          =SIMP(statut='f',typ=(courbe_sdaster,surface_sdaster) ),
              TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

              TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
              INVARIANT       =SIMP(statut='f',typ='TXM',into=("OUI",)),
              ELEM_PRINCIPAUX =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              RESULTANTE      =SIMP(statut='f',typ='TXM',max='**'),

              MOMENT          =SIMP(statut='f',typ='TXM',max='**'),
              POINT           =SIMP(statut='f',typ='R',max='**'),

              REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL",
                                 into=("GLOBAL","LOCAL","POLAIRE","UTILISATEUR","CYLINDRIQUE"),),
              ANGL_NAUT       =SIMP(statut='f',typ='R',min=3,max=3),
              ORIGINE         =SIMP(statut='f',typ='R',min=3,max=3),
              AXE_Z           =SIMP(statut='f',typ='R',min=3,max=3),

              TRAC_NOR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              TRAC_DIR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              DIRECTION       =SIMP(statut='f',typ='R',max='**'),

              VECT_Y          =SIMP(statut='f',typ='R',max='**'),
              MOYE_NOEUD      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           ),

           FORMAT_C        =SIMP(statut='f',typ='TXM',defaut="MODULE",into=("MODULE","REEL","IMAG")),

         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

POST_RUPTURE=MACRO(nom="POST_RUPTURE",
                   op=OPS("Macro.post_rupture_ops.post_rupture_ops"),
                   sd_prod=table_sdaster,
                   fr="post-traitements en Rupture",
                   reentrant='f',
                   UIinfo={"groupes":("Résultats et champs","Rupture",)},

      TABLE     = SIMP(statut='o',typ=table_sdaster,max='**'),

#     rq : il est impossible de proposer le bon choix pour OPERATION suivant la valeur de reuse...
      OPERATION = SIMP(statut='o',typ='TXM',into=(
                                                  'ABSC_CURV_NORM',
                                                  'ANGLE_BIFURCATION',
                                                  'K_EQ',
                                                  'DELTA_K_EQ',
                                                  'COMPTAGE_CYCLES',
                                                  'LOI_PROPA',
                                                  'CUMUL_CYCLES',
                                                  'PILO_PROPA',
                                                  'K1_NEGATIF',
                                                 )
                       ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'ABSC_CURV_NORM'
#-----------------------------------------------------------------------------------------------------------------------------------


      b_absc = BLOC(condition="OPERATION == 'ABSC_CURV_NORM'",fr="normalise l'abscisse curviligne",

                   NOM_PARA = SIMP(statut='f',typ='TXM',max=1,defaut="ABSC_CURV_NORM",fr="Nom de la nouvelle colonne"),

                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'ANGLE_BIFURCATION'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_angle = BLOC(condition="OPERATION == 'ANGLE_BIFURCATION'  ",fr="Angle de bifurcation",

                   NOM_PARA = SIMP(statut='f',typ='TXM',max=1,defaut="BETA",fr="Nom de la nouvelle colonne"),
                   CRITERE  = SIMP(statut='f',typ='TXM',max=1,defaut="SITT_MAX",into=('SITT_MAX','K1_MAX','K2_NUL','PLAN'),),
                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'K_EQ'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_Keq = BLOC(condition="OPERATION == 'K_EQ'  ",fr="Cumul sur les modes : calcul du K equivalent",

                   NOM_PARA = SIMP(statut='f',typ='TXM',max=1,defaut="K_EQ",fr="Nom de la nouvelle colonne"),
                   CUMUL    = SIMP(statut='f',typ='TXM',max=1,defaut="CUMUL_G",fr="Formule de cumul des modes",
                                   into=('LINEAIRE','QUADRATIQUE','CUMUL_G','MODE_I'),),

                     b_mater = BLOC(condition="CUMUL in ('QUADRATIQUE','CUMUL_G')",fr="materiau du fond de fissure",
                                    MATER = SIMP(statut='o',typ=mater_sdaster,),
                                   ),
                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'DELTA_K_EQ'
#-----------------------------------------------------------------------------------------------------------------------------------
                  
      b_DeltaKeq = BLOC(condition="OPERATION == 'DELTA_K_EQ'  ",fr="Cumul sur les modes : calcul du DeltaK equivalent",

                   NOM_PARA = SIMP(statut='f',typ='TXM',max=1,defaut="DELTA_K_EQ",fr="Nom de la nouvelle colonne"),
                   CUMUL    = SIMP(statut='f',typ='TXM',max=1,defaut="CUMUL_G",fr="Formule de cumul des modes",
                                       into=('QUADRATIQUE','CUMUL_G','MODE_I'),),

                     b_mater = BLOC(condition="CUMUL in ('QUADRATIQUE','CUMUL_G')",fr="materiau du fond de fissure",
                                      MATER = SIMP(statut='o',typ=mater_sdaster,),
                                    ),
                  
                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'COMPTAGE_CYCLES'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_Comptage = BLOC(condition="OPERATION == 'COMPTAGE_CYCLES'  ",fr="Comptage des cycles",

                   NOM_PARA   = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                                     fr="Nom des quantités sur lesquelles s'effectuent le comptage"),
                   COMPTAGE   = SIMP(statut='o',typ='TXM',into=("RAINFLOW","RCCM","NATUREL","UNITAIRE")),
                   DELTA_OSCI = SIMP(statut='f',typ='R',defaut= 0.0E+0),

                     b_Comptage_Unitaire = BLOC(condition="COMPTAGE=='UNITAIRE'",
                                                fr="comptage unitaire pour les amplitudes constantes",

                                                COEF_MULT_MINI = SIMP(statut='o',typ='R',),
                                                COEF_MULT_MAXI = SIMP(statut='o',typ='R',),

                                               ),

                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'LOI_PROPA'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_Loi_Propa   = BLOC(condition="OPERATION == 'LOI_PROPA'  ",fr="calcul de l'incrément d'avancée de fissure par cycle",

                   NOM_PARA       = SIMP(statut='f',typ='TXM',defaut="DELTA_A"   ,max=1,fr="Nom de la nouvelle colonne"),
                   NOM_DELTA_K_EQ = SIMP(statut='f',typ='TXM',defaut="DELTA_K_EQ",max=1,
                                                                              fr="Nom de la quantité correspondant au Delta_K_eq"),
                   LOI            = SIMP(statut='o',typ='TXM',into=("PARIS",)),

                     b_paris = BLOC(condition = "LOI=='PARIS'",
                                    C = SIMP(statut='o',typ='R',),
                                    M = SIMP(statut='o',typ='R',),
                                   ),

      ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'CUMUL_CYCLES'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_cumul = BLOC(condition="OPERATION == 'CUMUL_CYCLES'  ",fr="Cumul sur les cycles",

                   NOM_PARA = SIMP(statut='f',typ='TXM',max=1,defaut="DELTA_A",fr="Nom de la colonne à traiter"),
                   CUMUL    = SIMP(statut='f',typ='TXM',max=1,defaut="LINEAIRE",into=('LINEAIRE',)),

                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'PILO_PROPA'
#-----------------------------------------------------------------------------------------------------------------------------------
                  
      b_pilo_propa = BLOC(condition="OPERATION == 'PILO_PROPA'  ",fr="Pilotage de la propagation",

                   regles      = UN_PARMI('DELTA_A_MAX','DELTA_N'),
                   DELTA_A_MAX = SIMP(statut='f',typ='R',max=1,val_min=0.,fr="Pilotage en incrément d'avancée max"),
                   DELTA_N     = SIMP(statut='f',typ='R',max=1,val_min=1 ,fr="Pilotage en incrément de nombre de blocs"),
                  
                   ),

#-----------------------------------------------------------------------------------------------------------------------------------
#                 'K1_NEGATIF'
#-----------------------------------------------------------------------------------------------------------------------------------

      b_k1_neg = BLOC(condition="OPERATION == 'K1_NEGATIF'  ",fr="Mise a zero des valeurs negatives de K1",

                   MODELISATION = SIMP(statut='o',typ='TXM',into=("C_PLAN","D_PLAN","3D","AXIS")),
                   MATER        = SIMP(statut='o',typ=mater_sdaster,),

                   ),

#-----------------------------------------------------------------------------------------------------------------------------------

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: irmela.zentner at edf.fr
POST_USURE=OPER(nom="POST_USURE",op=153,sd_prod=table_sdaster,reentrant='f',
            UIinfo={"groupes":("Post-traitements",)},
                fr="Calcul des volumes d'usure et des profondeurs d'usure d'après la puissance d'usure",
         regles=(UN_PARMI('TUBE_NEUF','RESU_GENE','PUIS_USURE'),
                 PRESENT_PRESENT('RESU_GENE','NOEUD','LOI_USURE'),
                 PRESENT_PRESENT('PUIS_USURE','LOI_USURE'),),
         TUBE_NEUF       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ETAT_INIT       =FACT(statut='f',
           TABL_USURE      =SIMP(statut='f',typ=table_sdaster),
           INST_INIT       =SIMP(statut='f',typ='R'),
                         ),
         RESU_GENE       =SIMP(statut='f',typ=tran_gene),
         NOEUD           =SIMP(statut='f',typ=no,),
         INST_INIT       =SIMP(statut='f',typ='R',defaut=-1.0E+0),
         INST_FIN        =SIMP(statut='f',typ='R'),
         NB_BLOC         =SIMP(statut='f',typ='I',defaut= 1 ),
         PUIS_USURE      =SIMP(statut='f',typ='R'),
         LOI_USURE       =SIMP(statut='f',typ='TXM',into=("ARCHARD","KWU_EPRI","EDF_MZ")),
         b_archard       =BLOC(condition = "LOI_USURE == 'ARCHARD'",
           regles=(UN_PARMI('MOBILE','MATER_USURE','SECTEUR'),
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R'),
           ),
           OBSTACLE        =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R'),
           ),
           SECTEUR         =FACT(statut='f',max='**',
             CONTACT         =SIMP(statut='f',typ='TXM',into=("TUBE_BAV","TUBE_ALESAGE","TUBE_4_ENCO",
                                                              "GRAPPE_ALESAGE","TUBE_3_ENCO","TUBE_TUBE",
                                                              "GRAPPE_1_ENCO","GRAPPE_2_ENCO")),
             COEF_USUR_MOBILE=SIMP(statut='f',typ='R'),
             COEF_USUR_OBST  =SIMP(statut='f',typ='R'),
             ANGL_INIT       =SIMP(statut='f',typ='R'),
             ANGL_FIN        =SIMP(statut='f',typ='R'),
           ),
           MATER_USURE     =SIMP(statut='f',typ='TXM'),
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
         ),
         b_kwu_epri        =BLOC(condition = "LOI_USURE == 'KWU_EPRI'",
           regles=(UN_PARMI('MOBILE','MATER_USURE'),
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_FNOR       =SIMP(statut='f',typ='R'),
             COEF_VTAN       =SIMP(statut='f',typ='R'),
             COEF_USURE      =SIMP(statut='f',typ='R'),
             COEF_K          =SIMP(statut='f',typ='R',defaut=5.0E+0),
             COEF_C          =SIMP(statut='f',typ='R',defaut=10.0E+0),
           ),
           OBSTACLE        =FACT(statut='f',
             COEF_FNOR       =SIMP(statut='f',typ='R' ),
             COEF_VTAN       =SIMP(statut='f',typ='R' ),
             COEF_USURE      =SIMP(statut='o',typ='R'),
             COEF_K          =SIMP(statut='f',typ='R',defaut=5.0E+0),
             COEF_C          =SIMP(statut='f',typ='R',defaut=10.0E+0),
           ),
           MATER_USURE     =SIMP(statut='f',typ='TXM'),
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
           FNOR_MAXI       =SIMP(statut='f',typ='R' ),
           VTAN_MAXI       =SIMP(statut='f',typ='R' ),
         ),
         b_edf_mz          =BLOC(condition = "LOI_USURE == 'EDF_MZ'",
           regles=(UN_PARMI('MOBILE','MATER_USURE'),
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_USURE      =SIMP(statut='f',typ='R',defaut=1.0E-13),
             COEF_B          =SIMP(statut='f',typ='R',defaut=1.2E+0),
             COEF_N          =SIMP(statut='f',typ='R',defaut=2.44E-8),
             COEF_S          =SIMP(statut='f',typ='R',defaut=1.14E-16),
           ),
           OBSTACLE        =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R',defaut=1.0E-13),
             COEF_B          =SIMP(statut='f',typ='R',defaut=1.2E+0),
             COEF_N          =SIMP(statut='f',typ='R',defaut=2.44E-8),
             COEF_S          =SIMP(statut='f',typ='R',defaut=1.14E-16),
           ),
           MATER_USURE     =SIMP(statut='f',typ='TXM'),
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
         ),
         b_tube_neuf       =BLOC(condition = "TUBE_NEUF == 'OUI'",
            TABL_USURE      =SIMP(statut='o',typ=table_sdaster),
         ),
         CONTACT         =SIMP(statut='f',typ='TXM',into=("TUBE_BAV","TUBE_ALESAGE","TUBE_4_ENCO",
                                                          "GRAPPE_ALESAGE","TUBE_3_ENCO","TUBE_TUBE",
                                                          "GRAPPE_1_ENCO","GRAPPE_2_ENCO")),
         RAYON_MOBILE    =SIMP(statut='f',typ='R'),
         RAYON_OBST      =SIMP(statut='f',typ='R'),
         LARGEUR_OBST    =SIMP(statut='f',typ='R'),
         ANGL_INCLI      =SIMP(statut='f',typ='R'),
         ANGL_ISTHME     =SIMP(statut='f',typ='R'),
         ANGL_IMPACT     =SIMP(statut='f',typ='R'),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         COEF_INST       =SIMP(statut='f',typ='R',defaut=1.0E+0),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr

POURSUITE=MACRO(nom="POURSUITE",
                op=OPS("Cata.ops.build_poursuite"),
                repetable='n',
                fr="Poursuite d'une étude à partir de la sauvegarde au format JEVEUX " \
                   "ou HDF de sa base globale",
                sd_prod = ops.POURSUITE,
                UIinfo={"groupes":("Gestion du travail",)},
                op_init=ops.POURSUITE_context,
                fichier_ini=1,
         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
                               typ='TXM',defaut="NON",into=("OUI","NON",) ),
         PAR_LOT         =SIMP(fr="mode de traitement des commandes",statut='f',typ='TXM',
                           into=("OUI","NON"),defaut="OUI"),
         IMPR_MACRO      =SIMP(fr="affichage des sous-commandes produites par les macros dans le fichier mess",
                           statut='f',typ='TXM',into=("OUI","NON"),defaut="NON"),

         BASE            =FACT(fr="définition des paramètres associés aux bases JEVEUX",
                               statut='f',min=1,max=2,
           FICHIER         =SIMP(fr="nom de la base",statut='o',typ='TXM'),
           TITRE           =SIMP(statut='f',typ='TXM'),
           CAS             =SIMP(statut='f',typ='TXM'),
           NMAX_ENRE       =SIMP(fr="nombre maximum d enregistrements",statut='f',typ='I'),
           LONG_ENRE       =SIMP(fr="longueur des enregistrements",statut='f',typ='I'),
           LONG_REPE       =SIMP(fr="longueur du répertoire",statut='f',typ='I'),
         ),

# Le mot cle CATALOGUE n'est jamais utilise en POURSUITE mais sa presence est necessaire au bon fonctionnement
# de la commande, le code source etant commun aux commandes DEBUT et POURSUITE.
#
         CATALOGUE       =FACT(statut='f',min=1,max=10,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I'),
         ),

         ERREUR          =FACT(fr="comportement en cas d'erreur",statut='f',min=1,max=1,
           ERREUR_F        =SIMP(statut='f',typ='TXM',into=('ABORT','EXCEPTION'),defaut='ABORT'),
         ),

         DEBUG           =FACT(fr="option de déboggage reservée aux développeurs",
                               statut='f',min=1,max=1,
           JXVERI          =SIMP(fr="vérifie l intégrité de la segmentation mémoire",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           SDVERI          =SIMP(fr="vérifie la conformité des SD produites par les commandes",
                                 statut='f',typ='TXM',into=('OUI','NON')),
           JEVEUX          =SIMP(fr="force les déchargement sur disque",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           ENVIMA          =SIMP(fr="imprime les valeurs définies dans ENVIMA",
                                 statut='f',typ='TXM',into=('TEST',)),
           HIST_ETAPE = SIMP(fr="permet de conserver toutes les étapes du jeu de commandes",
                             statut='f', typ='TXM', into=('OUI', 'NON'), defaut='NON'),
         ),

         MESURE_TEMPS     =FACT(fr="Pour choisir les mesures de temps consommé dans les commandes",
                               statut='d',min=1,max=1,
           NIVE_DETAIL      =SIMP(fr="niveau de détail des impressions",
                                 statut='f',typ='I',into=(0,1,2,3),defaut=1),
                                 # 0 : rien
                                 # 1 : impression en fin de commande des mesures principales
                                 # 2 : impression en fin de commande des mesures principales et secondaires
                                 # 3 : impression des mesures principales et secondaires pour chaque pas de temps
           MOYENNE     =SIMP(fr="affichage des moyennes et écart-types en parallèle",
                                  statut='f',typ='TXM',into=('OUI','NON',),defaut='NON'),
         ),

         MEMOIRE         =FACT(fr="mode de gestion mémoire utilisé",statut='d',min=1,max=1,
           TAILLE_BLOC       =SIMP(statut='f',typ='R',defaut=800.),
           TAILLE_GROUP_ELEM =SIMP(statut='f',typ='I',defaut=1000),
         ),

         RESERVE_CPU     =FACT(fr="reserve de temps pour terminer une execution",statut='d',max=1,
           regles=(EXCLUS('VALE','POURCENTAGE'),),
           VALE            =SIMP(statut='f',typ='I',val_min=0),
#                            valeur par défaut fixée à 10. dans le FORTRAN si CODE présent
           POURCENTAGE     =SIMP(statut='f',typ='R',val_min=0.,val_max=1.0),
#                           valeur par défaut fixée à 10% dans le FORTRAN
           BORNE           =SIMP(statut='f',typ='I',val_min=0,defaut=900) ),
#          valeur en pourcentage du temps maximum bornée à 900 secondes

         CODE            =SIMP(statut='f',typ='TXM',into=('OUI', 'NON'),defaut='NON',
                               fr="paramètre réservé aux cas-tests"),

         IGNORE_ALARM = SIMP(statut='f', typ='TXM', max='**', fr="Alarmes que l'utilisateur souhaite délibérément ignorer"),

         LANG = SIMP(statut='f', typ='TXM',
                     fr="Permet de choisir la langue utilisée pour les messages (si disponible)",
                     ang="Allows to choose the language used for messages (if available)"),

         INFO     = SIMP(statut='f', typ='I', defaut=1, into=(1,2),),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

PRE_GIBI=PROC(nom="PRE_GIBI",op=49,
            UIinfo={"groupes":("Gestion du travail",)},
              fr="Conversion d'un fichier de maillage GIBI au format Aster",
         UNITE_GIBI      =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

PRE_GMSH=PROC(nom="PRE_GMSH",op=47,
            UIinfo={"groupes":("Gestion du travail",)},
               fr="Conversion d'un fichier de maillage GMSH au format Aster",
         UNITE_GMSH      =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: alexei.mikchevitch at edf.fr
PRE_IDEAS=PROC(nom="PRE_IDEAS",op=47,
            UIinfo={"groupes":("Gestion du travail",)},
               fr="Conversion d'un fichier universel IDEAS-SUPERTAB au format Aster",
         UNITE_IDEAS     =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
         CREA_GROUP_COUL =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

PROD_MATR_CHAM=OPER(nom="PROD_MATR_CHAM",op= 156,sd_prod=cham_no_sdaster,
                    fr="Effectuer le produit d'une matrice par un vecteur",
                    reentrant='n',
            UIinfo={"groupes":("Post-traitements","Matrices et vecteurs",)},
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_pres_c ) ),
         CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# person_in_charge: emmanuel.boyere at edf.fr


def proj_base_prod(self,MATR_ASSE_GENE,VECT_ASSE_GENE,
                   RESU_GENE, NUME_DDL_GENE,
                   STOCKAGE,**args ):
  if NUME_DDL_GENE is not None and NUME_DDL_GENE.is_typco():
      self.type_sdprod(NUME_DDL_GENE, nume_ddl_gene)
  if MATR_ASSE_GENE != None:
    for m in MATR_ASSE_GENE:
      self.type_sdprod(m['MATRICE'],matr_asse_gene_r)
  if VECT_ASSE_GENE != None:
    for v in VECT_ASSE_GENE:
      self.type_sdprod(v['VECTEUR'],vect_asse_gene)
  if RESU_GENE != None:
    for v in RESU_GENE:
      self.type_sdprod(v['RESULTAT'],tran_gene)
  return None

PROJ_BASE=MACRO(nom="PROJ_BASE",
                op=OPS('Macro.proj_base_ops.proj_base_ops'),
                regles=(AU_MOINS_UN('MATR_ASSE_GENE','VECT_ASSE_GENE','RESU_GENE')),
                UIinfo={"groupes":("Matrices et vecteurs","Dynamique",)},
                sd_prod=proj_base_prod,
         fr="Projection des matrices et/ou vecteurs assembles sur une base (modale ou de RITZ)",
         BASE            =SIMP(statut='o',typ=(mode_meca,mode_gene) ),
         NB_VECT         =SIMP(statut='f',typ='I',defaut= 9999),
         STOCKAGE        =SIMP(statut='f',typ='TXM',defaut="PLEIN",into=("PLEIN","DIAG") ),
         NUME_DDL_GENE   =SIMP(statut='f',typ=(nume_ddl_gene,CO),defaut=None),
         MATR_ASSE_GENE  =FACT(statut='f',max='**',
           MATRICE         =SIMP(statut='o',typ=CO,),
           regles=(UN_PARMI('MATR_ASSE','MATR_ASSE_GENE',),),
           MATR_ASSE       =SIMP(statut='f',typ=matr_asse_depl_r),
           MATR_ASSE_GENE  =SIMP(statut='f',typ=matr_asse_gene_r),
         ),
         VECT_ASSE_GENE  =FACT(statut='f',max='**',
           VECTEUR         =SIMP(statut='o',typ=CO,),
           regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE',),),
           TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene),
         ),
         RESU_GENE  =FACT(statut='f',max='**',
           RESULTAT        =SIMP(statut='o',typ=CO,),
           TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
           RESU            =SIMP(statut='o',typ=dyna_trans),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr
def proj_champ_prod(RESULTAT=None,CHAM_GD=None,METHODE=None,**args ):
    if (RESULTAT == None and CHAM_GD == None) : return corresp_2_mailla
    if  RESULTAT != None                      : return AsType(RESULTAT)
    if  CHAM_GD  != None and METHODE == 'SOUS_POINT' :
        return cham_elem
    else :
        return AsType(CHAM_GD)
    raise AsException("type de concept resultat non prevu")




PROJ_CHAMP=OPER(nom="PROJ_CHAMP",op= 166,sd_prod=proj_champ_prod,reentrant='f',
        UIinfo={"groupes":("Résultats et champs",)},
            fr="Projeter des champs d'un maillage sur un autre",

     # faut-il projeter les champs ?
     PROJECTION      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",),),

     # pour projeter avec une sd_corresp_2_mailla deja calculée :
     MATR_PROJECTION   =SIMP(statut='f',typ=corresp_2_mailla,),



     #-----------------------------------------------------------------------------------------------------------
     # 1er cas : on fait tout d'un coup : creation de la sd_corresp_2_mailla + projection des champs
     #-----------------------------------------------------------------------------------------------
     b_1_et_2   =BLOC(condition= "PROJECTION == 'OUI' and MATR_PROJECTION == None",
         regles=(UN_PARMI('RESULTAT','CHAM_GD'),
                 UN_PARMI('MODELE_1','MAILLAGE_1'),
                 UN_PARMI('MODELE_2','MAILLAGE_2'),
                 ),
         RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),
         CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,cham_elem)),

         METHODE         =SIMP(statut='f',typ='TXM',defaut="AUTO",
                               into=("NUAGE_DEG_0","NUAGE_DEG_1","AUTO","COLLOCATION","ECLA_PG","SOUS_POINT") ),


         MODELE_1        =SIMP(statut='f',typ=modele_sdaster),
         MAILLAGE_1      =SIMP(statut='f',typ=(maillage_sdaster,squelette)),

         MODELE_2        =SIMP(statut='f',typ=modele_sdaster),
         MAILLAGE_2      =SIMP(statut='f',typ=maillage_sdaster),

         # Cas de la projection NUAGE_DEG_0/1 :
         #--------------------------------------------
         b_nuage         =BLOC(condition="METHODE in ('NUAGE_DEG_0','NUAGE_DEG_1')",
             CHAM_NO_REFE    =SIMP(statut='o',typ=cham_no_sdaster),
         ),


         # Cas de la projection COLLOCATION :
         #--------------------------------------------
         b_elem          =BLOC(condition="METHODE in ('COLLOCATION','ECLA_PG','AUTO')",
             CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",),
                  fr="Pour indiquer au programme le type de projection souhaité"),
             DISTANCE_MAX    =SIMP(statut='f',typ='R',
                  fr="Distance maximale entre le noeud et l'élément le plus proche, lorsque le noeud n'est dans aucun élément."),

             TRANSF_GEOM_1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_1 avant la projection."),
             TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_2 avant la projection."),

             ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),

             TYPE_CHAM       =SIMP(statut='f',typ='TXM',into=("NOEU",),
                  fr="Pour forcer le type des champs projetés. NOEU -> cham_no"),

             PROL_ZERO       =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
                  fr="Pour prolonger les champs par zéro là ou la projection ne donne pas de valeurs."),
         ),

         # Cas de la projection SOUS_POINT :
         #--------------------------------------------
         b_sous_point         =BLOC(condition="METHODE == 'SOUS_POINT'" ,
             CARA_ELEM    =SIMP(statut='o',typ=cara_elem),
             PROL_ZERO       =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
                  fr="Pour prolonger les champs par zéro là ou la projection ne donne pas de valeurs."),
             TRANSF_GEOM_1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_1 avant la projection."),
             TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_2 avant la projection."),
         ),


         # Cas de la projection d'une sd_resultat :
         #--------------------------------------------
         b_resultat      =BLOC(condition="RESULTAT != None",
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','LIST_INST','LIST_FREQ','LIST_ORDRE'),
                   EXCLUS('TOUT_CHAM','NOM_CHAM',),),
           NOM_PARA        =SIMP(statut='f',typ='TXM', max='**'),
           TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(),),

           NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster),
                fr="Utile en dynamique pour pouvoir imoser la numérotation des cham_no."),

           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),

           b_acce_reel     =BLOC(condition="(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
           ),
         ),


         VIS_A_VIS       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT_1','GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   AU_MOINS_UN('TOUT_2','GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),),
           TOUT_1          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TOUT_2          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

           # les mots clés suivants ne sont actifs que si METHODE='COLLOCATION' mais on ne peut pas le vérifier:
               CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
               TRANSF_GEOM_1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                    fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                       " aux noeuds du MODELE_1 avant la projection."),
               TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                    fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                       " aux noeuds du MODELE_2 avant la projection."),
         ),
     ), # fin bloc b_1_et_2



     #-----------------------------------------------------------------------------------------------------------
     # 2eme cas : on s'arrete apres la creation de la sd_corresp_2_mailla
     #-----------------------------------------------------------------------------------------------
     b_1   =BLOC(condition="PROJECTION == 'NON'",

         METHODE         =SIMP(statut='f',typ='TXM',defaut="COLLOCATION",
                               into=("COLLOCATION","COUPLAGE",) ),

         regles=(UN_PARMI('MODELE_1','MAILLAGE_1'),
                 UN_PARMI('MODELE_2','MAILLAGE_2'),
                 ),
         MODELE_1        =SIMP(statut='f',typ=modele_sdaster),
         MAILLAGE_1      =SIMP(statut='f',typ=maillage_sdaster),

         MODELE_2        =SIMP(statut='f',typ=modele_sdaster),
         MAILLAGE_2      =SIMP(statut='f',typ=maillage_sdaster),


         # Cas de la projection COLLOCATION :
         #--------------------------------------------
         b_elem          =BLOC(condition="METHODE in ('COLLOCATION',)",
             CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",),
                  fr="Pour indiquer au programme le type de projection souhaité"),
             DISTANCE_MAX    =SIMP(statut='f',typ='R',
                  fr="Distance maximale entre le noeud et l'élément le plus proche, lorsque le noeud n'est dans aucun élément."),

             TRANSF_GEOM_1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_1 avant la projection."),
             TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                  fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                     " aux noeuds du MODELE_2 avant la projection."),

             ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),

         ),

         VIS_A_VIS       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT_1','GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   AU_MOINS_UN('TOUT_2','GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),),
           TOUT_1          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TOUT_2          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

           # les mots clés suivants ne sont actifs que si METHODE='COLLOCATION' mais on ne peut pas le vérifier:
               CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
               TRANSF_GEOM_1   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                    fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                       " aux noeuds du MODELE_1 avant la projection."),
               TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                    fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                       " aux noeuds du MODELE_2 avant la projection."),
         ),
     ), # fin bloc b_1



     #-----------------------------------------------------------------------------------------------------------
     # 3eme cas : on projette les champs avec une sd_corresp_2_mailla déjé calculée
     #-----------------------------------------------------------------------------------------------
     b_2   =BLOC(condition="MATR_PROJECTION != None",
         regles=(UN_PARMI('RESULTAT','CHAM_GD'),),
         RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),
         CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,cham_elem)),

         TYPE_CHAM       =SIMP(statut='f',typ='TXM',into=("NOEU",),
              fr="Pour forcer le type des champs projetés. NOEU -> cham_no"),

         NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster),
              fr="Parfois utile en dynamique pour pouvoir imposer la numérotation des cham_no."),

         # nécessaire si l'on projette des cham_elem :
         MODELE_2        =SIMP(statut='f',typ=modele_sdaster),

         PROL_ZERO       =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
              fr="Pour prolonger les champs par zéro là où la projection ne donne pas de valeurs."),



         # Cas de la projection d'une sd_resultat :
         #--------------------------------------------
         b_resultat      =BLOC(condition="RESULTAT != None",
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','LIST_INST','LIST_FREQ','LIST_ORDRE'),
                   EXCLUS('TOUT_CHAM','NOM_CHAM',),),

           NOM_PARA        =SIMP(statut='f',typ='TXM', max='**'),
           TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO(),),


           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),

           b_acce_reel     =BLOC(condition="(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                   PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                   PRECISION       =SIMP(statut='o',typ='R',),),
           ),

         ),
     ), # fin bloc b_2



     TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
     INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
def matr_asse_gene_prod(MATR_ASSE,MATR_ASSE_GENE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r  : return matr_asse_gene_r
  if AsType(MATR_ASSE_GENE) == matr_asse_gene_r  : return matr_asse_gene_r
  if AsType(MATR_ASSE) == matr_asse_depl_c  : return matr_asse_gene_c
  if AsType(MATR_ASSE_GENE) == matr_asse_gene_c  : return matr_asse_gene_c
  raise AsException("type de concept resultat non prevu")

PROJ_MATR_BASE=OPER(nom="PROJ_MATR_BASE",op=  71,sd_prod=matr_asse_gene_prod,
                    fr="Projection d'une matrice assemblée sur une base (modale ou de RITZ)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(UN_PARMI('MATR_ASSE','MATR_ASSE_GENE'),),            
         BASE            =SIMP(statut='o',typ=(mode_meca,mode_gene ) ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         MATR_ASSE       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c) ),
         MATR_ASSE_GENE  =SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: harinaivo.andriambololona at edf.fr
def proj_mesu_modal_prod(MODELE_MESURE,**args):
     vale=MODELE_MESURE['MESURE']
     if  AsType(vale) == dyna_trans   : return tran_gene
     if  AsType(vale) == dyna_harmo   : return harm_gene
     if  AsType(vale) == mode_meca    : return mode_gene
     if  AsType(vale) == mode_meca_c  : return mode_gene
#     if  AsType(vale) == base_modale  : return mode_gene
     raise AsException("type de concept resultat non prevu")

PROJ_MESU_MODAL=OPER(nom="PROJ_MESU_MODAL",op= 193,
                     sd_prod=proj_mesu_modal_prod,
                     reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
                     fr="Calcul des coordonnees généralisees de mesure experimentale relatives a une base de projection",

         MODELE_CALCUL   =FACT(statut='o',
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
#           BASE            =SIMP(statut='o',typ=(mode_meca,base_modale,) ),          
           BASE            =SIMP(statut='o',typ= mode_meca, ),
                         ),
         MODELE_MESURE   =FACT(statut='o',
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
#           MESURE          =SIMP(statut='o',typ=(dyna_trans,dyna_harmo,base_modale,mode_meca,mode_meca_c,) ),
           MESURE          =SIMP(statut='o',typ=(dyna_trans,dyna_harmo,mode_meca,mode_meca_c,) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE","ACCE",
                                 "SIEF_NOEU","EPSI_NOEU",),max='**'),
                         ),
         CORR_MANU       =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('NOEU_CALCUL','NOEU_MESURE'),),
           NOEU_CALCUL     =SIMP(statut='f',typ=no),
           NOEU_MESURE     =SIMP(statut='f',typ=no),
                         ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
         RESOLUTION      =FACT(statut='f',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="LU",into=("LU","SVD",) ),
           b_svd =BLOC(condition="METHODE=='SVD'",
                       EPS=SIMP(statut='f',typ='R',defaut=0. ),
                      ),
           REGUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","NORM_MIN","TIK_RELA",) ),
           b_regul =BLOC(condition="REGUL!='NON'",
                         regles=(PRESENT_ABSENT('COEF_PONDER','COEF_PONDER_F', ),),
                         COEF_PONDER   =SIMP(statut='f',typ='R',defaut=0.     ,max='**' ),  
                         COEF_PONDER_F =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
                        ),
             ),

          ); 

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: albert.alarcon at edf.fr

PROJ_RESU_BASE=OPER(nom="PROJ_RESU_BASE",op=  79,sd_prod=tran_gene,
                    fr="Projection d'une sd resultat assemblee sur une base (modale ou de RITZ)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         BASE            =SIMP(statut='o',typ=(mode_meca,mode_gene) ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
         RESU            =SIMP(statut='o',typ=dyna_trans),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
PROJ_SPEC_BASE=OPER(nom="PROJ_SPEC_BASE",op= 146,sd_prod=interspectre,reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
            fr="Projecter un ou plusieurs spectres de turbulence sur une (ou plusieurs) base(s) modale(s) ",
      regles=(UN_PARMI('BASE_ELAS_FLUI','MODE_MECA','CHAM_NO'),
              UN_PARMI('TOUT','GROUP_MA','MAILLE'),
              PRESENT_PRESENT('CHAM_NO','MODELE_INTERFACE'),),
         SPEC_TURB      =SIMP(statut='o',typ=spectre_sdaster,validators=NoRepeat(),max='**' ),
         TOUT_CMP       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         BASE_ELAS_FLUI =SIMP(statut='f',typ=melasflu_sdaster ),
         b_fluide = BLOC(condition="BASE_ELAS_FLUI !=None",
           VITE_FLUI      =SIMP(statut='o',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
         ),
         MODE_MECA      =SIMP(statut='f',typ=mode_meca ),
         CHAM_NO        =SIMP(statut='f',typ=cham_no_sdaster),
         FREQ_INIT      =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         FREQ_FIN       =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         NB_POIN        =SIMP(statut='o',typ='I' ),  
         OPTION         =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG")),
         TOUT           =SIMP(statut='f',typ='TXM',into=("OUI",), ),
         GROUP_MA       =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE         =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
#  Quel est le type attendu derriere  MODELE_INTERFACE         
         MODELE_INTERFACE=SIMP(statut='f',typ=modele_sdaster),
         VECT_X         =SIMP(statut='f',typ='R',min=3,max=3 ),
         VECT_Y         =SIMP(statut='f',typ='R',min=3,max=3 ),
         ORIG_AXE       =SIMP(statut='f',typ='R',min=3,max=3 ),  
         TITRE          =SIMP(statut='f',typ='TXM',max='**' ),  
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr

PROJ_VECT_BASE=OPER(nom="PROJ_VECT_BASE",op=  72,sd_prod=vect_asse_gene,
                    fr="Projection d'un vecteur assemblé sur une base (modale ou de RITZ)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE'),),              
         BASE            =SIMP(statut='o',typ=(mode_meca,mode_gene) ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
         VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
         VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr


def propa_fiss_prod(self,**args):
  if  args.has_key('MAIL_TOTAL')  :
      MAIL_TOTAL = args['MAIL_TOTAL']
      self.type_sdprod(MAIL_TOTAL,maillage_sdaster)
  if  args.has_key('MAIL_FISS')  :
      MAIL_FISS = args['MAIL_FISS']
      self.type_sdprod(MAIL_FISS,maillage_sdaster)
  if args.has_key('FISSURE') :
      FISSURE = args['FISSURE']
      for numfis in FISSURE :
        if (args['METHODE_PROPA']=='MAILLAGE') :
          self.type_sdprod(numfis['MAIL_PROPAGE'],maillage_sdaster)
        else :
          self.type_sdprod(numfis['FISS_PROPAGEE'],fiss_xfem)
  return None

PROPA_FISS=MACRO(nom="PROPA_FISS",
                 op=OPS('Macro.propa_fiss_ops.propa_fiss_ops'),
                 sd_prod=propa_fiss_prod,
                 fr="Propagation de fissure avec X-FEM",reentrant='n',
                 UIinfo={"groupes":("Post-traitements","Rupture",)},

        METHODE_PROPA = SIMP(statut='o',typ='TXM',
                               into=("SIMPLEXE","UPWIND","MAILLAGE","INITIALISATION","GEOMETRIQUE") ),

        b_hamilton = BLOC(condition="(METHODE_PROPA=='SIMPLEXE') or (METHODE_PROPA=='UPWIND') or (METHODE_PROPA=='GEOMETRIQUE') ",
              MODELE        = SIMP(statut='o',typ=modele_sdaster),
              TEST_MAIL     = SIMP(statut='f',typ='TXM',into=("NON","OUI",),defaut="NON"),
              DA_MAX        = SIMP(statut='o',typ='R',max=1,val_min=0.0),
              RAYON         = SIMP(statut='o',typ='R',),
              ZONE_MAJ      = SIMP(statut='f',typ='TXM',into=("TOUT","TORE"),defaut="TORE"),
              b_tore        = BLOC(condition = "ZONE_MAJ == 'TORE' ",
                                   RAYON_TORE    = SIMP(statut='f',typ='R',max=1,val_min=0.0),
                                  ),
              b_propagation = BLOC(condition = "TEST_MAIL == 'NON' ",
                                   FISSURE   = FACT(statut='o',min=1,max='**',
                                                    FISS_ACTUELLE  = SIMP(statut='o',typ=fiss_xfem,max=1),
                                                    FISS_PROPAGEE  = SIMP(statut='o',typ=CO,max=1),
                                                    NB_POINT_FOND  = SIMP(statut='f',typ='I',max='**',val_min=2),
                                                    TABLE          = SIMP(statut='o',typ=table_sdaster,max=1),
                                                    ),
                                   LOI_PROPA = FACT(statut='o',max=1,
                                                    LOI     = SIMP(statut='o',typ='TXM',into=("PARIS",),defaut="PARIS"),
                                                    b_paris = BLOC(condition = "LOI=='PARIS'",
                                                                   C = SIMP(statut='o',typ='R',),
                                                                   M = SIMP(statut='o',typ='R',),
                                                                  ),
                                                    MATER = SIMP(statut='o',typ=mater_sdaster,),
                                                   ),
                                   COMP_LINE = FACT(statut='o',max=1,
                                                    COEF_MULT_MINI = SIMP(statut='o',typ='R',),
                                                    COEF_MULT_MAXI = SIMP(statut='o',typ='R',),
                                                   ),
                                   CRIT_ANGL_BIFURCATION = SIMP(statut='f',typ='TXM',max=1,defaut="SITT_MAX",
                                                              into=('SITT_MAX','K1_MAX','K2_NUL','PLAN','ANGLE_IMPO'),),
                                   ),

              b_test_const  = BLOC(condition = "TEST_MAIL == 'OUI' ",
                                   FISSURE   = FACT(statut='o',min=1,max='**',
                                                    FISS_ACTUELLE  = SIMP(statut='o',typ=fiss_xfem,max=1),
                                                    FISS_PROPAGEE  = SIMP(statut='o',typ=CO,max=1),
                                                    ),
                                   ITERATIONS     = SIMP(statut='f',typ='I',max=1,val_min=3,defaut=5),
                                   TOLERANCE      = SIMP(statut='f',typ='R',max=1,val_min=0.0,val_max=100.0,defaut=5.0),
                                  ),

                         ),

        b_maillage    =BLOC(condition="(METHODE_PROPA=='MAILLAGE')",
               MAIL_STRUC       = SIMP(statut='o',typ=maillage_sdaster),
               ITERATION      = SIMP(statut='o',typ='I',max=1),
               DA_MAX        = SIMP(statut='o',typ='R',max=1),
               FISSURE   = FACT(statut='o',min=1,max='**',
                                MAIL_ACTUEL    = SIMP(statut='o',typ=maillage_sdaster,max=1),
                                GROUP_MA_FOND    = SIMP(statut='f',typ=grma,defaut="FOND"),
                                GROUP_MA_FISS    = SIMP(statut='f',typ=grma,defaut="FISS"),
                                FISS_ACTUELLE  = SIMP(statut='o',typ=fiss_xfem,max=1),
                                MAIL_PROPAGE  = SIMP(statut='f',typ=CO,max=1),
                                TABLE          = SIMP(statut='o',typ=table_sdaster,max=1),
                                                    ),
               MAIL_TOTAL        = SIMP(statut='o',typ=CO),
               LOI_PROPA = FACT(statut='o',max=1,
                                LOI     = SIMP(statut='o',typ='TXM',into=("PARIS",),defaut="PARIS"),
                                b_paris = BLOC(condition = "LOI=='PARIS'",
                                               C = SIMP(statut='o',typ='R',),
                                               M = SIMP(statut='o',typ='R',),
                                              ),
                                MATER = SIMP(statut='o',typ=mater_sdaster,),
                                                   ),
               COMP_LINE = FACT(statut='o',max=1,
                                COEF_MULT_MINI = SIMP(statut='o',typ='R',),
                                COEF_MULT_MAXI = SIMP(statut='o',typ='R',),
                                                   ),
               CRIT_ANGL_BIFURCATION = SIMP(statut='f',typ='TXM',max=1,defaut="SITT_MAX",
                                                into=('SITT_MAX','K1_MAX','K2_NUL','PLAN','ANGLE_IMPO'),),
                                ),

        b_init    =BLOC(condition="(METHODE_PROPA=='INITIALISATION')",
               MAIL_STRUC    = SIMP(statut='o',typ=maillage_sdaster),
               FORM_FISS   = SIMP(statut='o',typ='TXM', into=("DEMI_DROITE","DEMI_PLAN","ELLIPSE"), ),
               GROUP_MA_FOND    = SIMP(statut='f',typ=grma,defaut="FOND"),
               GROUP_MA_FISS    = SIMP(statut='f',typ=grma,defaut="FISS"),
               MAIL_TOTAL     = SIMP(statut='o',typ=CO),
               MAIL_FISS       = SIMP(statut='f',typ=CO),

               b_droite = BLOC(condition = "FORM_FISS == 'DEMI_DROITE' ",
                  PFON        = SIMP(statut='o',typ='R',max=3),
                  DTAN        = SIMP(statut='o',typ='R',min=3,max=3),
               ),

               b_plan = BLOC(condition = "FORM_FISS == 'DEMI_PLAN' ",
                  DTAN        = SIMP(statut='o',typ='R',min=3,max=3),
                  POINT_ORIG        = SIMP(statut='o',typ='R',min=3,max=3),
                  POINT_EXTR        = SIMP(statut='o',typ='R',min=3,max=3),
                  NB_POINT_FOND     = SIMP(statut='o',typ='I',),
               ),

               b_ellipse = BLOC(condition = "FORM_FISS == 'ELLIPSE' ",
                  CENTRE         =SIMP(statut='o',typ='R',min=3,max=3),
                  DEMI_GRAND_AXE =SIMP(statut='o',typ='R',val_min=0.E+0),
                  DEMI_PETIT_AXE =SIMP(statut='o',typ='R',val_min=0.E+0),
                  VECT_X         =SIMP(statut='o',typ='R',min=3,max=3),
                  VECT_Y         =SIMP(statut='o',typ='R',min=3,max=3),
                  ANGLE_ORIG        = SIMP(statut='o',typ='R',),
                  ANGLE_EXTR        = SIMP(statut='o',typ='R',),
                  NB_POINT_FOND     = SIMP(statut='o',typ='I',)
               ),
             ),

        INFO = SIMP(statut='f',typ='I',defaut=1,into=(0,1,2)),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

PROPA_XFEM=OPER(nom="PROPA_XFEM",op=10,sd_prod=fiss_xfem,reentrant='n',
                UIinfo={"groupes":("Post-traitements","Rupture",)},
                fr="Propagation de fissure avec X-FEM",
    
    MODELE        =SIMP(statut='o',typ=modele_sdaster),

    TEST_MAIL     =SIMP(statut='f',typ='TXM',into=("NON","OUI",),defaut="NON"),

    DA_MAX        =SIMP(statut='o',typ='R'),

    FISS_PROP     =SIMP(statut='o',typ=fiss_xfem),

    ZONE_MAJ      =SIMP(statut='f',typ='TXM',into=("TOUT","TORE"),defaut="TORE"),

    RAYON_TORE    =SIMP(statut='f',typ='R'),

    LISTE_FISS    =SIMP(statut='o',typ=fiss_xfem,min=1,max='**'),

    ANGLE         =SIMP(statut='f',typ='R',max='**'),
    VITESSE       =SIMP(statut='f',typ='R',max='**'),
    DA_FISS       =SIMP(statut='f',typ='R'),
    NB_CYCLES     =SIMP(statut='f',typ='R'),        

    b_test_mail_const =BLOC( condition = "TEST_MAIL == 'OUI' ",
                             FISS_INITIALE =SIMP(statut='o',typ=fiss_xfem,max=1),
                             DISTANCE      =SIMP(statut='o',typ='R',max=1),
                             TOLERANCE     =SIMP(statut='o',typ='R',max=1),
                           ),
            
    RAYON          =SIMP(statut='o',typ='R',),
          
    METHODE =SIMP(statut='f',typ='TXM',into=("SIMPLEXE","UPWIND","GEOMETRIQUE"),defaut="UPWIND"),

    INFO           =SIMP(statut='f',typ='I',defaut= 0,into=(0,1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: renaud.bargellini at edf.fr

RAFF_GP =MACRO(nom="RAFF_GP",
                   op=OPS('Macro.raff_gp_ops.raff_gp_ops'),
                   sd_prod=maillage_sdaster,
                   UIinfo={"groupes":("Outils-métier","Rupture",)},
                   reentrant='n',
                   fr="Preparation du maillage pour calcul du Gp en 2D",
         MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),           
         TRANCHE_2D  = FACT(statut='0',max = 1,
                           CENTRE           =SIMP(statut='o',typ='R',max=2),
                           RAYON       =SIMP(statut='o',typ='R',max=1),
                           ANGLE            =SIMP(statut='o',typ='R',max=1),
                           TAILLE          =SIMP(statut='o',typ='R',max=1),
                           NB_ZONE        =SIMP(statut='o',typ='I',),
                             ),
         NB_RAFF      = SIMP(statut='f',typ='I',defaut=4),         
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

# determination du type de sd produite par la commande
def raff_xfem_prod(self,TYPE,**args):
  if TYPE == 'DISTANCE' :
     return cham_no_sdaster
  elif TYPE == 'ZONE' :
     return carte_sdaster
  else :
     raise AsException("type de concept non prevu")


RAFF_XFEM=MACRO(nom="RAFF_XFEM",
                op=OPS('Macro.raff_xfem_ops.raff_xfem_ops'),
                sd_prod=raff_xfem_prod,
                fr="Calcul d'un indicateur pour le raffinement",
                reentrant='n',
                UIinfo={"groupes":("Résultats et champs","Rupture",)},

                TYPE   =SIMP(statut='f',typ='TXM',into=('DISTANCE','ZONE'),defaut='DISTANCE'),
                FISSURE=SIMP(statut='o',typ=fiss_xfem,min=1,max='**',),

                b_zone =BLOC(condition = "TYPE == 'ZONE' ",fr="Paramètres de la zone",
                   RAYON =SIMP(statut='o',typ='R',val_min=0.),
                            ),
                
                )  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: samuel.geniaut at edf.fr

# commande cachee appelee uniquement par la macro RAFF_XFEM

RAFF_XFEM_ZONE=OPER(nom="RAFF_XFEM_ZONE",
                    op=188,
#                    sd_prod=cham_elem,
                    sd_prod=carte_sdaster,
                    fr="Calcul d'un indicateur binaire pour le raffinement",
                    reentrant='n',
                    UIinfo={"groupes":("Résultats et champs","Rupture",)},

                    FISSURE=SIMP(statut='o',typ=fiss_xfem,min=1,max=1),
                    RAYON  =SIMP(statut='o',typ='R',val_min=0.),                

                    )  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: aurore.parrot at edf.fr
RECA_WEIBULL=OPER(nom="RECA_WEIBULL",op= 197,sd_prod=table_sdaster,
                     fr="Recaler les paramètres du modèle de WEIBULL sur des données expérimentales",reentrant='n',
            UIinfo={"groupes":("Post-traitements",)},
         LIST_PARA       =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=2,into=("SIGM_REFE","M",) ),
         RESU            =FACT(statut='o',max='**',
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST',),
                   AU_MOINS_UN('TOUT','GROUP_MA','MAILLE', ),),
           EVOL_NOLI       =SIMP(statut='o',typ=(evol_noli) ),
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
           CHAM_MATER      =SIMP(statut='o',typ=(cham_mater) ),
           TEMPE           =SIMP(statut='f',typ='R' ),
           LIST_INST_RUPT  =SIMP(statut='o',typ='R',validators=NoRepeat(),max='**' ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut= 1.E0 ),
                         ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="SIGM_ELGA",into=("SIGM_ELGA","SIGM_ELMOY",) ),
         CORR_PLAST      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MAXI_VRAI",into=("MAXI_VRAI","REGR_LINE",) ),
         INCO_GLOB_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ,) ),
                       )  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
def recu_fonction_prod(RESULTAT=None,TABLE=None,RESU_GENE=None,
                       BASE_ELAS_FLUI=None,CHAM_GD=None,NAPPE=None,
                       INTE_SPEC=None,NOEUD_J=None,NUME_ORDRE_J=None,
                       NOM_CMP_J=None,NOM_CMP_I=None,NUME_ORDRE_I=None,NOEUD_I=None,
                       NOM_PARA_TABL=None,**args):
   if AsType(RESULTAT)  == dyna_harmo or \
      AsType(RESU_GENE) == harm_gene or \
      (INTE_SPEC and NUME_ORDRE_J and (NUME_ORDRE_I != NUME_ORDRE_J) ) or \
      (INTE_SPEC and NOEUD_J and ((NOEUD_I != NOEUD_J) or (NOM_CMP_I != NOM_CMP_J)) ) or \
      (TABLE != None and NOM_PARA_TABL == "FONCTION_C"):
      return fonction_c
   else:
      return fonction_sdaster

RECU_FONCTION=OPER(nom="RECU_FONCTION",op=90,sd_prod=recu_fonction_prod,
                   fr="Extraire sous forme d'une fonction, l'évolution d'une grandeur en fonction d'une autre",
                   reentrant='f',
            UIinfo={"groupes":("Résultats et champs","Fonctions",)},
         regles=(UN_PARMI('CHAM_GD','RESULTAT','RESU_GENE','TABLE','BASE_ELAS_FLUI','NAPPE','INTE_SPEC'),),

         CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,cham_elem,),),
         RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),
         RESU_GENE       =SIMP(statut='f',typ=(tran_gene, mode_gene, harm_gene)),
         TABLE           =SIMP(statut='f',typ=(table_sdaster,table_fonction)),
         BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster),
         NAPPE           =SIMP(statut='f',typ=nappe_sdaster),
         INTE_SPEC       =SIMP(statut='f',typ=interspectre),

# ======= ACCES A LA SD RESULTAT =================================================
         b_acces = BLOC ( condition = "(RESULTAT != None) or (RESU_GENE != None)",
                          fr="acces a une SD résultat",
# on ne peut pas mettre de regles, le défaut TOUT_ORDRE est pris en compte dans le fortran
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
           TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           b_prec = BLOC ( condition = "(INST != None) or (LIST_INST != None) or (FREQ != None) or (LIST_FREQ != None)",
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
             INTERP_NUME     =SIMP(statut='f',typ='TXM',into=("NON","LIN") ),
           ),
         ),
# ======= BASE_ELAS_FLUI =================================================
         b_base_elas_flui = BLOC ( condition = "BASE_ELAS_FLUI != None",
                                   fr="Récupération de la fonction à partir d un concept melasflu",
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE'),),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE       =SIMP(statut='o',typ='I' ),
           PARA_X          =SIMP(statut='o',typ='TXM',into=("VITE_FLU",) ),
           PARA_Y          =SIMP(statut='o',typ='TXM',into=("FREQ","AMOR") ),
         ),

# ======= INTERSPECTRE =================================================
         b_inte_spec = BLOC ( condition = "INTE_SPEC != None",
                              fr="Récupération de fonction dans un concept interspectre",
           regles=(UN_PARMI('NUME_ORDRE_I','NOEUD_I'),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
           NOEUD_I         =SIMP(statut='f',typ=no,max=1),
           NUME_ORDRE_I    =SIMP(statut='f',typ='I',max=1 ),
           b_nume_ordre_i = BLOC (condition = "NUME_ORDRE_I != None",
             NUME_ORDRE_J    =SIMP(statut='f',typ='I',max=1 ),
           ),
           b_noeud_i = BLOC (condition = "NOEUD_I != None",
             NOEUD_J         =SIMP(statut='f',typ=no,max=1),
             NOM_CMP_I       =SIMP(statut='o',typ='TXM',max=1 ),
             NOM_CMP_J       =SIMP(statut='f',typ='TXM',max=1 ),
           ),
         ),

# ======= TABLE =================================================
         b_table = BLOC ( condition = "TABLE != None",
                          fr="Récupération de la fonction à partir d un concept table",
                          regles=(UN_PARMI('PARA_X','NOM_PARA_TABL'),
                                  PRESENT_PRESENT('PARA_X','PARA_Y'),),
           PARA_X        = SIMP(statut='f',typ='TXM',
                                 fr="1ère colonne de la table qui définit la fonction à récupérer", ),
           PARA_Y        = SIMP(statut='f',typ='TXM',
                                 fr="2ème colonne de la table qui définit la fonction à récupérer", ),
           #b_tabl_fonc = BLOC(condition = "AsType(TABLE) == table_fonction",
           NOM_PARA_TABL = SIMP(statut='f',typ='TXM',into=("FONCTION","FONCTION_C"),
                                fr="Nom du paramètre de la table contenant la fonction" ),
           #),

           FILTRE        = FACT(statut='f',max='**',
              NOM_PARA        =SIMP(statut='o',typ='TXM' ),
              CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                    into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                          "NON_VIDE","MAXI","MAXI_ABS","MINI","MINI_ABS") ),
              b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
                 regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
                 VALE            =SIMP(statut='f',typ='R' ),
                 VALE_I          =SIMP(statut='f',typ='I' ),
                 VALE_C          =SIMP(statut='f',typ='C' ),
                 VALE_K          =SIMP(statut='f',typ='TXM' ),),

              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
         ),

# ======= RESULTAT =================================================
         b_resu = BLOC ( condition = "RESULTAT != None", fr="Opérandes en cas de RESULTAT",
                         regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
           NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
           b_cham = BLOC ( condition = "NOM_CHAM != None",
                           regles=(AU_MOINS_UN('MAILLE','GROUP_MA','GROUP_NO','NOEUD'),
                                   PRESENT_ABSENT('POINT','NOEUD','GROUP_NO'),
                                   PRESENT_ABSENT('SOUS_POINT','NOEUD','GROUP_NO'),
                                   EXCLUS('GROUP_MA','MAILLE'),
                                   EXCLUS('GROUP_NO','NOEUD'),),
             NOM_CMP         =SIMP(statut='o',typ='TXM' ),
             MAILLE          =SIMP(statut='f',typ=ma),
             GROUP_MA        =SIMP(statut='f',typ=grma),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
             POINT           =SIMP(statut='f',typ='I' ),
             SOUS_POINT      =SIMP(statut='f',typ='I' ),
           ),
         ),

# ======= RESU_GENE =================================================
         b_tran_gene = BLOC ( condition = "AsType(RESU_GENE) == tran_gene",
                              fr="Récupération d'une fonction à partir d un concept TRAN_GENE",
                              regles=(UN_PARMI('NOM_CHAM','NOEUD_CHOC','GROUP_NO_CHOC'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=("DEPL","VITE","ACCE","PTEM") ),
             NOEUD_CHOC      =SIMP(statut='f',typ=no),
             GROUP_NO_CHOC   =SIMP(statut='f',typ=grno),
           b_cham = BLOC ( condition = "(NOM_CHAM=='DEPL') or (NOM_CHAM=='VITE') or (NOM_CHAM=='ACCE')",
                           regles=(UN_PARMI('GROUP_NO','NOEUD','NUME_CMP_GENE',),
                                   UN_PARMI('NOM_CMP','NUME_CMP_GENE',),
                                   EXCLUS('MULT_APPUI','CORR_STAT'),),
             NOM_CMP         =SIMP(statut='f',typ='TXM' ),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
             MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             ACCE_MONO_APPUI =SIMP(statut='f',typ=(fonction_sdaster,formule)),
           ),
           b_choc = BLOC ( condition = "(NOEUD_CHOC != None) or (GROUP_NO_CHOC != None)",
                           regles=(PRESENT_PRESENT('SOUS_STRUC','INTITULE'),),
             PARA_X          =SIMP(statut='o',typ='TXM',
                              into=("INST","FN","FT1","FT2","VN","VT1","VT2","DXLOC","DYLOC","DZLOC") ),
             PARA_Y          =SIMP(statut='o',typ='TXM',
                              into=("INST","FN","FT1","FT2","VN","VT1","VT2","DXLOC","DYLOC","DZLOC") ),
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
             INTITULE        =SIMP(statut='f',typ='TXM' ),
             SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           ),
         ),
         b_harm_gene = BLOC ( condition = "AsType(RESU_GENE)==harm_gene",
                              fr="Récupération d'une fonction à partir d un concept HARM_GENE",
                              regles=(UN_PARMI('NOM_CMP','NUME_CMP_GENE'),
                                      UN_PARMI('GROUP_NO','NOEUD','NUME_CMP_GENE',),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=("DEPL","VITE","ACCE") ),
             NOM_CMP         =SIMP(statut='f',typ='TXM' ),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
         ),
         # b_harm_gene = BLOC ( condition = "AsType(RESU_GENE)==harm_gene",
         #                      fr="Récupération d'une fonction à partir d un concept HARM_GENE",
         #                      regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
         #     NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
         #     NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
         #   b_cham = BLOC ( condition = "NOM_CHAM != None",
         #                   regles=(UN_PARMI('NUME_CMP_GENE','NOM_CMP'),),
         #     NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
         #     NOM_CMP         =SIMP(statut='f',typ='TXM' ),
         #     b_cmp = BLOC ( condition = "NOM_CMP != None",
         #                    regles=(UN_PARMI('NOEUD','GROUP_NO'),),
         #       NOEUD         =SIMP(statut='f',typ=no),
         #       GROUP_NO      =SIMP(statut='f',typ=grno),
         #     ),
         #   ),
         # ),
         b_mode_gene = BLOC ( condition = "AsType(RESU_GENE)==mode_gene",
                              fr="Récupération d'une fonction à partir d un concept MODE_GENE",
                              regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
             NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
           b_cham = BLOC ( condition = "NOM_CHAM != None",
                           regles=(UN_PARMI('NUME_CMP_GENE','NOM_CMP'),),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
             NOM_CMP         =SIMP(statut='f',typ='TXM' ),
             b_cmp = BLOC ( condition = "NOM_CMP != None",
                            regles=(UN_PARMI('NOEUD','GROUP_NO'),
                                    UN_PARMI('SQUELETTE','SOUS_STRUC'),),
               NOEUD         =SIMP(statut='f',typ=no),
               GROUP_NO      =SIMP(statut='f',typ=grno),
               SQUELETTE     =SIMP(statut='f',typ=squelette ),
               SOUS_STRUC    =SIMP(statut='f',typ='TXM' ),  
             ),
           ),
         ),

# ======= CHAM_GD =================================================
         b_cham_gd = BLOC ( condition = "(CHAM_GD != None)", fr="Opérandes en cas de CHAM_GD",
                            regles=(AU_MOINS_UN('MAILLE','GROUP_MA','GROUP_NO','NOEUD'),
                                    PRESENT_ABSENT('POINT','NOEUD','GROUP_NO'),
                                    PRESENT_ABSENT('SOUS_POINT','NOEUD','GROUP_NO'),
                                    EXCLUS('GROUP_MA','MAILLE'),
                                    EXCLUS('GROUP_NO','NOEUD'),),
           NOM_CMP         =SIMP(statut='o',typ='TXM' ),
           MAILLE          =SIMP(statut='f',typ=ma),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           POINT           =SIMP(statut='f',typ='I' ),
           SOUS_POINT      =SIMP(statut='f',typ='I' ),
         ),

# ======= NAPPE =================================================
         b_nappe = BLOC ( condition = "(NAPPE != None)", fr="Opérandes en cas de NAPPE",
         VALE_PARA_FONC  =SIMP(statut='o',typ='R' ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),

# ======= SURCHARGE DES ATTRIBUTS =================================================
         NOM_PARA        =SIMP(statut='f',typ='TXM', into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: emmanuel.boyere at edf.fr
RECU_GENE=OPER(nom="RECU_GENE",op=  76,sd_prod=vect_asse_gene,reentrant='n',
               UIinfo={"groupes":("Résultats et champs",)},
               fr="Extraire d'un champ de grandeur (déplacements, vitesses ou accélérations) à partir de résultats"
                  +" en coordonnées généralisées",
               regles=(UN_PARMI('FREQ','INST',),),
         RESU_GENE       =SIMP(statut='o',typ=(tran_gene,harm_gene),),
         INST            =SIMP(statut='f',typ='R',),
         FREQ            =SIMP(statut='f',typ='R',),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE","ACCE",),),
         b_interp_temp=BLOC(condition="INST != None and FREQ == None",
             INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN",),),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: nicolas.greffet at edf.fr
#
# RECUPERATION DE PARAMETRES DE COUPLAGE VIA YACS
# 
RECU_PARA_YACS=OPER(nom="RECU_PARA_YACS",op=114,sd_prod=listr8_sdaster,
                   reentrant = 'n',
                    UIinfo={"groupes":("Fonction",)},
                   fr        = "Gestion des scalaires via YACS pour le coupleur IFS",
          DONNEES = SIMP(statut='o',typ='TXM',into=("INITIALISATION","CONVERGENCE","FIN","PAS",) ),
          b_init   = BLOC(condition= "DONNEES=='INITIALISATION'",
                     PAS             = SIMP(statut='o',typ='R', ),),
          b_noinit = BLOC(condition= "(DONNEES=='CONVERGENCE')or(DONNEES=='FIN')",
                     NUME_ORDRE_YACS = SIMP(statut='o', typ='I',),
                     INST         = SIMP(statut='o',typ='R', ),
                     PAS             = SIMP(statut='o',typ='R', ),),
          b_pastps = BLOC(condition= "(DONNEES=='PAS')",
                     NUME_ORDRE_YACS = SIMP(statut='o', typ='I',),
                     INST         = SIMP(statut='o',typ='R', ),
                     PAS             = SIMP(statut='o',typ='R', ),),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
);

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
RECU_TABLE=OPER(nom="RECU_TABLE",op= 174,sd_prod=table_sdaster,
         fr="Récupérer dans une table les valeurs d'un paramètre d'une SD Résultat ou d'extraire une table contenue"
            +" dans une autre SD pour celles qui le permettent",
         UIinfo={"groupes":("Résultats et champs","Tables",)},reentrant='n',
         CO              =SIMP(statut='o',typ=assd),
         regles=(UN_PARMI('NOM_TABLE','NOM_PARA')),
         NOM_TABLE       =SIMP(statut='f',typ='TXM' ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jacques.pellet at edf.fr

RESOUDRE=OPER(nom="RESOUDRE",op=15,sd_prod=cham_no_sdaster,reentrant='f',
               fr="Résolution par méthode directe un système d'équations linéaires préalablement factorisé par FACT_LDLT"+
                  "ou Résolution d'un système linéaire par la méthode du gradient conjugué préconditionné",
               UIinfo={"groupes":("Résolution",)},
         MATR           =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),
         CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
         CHAM_CINE       =SIMP(statut='f',typ=cham_no_sdaster),

         # mot-clé commun aux solveurs MUMPS, GCPC et PETSc:
         RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6),

         # mot-clé pour les posttraitements de la phase de solve de MUMPS
         POSTTRAITEMENTS =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO","FORCE")),

         # mot-clé commun aux solveurs GCPC et PETSc:
         NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
         MATR_PREC       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r ) ),

         # mots-clés pour solveur PETSc:
         ALGORITHME      =SIMP(statut='f',typ='TXM',into=("CG", "CR", "GMRES", "GCR", ),defaut="GMRES" ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
 
# person_in_charge: Georges-cc.devesa at edf.fr
def rest_cond_tran_prod(RESULTAT,TYPE_RESU,**args ):
 
  if AsType(RESULTAT) == dyna_trans  : return dyna_trans
  if (AsType(RESULTAT) == evol_noli and TYPE_RESU == "DYNA_TRANS") : return dyna_trans
  if (AsType(RESULTAT) == evol_noli and TYPE_RESU == "EVOL_NOLI") : return evol_noli

  raise AsException("type de concept resultat non prevu")

REST_COND_TRAN=OPER(nom="REST_COND_TRAN",op=  78,sd_prod=rest_cond_tran_prod,
                    fr="Restituer dans la base physique des résultats issus d'un calcul" 
                        +"non-lineaire avec projection modale ou d'un calcul transitoire linear"
                        +"avec condensation dynamique",
                    reentrant='f',
            UIinfo={"groupes":("Matrices et vecteurs",)},
        regles=(
                EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','TOUT_INST'),
                EXCLUS('MACR_ELEM_DYNA','BASE_MODALE'),),
         RESULTAT        =SIMP(statut='f',typ=(evol_noli,dyna_trans) ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNA_TRANS",
                          into=("DYNA_TRANS","EVOL_NOLI") ),
         BASE_MODALE     =SIMP(statut='f',typ=mode_meca),
#         NUME_DDL        =SIMP(statut='f',typ=nume_ddl_sdaster ),
         MACR_ELEM_DYNA  =SIMP(statut='f',typ=macr_elem_dyna),
         TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("ABSOLU","RELATIF") ),
         b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
         b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION       =SIMP(statut='o',typ='R',),),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN") ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         b_nom_cham=BLOC(condition="TOUT_CHAM == None",
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,defaut="ACCE",into=("DEPL",
                                   "VITE","ACCE",),),),
         b_base_moda=BLOC(condition="BASE_MODALE != None",
             CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
             CARA_ELEM       =SIMP(statut='f',typ=cara_elem),),
             RESU_FINAL      =SIMP(statut='f',typ=(evol_noli,dyna_trans) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# person_in_charge: emmanuel.boyere at edf.fr

def rest_gene_phys_prod(RESU_GENE,**args ):
  if AsType(RESU_GENE) == tran_gene : return dyna_trans
  if AsType(RESU_GENE) == mode_gene : return mode_meca
  if AsType(RESU_GENE) == harm_gene : return dyna_harmo
  
  raise AsException("type de concept resultat non prevu")

REST_GENE_PHYS=OPER(nom="REST_GENE_PHYS",op=  75,sd_prod=rest_gene_phys_prod,
                    fr="Restituer dans la base physique des résultats en coordonnées généralisées",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
        regles=(
                EXCLUS('INST','LIST_INST','TOUT_INST',
                       'TOUT_ORDRE','NUME_ORDRE','NUME_MODE',),
                EXCLUS('FREQ','LIST_FREQ'),
                EXCLUS('MULT_APPUI','CORR_STAT'),
                EXCLUS('MULT_APPUI','NOEUD','GROUP_NO'),
                EXCLUS('CORR_STAT','NOEUD','GROUP_NO'),             
                EXCLUS('NOEUD','GROUP_NO'),
                EXCLUS('MAILLE','GROUP_MA'),
                PRESENT_PRESENT('ACCE_MONO_APPUI','DIRECTION'),),
         RESU_GENE       =SIMP(statut='f',typ=(tran_gene,mode_gene,harm_gene) ), 
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         NUME_DDL        =SIMP(statut='f',typ=nume_ddl_sdaster ),
         TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ), 
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),  
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ), 
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("ABSOLU","RELATIF") ),
         b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
         b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION       =SIMP(statut='o',typ='R',),),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN") ),
         MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         b_nom_cham=BLOC(condition="TOUT_CHAM == None",
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=8,defaut="ACCE",into=("DEPL",
                                   "VITE","ACCE","ACCE_ABSOLU","EFGE_ELNO","SIPO_ELNO","SIGM_ELNO","FORC_NODA",),),),
         GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         ACCE_MONO_APPUI =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         DIRECTION       =SIMP(statut='f',typ='R',min=3,max=3 ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
def rest_mode_nonl_prod(TYPE_RESU,**args):
    if TYPE_RESU == 'DYNA_TRANS' : return dyna_trans
    elif TYPE_RESU == 'MODE_MECA' : return mode_meca
    raise AsException("type de concept resultat non prevu")

REST_MODE_NONL=OPER(nom="REST_MODE_NONL", op=63,
         sd_prod=rest_mode_nonl_prod, reentrant='n',
         fr="Post traitement de mode_non_line : \
             recuperation resultats ",
         UIinfo={"groupes":("Post-traitements",)},

         MODE_NON_LINE    =SIMP(statut='o',typ=table_container,max=1),
         TYPE_RESU    =SIMP(statut='o',typ='TXM',into=('MODE_MECA','DYNA_TRANS'),defaut='DYNA_TRANS',max=1),
         NUME_ORDRE      =SIMP(statut='o',typ='I',max=1),
         b_dyna_trans  =BLOC(condition="TYPE_RESU=='DYNA_TRANS'",
                NB_INST =SIMP(statut='f',typ='I',max=1,defaut=512),),
         INFO          =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;



# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# person_in_charge: mathieu.corus at edf.fr
def rest_sous_struc_prod(RESU_GENE,RESULTAT,**args ):
  if AsType(RESU_GENE) == tran_gene : return dyna_trans
  if AsType(RESU_GENE) == mode_gene : return mode_meca
  if AsType(RESU_GENE) == mode_cycl : return mode_meca
  if AsType(RESU_GENE) == harm_gene : return dyna_harmo
  if AsType(RESULTAT)  == evol_noli      : return evol_noli
  if AsType(RESULTAT)  == dyna_trans     : return dyna_trans
  if AsType(RESULTAT)  == mode_meca      : return mode_meca
  raise AsException("type de concept resultat non prevu")

REST_SOUS_STRUC=OPER(nom="REST_SOUS_STRUC",op=  77,sd_prod=rest_sous_struc_prod,
          fr="Restituer dans la base physique des résultats obtenus par sous-structuration",
                    reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
        regles=(UN_PARMI('RESU_GENE','RESULTAT'),
# ajout d'une regle de Ionel et Nicolas:
#                UN_PARMI('NOM_CHAM','TOUT_CHAM'),
#
              EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','TOUT_INST','NUME_MODE',
                     'FREQ', 'LIST_FREQ'),
#  Doc U à revoir
              EXCLUS('NOEUD','GROUP_NO'),
              EXCLUS('MAILLE','GROUP_MA'),
              PRESENT_PRESENT('RESULTAT','SQUELETTE'),
              UN_PARMI('SQUELETTE','SOUS_STRUC','SECTEUR'),

                ),
         RESULTAT        =SIMP(statut='f',typ=(evol_noli,dyna_trans,
                                            mode_meca) ),
         RESU_GENE       =SIMP(statut='f',typ=(tran_gene,mode_gene,mode_cycl,harm_gene) ),
         NUME_DDL        =SIMP(statut='f',typ=nume_ddl_sdaster ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),  
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),  
         TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("ABSOLU","RELATIF") ),
         b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
         b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
             PRECISION       =SIMP(statut='o',typ='R',),),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN") ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         b_nom_cham=BLOC(condition="TOUT_CHAM == None",
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=8,defaut="ACCE",into=("DEPL",
                                   "VITE","ACCE","ACCE_ABSOLU","EFGE_ELNO","SIPO_ELNO","SIGM_ELNO","FORC_NODA",) ),),
         GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         CYCLIQUE    =FACT(statut='f',max='**',
           NB_SECTEUR      =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           NUME_DIAMETRE    =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           RESULTAT2       =SIMP(statut='f',typ=(evol_elas,evol_noli,dyna_trans,evol_char,
                                               mode_meca) ),
         ),

         SQUELETTE       =SIMP(statut='f',typ=squelette ),
         SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),  
         SECTEUR         =SIMP(statut='f',typ='I'),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: andre.adobes at edf.fr
REST_SPEC_PHYS=OPER(nom="REST_SPEC_PHYS",op= 148,sd_prod=interspectre,
                    reentrant='n',
            fr="Calculer la réponse d'une structure dans la base physique",
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=(AU_MOINS_UN('BASE_ELAS_FLUI','MODE_MECA'),),        
         BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
         b_fluide = BLOC(condition="BASE_ELAS_FLUI !=None",
           VITE_FLUI      =SIMP(statut='o',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
         ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca,),
         BANDE           =SIMP(statut='f',typ='R',min=2,validators=NoRepeat(),max=2    ),  
         NUME_ORDRE      =SIMP(statut='f',typ='I'      ,validators=NoRepeat(),max='**' ),
         TOUT_ORDRE       =SIMP(statut='f',typ='TXM',defaut="NON",  into=("OUI","NON")  ),
         INTE_SPEC_GENE  =SIMP(statut='o',typ=interspectre),
         NOEUD           =SIMP(statut='o',typ=no   ,max='**'),
         MAILLE          =SIMP(statut='f',typ=ma   ,max='**'),
         NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),  
         NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=7,into=("DEPL",
                               "VITE","ACCE","EFGE_ELNO","SIPO_ELNO","SIGM_ELNO","FORC_NODA") ),
         MODE_STAT       =SIMP(statut='f',typ=mode_meca ),
         EXCIT           =FACT(statut='f',
           NOEUD           =SIMP(statut='o',typ=no   ,max='**'),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),  
         ),
         MOUVEMENT       =SIMP(statut='f',typ='TXM',defaut="ABSOLU",into=("RELATIF","ABSOLU","DIFFERENTIEL") ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="DIAG_DIAG",    
                               into=("DIAG_TOUT","DIAG_DIAG","TOUT_TOUT","TOUT_DIAG") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: Georges-cc.devesa at edf.fr
def rest_spec_temp_prod(RESU_GENE,RESULTAT,**args):
  if AsType(RESULTAT) == dyna_harmo    : return dyna_trans
  if AsType(RESU_GENE) == harm_gene    : return tran_gene
  if AsType(RESULTAT) == dyna_trans    : return dyna_harmo
  if AsType(RESU_GENE) == tran_gene    : return harm_gene
  raise AsException("type de concept resultat non prevu")


REST_SPEC_TEMP=OPER(nom="REST_SPEC_TEMP",op=181,sd_prod=rest_spec_temp_prod,
              fr="Transformée de Fourier d'un résultat",
              reentrant='n',
            UIinfo={"groupes":("Matrices et vecteurs",)},
         regles=UN_PARMI('RESU_GENE','RESULTAT'),
         RESU_GENE       =SIMP(statut='f',typ=(harm_gene,tran_gene,) ),
         RESULTAT        =SIMP(statut='f',typ=(dyna_harmo,dyna_trans,) ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="PROL_ZERO",into=("PROL_ZERO","TRONCATURE") ),
         SYMETRIE        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",)),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,into=("DEPL","VITE","ACCE") ),
);

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix at edf.fr


SIMU_POINT_MAT=MACRO(nom="SIMU_POINT_MAT",
                     op=OPS('Macro.simu_point_mat_ops.simu_point_mat_ops'),
                     sd_prod=table_sdaster,
                     UIinfo={"groupes":("Résolution",)},
                     fr="Calcul de l'évolution mécanique, en quasi-statique," \
                        " d'un point matériel en non linéaire",
   COMPORTEMENT       =C_COMPORTEMENT(),
   MATER           =SIMP(statut='o',typ=mater_sdaster,max=30),

## ANGLE : rotation de ANGLE autour de Z uniquement, et seulement pour les déformations imposées.
   ANGLE      =SIMP(statut='f',typ='R',max=1, defaut=0.),
# --MASSIF : orientation du materiau (monocristal, orthotropie)
   MASSIF          =FACT(statut='f',max='**',
     regles=(UN_PARMI('ANGL_REP','ANGL_EULER'),),
     ANGL_REP        =SIMP(statut='f',typ='R',min=1,max=3),
     ANGL_EULER      =SIMP(statut='f',typ='R',min=1,max=3),
   ),
   INCREMENT       =C_INCREMENT('MECANIQUE'),
   NEWTON          =C_NEWTON(),
   CONVERGENCE     =C_CONVERGENCE(),

   SUPPORT= SIMP(statut='f',typ='TXM',max=1,into=("POINT","ELEMENT",),defaut=("POINT"),),

   b_PM = BLOC(condition="SUPPORT ==  'POINT'",fr="Simulation sans élément fini",
      FORMAT_TABLE  =SIMP(statut='f',typ='TXM',max=1,into=("CMP_COLONNE","CMP_LIGNE",),defaut=("CMP_COLONNE"),),
      NB_VARI_TABLE  =SIMP(statut='f',typ='I',max=1,),
      OPER_TANGENT  =SIMP(statut='f',typ='TXM',max=1,into=("OUI","NON",),defaut="NON",),
       ARCHIVAGE    =FACT(statut='f',
       LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
       INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
       PAS_ARCH        =SIMP(statut='f',typ='I' ),
       PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-6),
                           ),
     # on permet certaines variables de commandes scalaires, définies par une fonction du temps
     # on permet ici seulementn celles qui sont validees
      AFFE_VARC    = FACT(statut='f',max='**',
         NOM_VARC    =SIMP(statut='o',typ='TXM', into=("TEMP","IRRA","SECH")),
         VALE_FONC   = SIMP(statut='f',typ=(fonction_sdaster,formule) ),

         # VALE_REF est nécessaire pour certaines VARC :
         B_VALE_REF          =BLOC(condition="NOM_VARC in ('TEMP', 'SECH')",
            VALE_REF         =SIMP(statut='o',typ='R'),
                                  ),
                         ),
        # un mot clé caché qui ne sert qu'à boucler sur les VARC possibles :
      LIST_NOM_VARC =SIMP(statut='c',typ='TXM', defaut=("TEMP","IRRA","SECH")),

               ),
   b_EF = BLOC(condition="SUPPORT ==  'ELEMENT'",fr="Simulation sur un élément fini",
      MODELISATION  =SIMP(statut='f',typ='TXM',max=1,into=("3D","C_PLAN","D_PLAN",)),
      RECH_LINEAIRE   =C_RECH_LINEAIRE(),
      ARCHIVAGE       =C_ARCHIVAGE(),
      SUIVI_DDL       =C_SUIVI_DDL(),

     # on permet certaines variables de commandes scalaires, définies par une fonction du temps
     # a priori toutes doivent fonctionner
      AFFE_VARC    = FACT(statut='f',max='**',
         NOM_VARC        =SIMP(statut='o',typ='TXM', into=("TEMP","CORR","IRRA","HYDR","SECH","M_ACIER","M_ZIRC",
                                                           "EPSA","NEUT1","NEUT2")),
         VALE_FONC   = SIMP(statut='f',typ=(fonction_sdaster,formule) ),
         VALE_REF    = SIMP(statut='f',typ='R'),

             b_ZIRC = BLOC(condition="NOM_VARC=='M_ZIRC'",
              V1   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V2   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V3   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V4   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                          ),

             b_ACIER = BLOC(condition="NOM_VARC=='M_ACIER'",
              V1   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V2   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V3   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V4   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V5   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V6   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
              V7   = SIMP(statut='o',typ=(fonction_sdaster,formule) ),
                          ),
                         ),
        # un mot clé caché qui ne sert qu'à boucler sur les VARC possibles :
      LIST_NOM_VARC =SIMP(statut='c',typ='TXM', defaut=("TEMP","CORR","IRRA","HYDR","SECH","EPSA",
                                                              "M_ACIER","M_ZIRC","NEUT1","NEUT2")),

      SIGM_IMPOSE=FACT(statut='f',
            SIXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            SIYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            SIZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            SIXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            SIXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            SIYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                       ),
      EPSI_IMPOSE=FACT(statut='f',
            EPXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            EPYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            EPZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            EPXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            EPXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            EPYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                       ),

            ),
   b_COEF = BLOC(condition="SUPPORT ==  'POINT'",fr="matrice de coefficients",
     regles = (PRESENT_ABSENT('SIGM_IMPOSE','MATR_C1','MATR_C2','VECT_IMPO'),
               PRESENT_ABSENT('EPSI_IMPOSE','MATR_C1','MATR_C2','VECT_IMPO'),
               PRESENT_ABSENT('MATR_C1','SIGM_IMPOSE','EPSI_IMPOSE'),
               PRESENT_ABSENT('MATR_C2','SIGM_IMPOSE','EPSI_IMPOSE'),
               PRESENT_ABSENT('VECT_IMPO', 'SIGM_IMPOSE','EPSI_IMPOSE'),
               EXCLUS('EPSI_IMPOSE','GRAD_IMPOSE'),
               EXCLUS('SIGM_IMPOSE','GRAD_IMPOSE'),
               ),

     SIGM_IMPOSE=FACT(statut='f',
           SIXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SIYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SIZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SIXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SIXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SIYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                      ),
     EPSI_IMPOSE=FACT(statut='f',
           EPXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                      ),
     GRAD_IMPOSE=FACT(statut='f',
           regles = ( ENSEMBLE('F11','F12','F13','F21','F22','F23','F31','F32','F33',),),
           F11 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F12 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F13 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F21 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F22 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F23 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F31 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F32 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F33 = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                      ),
     MATR_C1=FACT(statut='f',max='**',
           VALE          =SIMP(statut='o',typ='R',max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
           NUME_COLONNE  =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=12 ),
                              ),
     MATR_C2=FACT(statut='f',max='**',
           VALE          =SIMP(statut='o',typ='R',max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
           NUME_COLONNE  =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=12 ),
                              ),
     VECT_IMPO=FACT(statut='f',max='**',
           VALE          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max=1, ),
           NUME_LIGNE    =SIMP(statut='o',typ='I',max=1,val_min=1,val_max=6 ),
                              ),
                    ),
   SIGM_INIT=FACT(statut='f',
          SIXX = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
          SIYY = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
          SIZZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
          SIXY = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
          SIXZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
          SIYZ = SIMP(statut='f',typ='R',max=1,defaut=0.0E+0),
                     ),
   EPSI_INIT=FACT(statut='f',
          EPXX = SIMP(statut='o',typ='R',max=1),
          EPYY = SIMP(statut='o',typ='R',max=1),
          EPZZ = SIMP(statut='o',typ='R',max=1),
          EPXY = SIMP(statut='o',typ='R',max=1),
          EPXZ = SIMP(statut='o',typ='R',max=1),
          EPYZ = SIMP(statut='o',typ='R',max=1),
                     ),
   VARI_INIT=FACT(statut='f',
          VALE = SIMP(statut='o',typ='R',max='**'),
                     ),

   INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: aimery.assire at edf.fr


STANLEY=MACRO(nom="STANLEY",
              op=OPS('Macro.stanley_ops.stanley_ops'),
              sd_prod=None,
              reentrant='n',
              UIinfo={"groupes":("Post-traitements",)},
              fr="Outil de post-traitement interactif Stanley ",
         RESULTAT        =SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther,mode_meca,dyna_harmo,dyna_trans) ),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         DISPLAY         =SIMP(statut='f',typ='TXM'),
         UNITE_VALIDATION=SIMP(statut='f',typ='I',val_min=10,val_max=90,
                               fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit les md5"),

)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mickael.abbas at edf.fr
#
STAT_NON_LINE=OPER(nom="STAT_NON_LINE",op=70,sd_prod=evol_noli,
                   fr="Calcul de l'évolution mécanique ou thermo-hydro-mécanique couplée, en quasi-statique,"
                      +" d'une structure en non linéaire",
                   reentrant='f',
            UIinfo={"groupes":("Résolution","Mécanique",)},

         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
         ),
         CONTACT         =SIMP(statut='f',typ=char_contact),
         SOUS_STRUC      =FACT(statut='f',min=01,max='**',
                regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                SUPER_MAILLE=SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
                FONC_MULT   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
              ),
#-------------------------------------------------------------------
         COMPORTEMENT =C_COMPORTEMENT('STAT_NON_LINE'),
#-------------------------------------------------------------------
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : ETAT_INIT obligatoire",
           ETAT_INIT       =FACT(statut='o',
             regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI',),
                  #   EXCLUS('EVOL_NOLI','DEPL',),
                  #   EXCLUS('EVOL_NOLI','SIGM',),
                  #   EXCLUS('EVOL_NOLI','VARI',),
                     EXCLUS('NUME_ORDRE','INST'), ),
             DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
             SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
             VARI            =SIMP(statut='f',typ=cham_elem),
             STRX            =SIMP(statut='f',typ=cham_elem),
             EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
             NUME_DIDI       =SIMP(statut='f',typ='I'),
             INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant : ETAT_INIT facultatif",
           ETAT_INIT       =FACT(statut='f',
             regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI',),
                   #  EXCLUS('EVOL_NOLI','DEPL',),
                   #  EXCLUS('EVOL_NOLI','SIGM',),
                   #  EXCLUS('EVOL_NOLI','VARI',),
                     EXCLUS('NUME_ORDRE','INST'), ),
             DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
             SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
             VARI            =SIMP(statut='f',typ=cham_elem),
             STRX            =SIMP(statut='f',typ=cham_elem),
             EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
             b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
             NUME_DIDI       =SIMP(statut='f',typ='I'),
             INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
#-------------------------------------------------------------------
         INCREMENT       =C_INCREMENT('MECANIQUE'),
#-------------------------------------------------------------------
         METHODE         =SIMP(statut='d',typ='TXM',defaut="NEWTON",into=("NEWTON","IMPLEX","NEWTON_KRYLOV")),
             b_meth_newton = BLOC(condition = "METHODE == 'NEWTON' or METHODE == 'NEWTON_KRYLOV'",
                                  NEWTON = C_NEWTON(),
                                  ),
#-------------------------------------------------------------------
         RECH_LINEAIRE   =C_RECH_LINEAIRE(),
#-------------------------------------------------------------------
         PILOTAGE        =C_PILOTAGE(),
#-------------------------------------------------------------------
         CONVERGENCE     =C_CONVERGENCE(),
#-------------------------------------------------------------------
         SOLVEUR         =C_SOLVEUR('STAT_NON_LINE'),
#-------------------------------------------------------------------
         OBSERVATION     =C_OBSERVATION(),
#-------------------------------------------------------------------
         SUIVI_DDL       =C_SUIVI_DDL(),
#-------------------------------------------------------------------
         ARCHIVAGE       =C_ARCHIVAGE(),
#-------------------------------------------------------------------
         CRIT_QUALITE    =FACT(statut='f',max=1,
           ERRE_TEMPS_THM  =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
                                 fr="Adaptation temporelle pour les modélisations HM instationnaires",
                                 ang="Time adaptation for unstationary HM models"),
         ),
#-------------------------------------------------------------------
         ENERGIE         =FACT(statut='f',max=1,
           CALCUL          =SIMP(statut='f',typ='TXM',into=("OUI",),defaut="OUI",),
         ),
#-------------------------------------------------------------------
         AFFICHAGE       =C_AFFICHAGE(),
#-------------------------------------------------------------------
         CRIT_STAB      =FACT(statut='f',min=1,max=1,
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,val_min=1,defaut=3),
           COEF_DIM_ESPACE =SIMP(statut='f',typ='I',max=1,val_min=2,defaut=5),
           RIGI_GEOM    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           MODI_RIGI    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
           b_char_crit  =BLOC(condition="(RIGI_GEOM=='OUI')",
              CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max=2,
                                 fr="Valeur des deux charges critiques délimitant la bande de recherche en HPP"),
                              ),
           TYPE         =SIMP(statut='f',typ='TXM',defaut="FLAMBEMENT",into=("FLAMBEMENT","STABILITE")),
           PREC_INSTAB   =SIMP(statut='f',typ='R',defaut=1.E-6,max=1,),
           SIGNE         =SIMP(statut='f',typ='TXM',defaut=("POSITIF_NEGATIF"),into=("NEGATIF","POSITIF","POSITIF_NEGATIF"),max=1,),
           b_rigi_geom  =BLOC(condition="(RIGI_GEOM=='NON')",
              DDL_EXCLUS      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=40,
                                    into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                          'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                          'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                          'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                          'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                          'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                          'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                          'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                          'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG')),),
           b_type_stab  =BLOC(condition= "TYPE == 'STABILITE' and RIGI_GEOM == 'NON'",
              DDL_STAB        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=40,
                                    into=('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                          'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                          'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                          'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                          'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                          'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                          'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C','V11','V12','V13','V21','V22',
                                          'V23','V31','V32','V33','PRES11','PRES12','PRES13','PRES21','PRES22','PRES23',
                                          'PRES31','PRES32','PRES33','VARI','LAG_GV','DAMG')),),
           regles         = (EXCLUS('PAS_CALC','LIST_INST','INST'),),
           LIST_INST      = SIMP(statut='f',typ=(listr8_sdaster) ),
           INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_CALC       = SIMP(statut='f',typ='I' ),
           CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
              b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
                 PRECISION       =SIMP(statut='o',typ='R',),),
         ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         b_info=BLOC(condition="INFO==2",
               fr="filtre les messages émis dans le .mess selon le type de message demandé",
               INFO_DBG = SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                               into=("CONTACT",
                                     "MECA_NON_LINE",
                                     "PILOTAGE",
                                     "FACTORISATION",
                                     "APPARIEMENT"),
                             ),
                    ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
 )

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jean-michel.proix at edf.fr


#              MACRO "TEST_THERMOPLASTIQUE"
#           ----------------------------
# def test_compor_sdprod(self, COMPORTEMENT, **kwargs):
#     """Ne produit une table qu'en présence de COMPORTEMENT."""
#     if COMPORTEMENT:
#         return table_sdaster
#     return None


TEST_COMPOR =MACRO(nom="TEST_COMPOR",
                   op=OPS('Macro.test_compor_ops.test_compor_ops'),
                  # sd_prod=test_compor_sdprod,
                   sd_prod=table_sdaster,
                   docu="",reentrant='n',
                   fr="macro de test des comportements incrementaux dependant de la temperature",

         OPTION         =SIMP(statut='f',typ='TXM',into=("THER","MECA"),defaut="THER"),

         COMPORTEMENT       =C_COMPORTEMENT('SIMU_POINT_MAT'),
         NEWTON          =C_NEWTON(),
         CONVERGENCE     =C_CONVERGENCE(),

         b_ther          =BLOC(condition = "OPTION == 'THER'",
            regles=(EXCLUS('C_PRAG','D_SIGM_EPSI'),),
            MATER           =SIMP(statut='o',typ=mater_sdaster,max=1,fr="materiau dependant de la temperature"),
            ALPHA           =SIMP(statut='o',typ=fonction_sdaster,
                                  fr="coefficient de dilatation fonction de la temperature"),
            YOUNG           =SIMP(statut='o',typ=fonction_sdaster,
                                  fr="module d'Young fonction de la temperature"),
            LIST_MATER      =SIMP(statut='o',typ=mater_sdaster,max='**',
                                          fr="liste des materiaux constants interpolés à chaque température"),
            TEMP_INIT       =SIMP(statut='o',typ='R', fr="temperature initiale et de reference"),
            TEMP_FIN        =SIMP(statut='o',typ='R', fr="temperature finale"),
            INST_FIN        =SIMP(statut='f',typ='R',defaut=1.,fr="instant final"),
            SUPPORT         =SIMP(statut='f',typ='TXM',max=1,into=("POINT","ELEMENT",),defaut=("POINT"),),
            NB_VARI         =SIMP(statut='o',typ='I', fr="nombre de variables internes - 0 en elasticité"),
            VARI_TEST       =SIMP(statut='f',typ='TXM',max='**',
                                  fr="liste de variables internes à tester - par defaut, toutes"),

#           special ecrouissage cinematique
            D_SIGM_EPSI     =SIMP(statut='f',typ=fonction_sdaster,
                                  fr="module tangent fonction de la temperature- VMIS_CINE_LINE"),
            C_PRAG          =SIMP(statut='f',typ=fonction_sdaster,
                                  fr="constante de Prager fonction de la temperature- VMIS_ECMI_*"),
                        ),
         b_meca          =BLOC(condition = "OPTION == 'MECA'",
            LIST_MATER      =SIMP(statut='o',typ=mater_sdaster,max=2,min=2,
                                          fr="liste des materiaux en Pa puis MPa "),
            YOUNG           =SIMP(statut='o',typ='R',fr="module d'Young"),
            POISSON         =SIMP(statut='o',typ='R',fr="coef de Poisson"),
            LIST_NPAS       =SIMP(statut='f',typ='I',max='**',
                                  fr="nombre de pas de temps pour chaque discretisation"),
            LIST_TOLE       =SIMP(statut='f',typ='R',max='**',),
            PREC_ZERO       =SIMP(statut='f',typ='R',max='**',),
            VARI_TEST       =SIMP(statut='f',typ='TXM',max='**',defaut=('V1','VMIS','TRACE'),
                                  fr="liste des CMP à tester "),
            SUPPORT         =SIMP(statut='f',typ='TXM',max=1,into=("POINT","ELEMENT",)),
            MODELISATION    =SIMP(statut='f',typ='TXM',max=1,into=("3D","C_PLAN"),defaut="3D",),
            ANGLE           =SIMP(statut='f',typ='R',max=1, defaut=0.,
             fr='Rotation de ANGLE autour de Z uniquement, et seulement pour les déformations imposées',),
            MASSIF          =FACT(statut='f',max='**',fr='orientation du materiau (monocristal, orthotropie)',
              regles=(UN_PARMI('ANGL_REP','ANGL_EULER'),),
              ANGL_REP        =SIMP(statut='f',typ='R',min=1,max=3),
              ANGL_EULER      =SIMP(statut='f',typ='R',min=1,max=3),
                                 ),
            TEST_TANGENTE   =SIMP(statut='f',typ='TXM',max=1,into=("OUI","NON"),defaut="OUI",),
            VERI_MATR_OPTION  =FACT(statut='f',max=1,fr='options pour le test de la matrice tangente',
              VALE_PERT_RELA  =SIMP(statut='f',typ='R',defaut=1.E-5),
              PRECISION       =SIMP(statut='f',typ='R',defaut=1.E-4 ),
              PREC_ZERO       =SIMP(statut='f',typ='R',defaut=1.E-12 ),
                                 ),
                               ),
            INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
                 )

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

TEST_FICHIER=MACRO(nom="TEST_FICHIER",
                   op=OPS('Macro.test_fichier_ops.test_fichier_ops'),
                   UIinfo={"groupes":("Utilitaires",)},
                   fr="Tester la non régression de fichiers produits par des commandes aster",
   FICHIER          =SIMP(statut='o',typ='TXM',validators=LongStr(1,255)),
   EXPR_IGNORE      =SIMP(statut='f',typ='TXM',max='**',
                          fr="Liste d'expressions régulières permettant d'ignorer certaines lignes"),
   NB_VALE         =SIMP(statut='o',typ='I',),

   INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
   **C_TEST_REFERENCE('FICHIER', max=1)
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: nicolas.sellenet at edf.fr

TEST_FONCTION=MACRO(nom="TEST_FONCTION",
                    op=OPS('Macro.test_fonction_ops.test_fonction_ops'),
                    sd_prod=None,
            fr="Extraction d'une valeur numérique ou d'un attribut de fonction pour comparaison à une valeur de référence",
            UIinfo={"groupes":("Fonctions","Utilitaires",)},
         TEST_NOOK       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         VALEUR          =FACT(statut='f',max='**',
                               fr="Tester la valeur d une fonction ou d une nappe",
           regles=(UN_PARMI('VALE_PARA','INTERVALLE'),),
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster,formule) ),
           NOM_PARA        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=2),
           VALE_PARA       =SIMP(statut='f',typ='R'  ,validators=NoRepeat(),max=2),
           INTERVALLE      =SIMP(statut='f',typ='R'  ,validators=NoRepeat(),min=2,max=2),
           **C_TEST_REFERENCE('FONCTION', max='**')
         ),
         ATTRIBUT        =FACT(statut='f',max='**',
                               fr="Tester la valeur d un attribut d une fonction ou d''une nappe",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster,formule) ),
           PARA            =SIMP(statut='f',typ='R' ),
           CRIT_PARA       =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PREC_PARA       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ATTR            =SIMP(statut='o',typ='TXM',
                                 into=("NOM_PARA","NOM_RESU","PROL_DROITE","PROL_GAUCHE","INTERPOL",
                                       "PROL_GAUCHE_FONC","PROL_DROITE_FONC","INTERPOL_FONC","NOM_PARA_FONC") ),
           ATTR_REFE       =SIMP(statut='o',typ='TXM' ),
           REFERENCE       =SIMP(statut='f',typ='TXM',
                                 into=("ANALYTIQUE","SOURCE_EXTERNE","AUTRE_ASTER") ),
         ),
)

# ======================================================================
# COPYRIGHT (C) 1991 - 2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
#
#
# ======================================================================
# person_in_charge: j-pierre.lefebvre at edf.fr
TEST_RESU=PROC(nom="TEST_RESU",op=23,
            UIinfo={"groupes":("Résultats et champs","Utilitaires",)},
         fr="Extraction d'une valeur d'une structure de donnée et comparaison à une valeur de référence",
         regles=(AU_MOINS_UN('CHAM_NO','CHAM_ELEM','CARTE','RESU','GENE','OBJET','TEST_NAN',)),

         CHAM_NO         =FACT(statut='f',max='**',
           regles=(EXCLUS('NOEUD','GROUP_NO'),  # EXCLUS avec 'TYPE_TEST' dans trchno.f
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT( 'GROUP_NO','NOM_CMP'),),
           CHAM_GD         =SIMP(statut='o',typ=cham_no_sdaster),
           NOEUD           =SIMP(statut='f',typ=no   ),
           GROUP_NO        =SIMP(statut='f',typ=grno ),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max=1),
           **C_TEST_REFERENCE('CHAM_NO', max='**')
         ),

         CARTE      =FACT(statut='f',max='**',
           CHAM_GD         =SIMP(statut='o',typ=carte_sdaster),
           MAILLE          =SIMP(statut='o',typ=ma),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max=1),
           **C_TEST_REFERENCE('CARTE', max=1)
         ),

         CHAM_ELEM       =FACT(statut='f',max='**',
           regles=(#UN_PARMI('MAILLE','TYPE_TEST',) dans trchel.f
                   EXCLUS('NOEUD','GROUP_NO','POINT'),
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT('GROUP_NO','NOM_CMP'),
                   PRESENT_PRESENT('POINT','NOM_CMP'),),
           CHAM_GD         =SIMP(statut='o',typ=cham_elem),
           MAILLE          =SIMP(statut='f',typ=ma),
           POINT           =SIMP(statut='f',typ='I' ),
           SOUS_POINT      =SIMP(statut='f',typ='I'),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max=1),
           **C_TEST_REFERENCE('CHAM_ELEM', max='**')
         ),

         RESU            =FACT(statut='f',max='**',
           regles=(UN_PARMI('NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGLE'),
                   UN_PARMI('NOM_CHAM','PARA'),
                   PRESENT_ABSENT('PARA','NOEUD','GROUP_NO','POINT','NOM_CMP',),
                   PRESENT_PRESENT('NOM_CMP','NOM_CHAM'),
                   EXCLUS('NOEUD','GROUP_NO','POINT'),  # EXCLUS avec 'TYPE_TEST' dans trresu.f
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT('GROUP_NO','NOM_CMP'),
                   PRESENT_PRESENT('POINT','NOM_CMP'),),
           RESULTAT        =SIMP(statut='o',typ=resultat_sdaster),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           FREQ            =SIMP(statut='f',typ='R'),
           NUME_MODE       =SIMP(statut='f',typ='I'),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',min=2,max=2),
           NOM_CAS         =SIMP(statut='f',typ='TXM'),
           ANGLE           =SIMP(statut='f',typ='R'),
           PARA            =SIMP(statut='f',typ='TXM'),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max=1),
           MAILLE          =SIMP(statut='f',typ=ma   ,max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           POINT           =SIMP(statut='f',typ='I'),
           SOUS_POINT      =SIMP(statut='f',typ='I'),
           **C_TEST_REFERENCE('RESU', max='**')
         ),

         GENE            =FACT(statut='f',max='**',
           RESU_GENE       =SIMP(statut='o',typ=(vect_asse_gene, tran_gene, mode_gene, harm_gene)),
           b_vect_asse     =BLOC(condition = "AsType(RESU_GENE) == vect_asse_gene",
             NUME_CMP_GENE   =SIMP(statut='o',typ='I'),
           ),
           b_mode          =BLOC(condition = "AsType(RESU_GENE) == mode_gene",
                            regles=(UN_PARMI('NUME_ORDRE','FREQ','NUME_MODE'),
                                    UN_PARMI('NOM_CHAM','PARA'),
                                    PRESENT_PRESENT('NOM_CHAM','NUME_CMP_GENE'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I'),
             PARA            =SIMP(statut='f',typ='TXM'),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             NUME_MODE       =SIMP(statut='f',typ='I'),
             FREQ            =SIMP(statut='f',typ='R'),
           ),
           b_harm          =BLOC(condition = "AsType(RESU_GENE) == harm_gene",
                            regles=(UN_PARMI('NUME_ORDRE','FREQ') ,),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
             NUME_CMP_GENE   =SIMP(statut='o',typ='I'),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             FREQ            =SIMP(statut='f',typ='R'),
           ),
           b_tran          =BLOC(condition = "AsType(RESU_GENE) == tran_gene",
                            regles=(UN_PARMI('NUME_ORDRE','INST') ,),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),into=C_NOM_CHAM_INTO()),
             NUME_CMP_GENE   =SIMP(statut='o',typ='I'),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
           ),
           **C_TEST_REFERENCE('GENE', max='**')
         ),

         OBJET           =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ='TXM'),
           **C_TEST_REFERENCE('OBJET', max=1)
         ),

         TEST_NAN        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr
TEST_TABLE=PROC(nom="TEST_TABLE",op= 177,
                UIinfo={"groupes":("Tables","Utilitaires",)},
                fr="Tester une cellule ou une colonne d'une table",
#  concept table_sdaster à tester
         TABLE           =SIMP(statut='o',typ=table_sdaster),
         FILTRE          =FACT(statut='f',max='**',
           NOM_PARA        =SIMP(statut='o',typ='TXM' ),
           CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                 into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                       "NON_VIDE","MAXI","MAXI_ABS","MINI","MINI_ABS") ),
           b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
              regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
              VALE            =SIMP(statut='f',typ='R',),
              VALE_I          =SIMP(statut='f',typ='I',),
              VALE_C          =SIMP(statut='f',typ='C',),
              VALE_K          =SIMP(statut='f',typ='TXM' ),),

           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         ),
         NOM_PARA        =SIMP(statut='o',typ='TXM' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         **C_TEST_REFERENCE('TABLE', max='**')
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

TEST_TEMPS=MACRO(nom="TEST_TEMPS",
                 op=OPS('Macro.test_temps_ops.test_temps_ops'),
                 sd_prod=None,
                 UIinfo={"groupes":("Utilitaires",)},
                 fr="Permet de vérifier le temps passé dans les commandes",
                 reentrant='n',

   RESU = FACT(statut='o',max='**',
      COMMANDE   = SIMP(statut='o', typ='TXM',
            fr="Nom de la commande testee"),
      NUME_ORDRE = SIMP(statut='f', typ='I', defaut=1, val_min=1,
            fr="Numero de l'occurrence de la commande testee"),
      MACHINE    = SIMP(statut='o', typ='TXM', max='**',
            fr="Liste des machines dont on a la référence"),
      VALE       = SIMP(statut='o', typ='R', max='**',
            fr="Temps CPU sur les machines listees en secondes"),
      CRITERE    = SIMP(statut='f', typ='TXM', defaut='RELATIF', into=('ABSOLU', 'RELATIF')),
      PRECISION  = SIMP(statut='f', typ='R', defaut=0.01, max='**',
            fr="Ecart admissible pour chaque machine"),
      TYPE_TEST  = SIMP(statut='o', typ='TXM', into=('USER', 'SYSTEM', 'USER+SYS', 'ELAPSED'),
            defaut='USER+SYS',
            fr="Valeur testee parmi 'USER', 'SYSTEM', 'USER+SYS', 'ELAPSED'"),
   ),

   INFO  = SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jessica.haelewyn at edf.fr
THER_LINEAIRE=OPER(nom="THER_LINEAIRE",op=25,sd_prod=evol_ther,reentrant='f',
            UIinfo={"groupes":("Résolution","Thermique",)},
                   fr="Résoudre un problème thermique linéaire stationnaire ou transitoire",
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_ther,char_cine_ther)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),
         ETAT_INIT       =FACT(statut='f',
           regles=(EXCLUS('STATIONNAIRE','EVOL_THER','CHAM_NO','VALE'),),
           STATIONNAIRE    =SIMP(statut='f',typ='TXM',into=("OUI",)),
           EVOL_THER       =SIMP(statut='f',typ=evol_ther),
           CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
           VALE            =SIMP(statut='f',typ='R'),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),
#-------------------------------------------------------------------
         INCREMENT       =C_INCREMENT('THERMIQUE'),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('THER_LINEAIRE'),
#-------------------------------------------------------------------
         PARM_THETA      =SIMP(statut='f',typ='R',defaut= 0.57),
#-------------------------------------------------------------------
         ARCHIVAGE       =C_ARCHIVAGE(),
#-------------------------------------------------------------------
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2)),
)  ;

# ======================================================================
# COPYRIGHT (C)1991-2026EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jessica.haelewyn at edf.fr
THER_NON_LINE=OPER(nom="THER_NON_LINE",op= 186,sd_prod=evol_ther,reentrant='f',
            UIinfo={"groupes":("Résolution","Thermique",)},
                   fr="Résoudre un problème thermique non linéaire (conditions limites ou comportement matériau)"
                      +" stationnaire ou transitoire" ,
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         CHAM_MATER      =SIMP(statut='o',typ=(cham_mater) ),
         CARA_ELEM       =SIMP(statut='c',typ=(cara_elem) ),
         COMPORTEMENT    =FACT(statut='d',max='**',
           RELATION        =SIMP(statut='f',typ='TXM',defaut="THER_NL",
                                 into=("THER_NL",
                                       "THER_HYDR",
                                       "SECH_GRANGER",
                                       "SECH_MENSI",
                                       "SECH_BAZANT",
                                       "SECH_NAPPE"
                                       ) ),
         regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         ),
         EVOL_THER_SECH  =SIMP(statut='f',typ=evol_ther),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_ther),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),
#-------------------------------------------------------------------
         INCREMENT       =C_INCREMENT('THERMIQUE'),
#-------------------------------------------------------------------
         ETAT_INIT       =FACT(statut='f',
           regles=(EXCLUS('STATIONNAIRE','EVOL_THER','CHAM_NO','VALE'),),
           STATIONNAIRE    =SIMP(statut='f',typ='TXM',into=("OUI",)),
           EVOL_THER       =SIMP(statut='f',typ=evol_ther),
           CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
           VALE            =SIMP(statut='f',typ='R'),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,),),
           b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
              PRECISION       =SIMP(statut='o',typ='R',),),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),
         NEWTON          =FACT(statut='d',
           REAC_ITER       =SIMP(statut='f',typ='I',defaut= 0 ,val_min=0),
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         CONVERGENCE     =FACT(statut='d',
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
         ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('THER_NON_LINE'),
#-------------------------------------------------------------------
         PARM_THETA      =SIMP(statut='f',typ='R',defaut= 0.57 ),
#-------------------------------------------------------------------
         ARCHIVAGE       =C_ARCHIVAGE(),
#-------------------------------------------------------------------
         OBSERVATION     =C_OBSERVATION(),
#------------------------------------------------------------------- 
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),

)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# person_in_charge: jessica.haelewyn at edf.fr
THER_NON_LINE_MO=OPER(nom="THER_NON_LINE_MO",op= 171,sd_prod=evol_ther,
                     fr="Résoudre un problème thermique non linéaire (conditions limites ou comportement matériau)"
                        +" stationnaire avec chargement mobile",
                     reentrant='n',
            UIinfo={"groupes":("Résolution","Thermique",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='c',typ=cara_elem ),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_ther ),
           FONC_MULT       =SIMP(statut='c',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         ETAT_INIT       =FACT(statut='f',
           EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         CONVERGENCE     =FACT(statut='d',
           CRIT_TEMP_RELA  =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRIT_ENTH_RELA  =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ARRET           =SIMP(statut='c',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
#-------------------------------------------------------------------
#        Catalogue commun SOLVEUR
         SOLVEUR         =C_SOLVEUR('THER_NON_LINE_MO'),
#-------------------------------------------------------------------
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;

# ======================================================================
# COPYRIGHT (C) 1991-2026  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

# Vérification des imports et définitions non autorisés dans le catalogue
UNAUTHORIZED = ("numpy", "UTMESS", "Table", "Graph")

for _name in UNAUTHORIZED:
    _obj = globals().get(_name, None)
    assert _obj is None, "Definition de '%s' interdite dans le catalogue." % _name

assert aster_exists or aster is None

